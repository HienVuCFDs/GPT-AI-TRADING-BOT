# === ANTI-CRASH PROTECTION SYSTEM ===
import sys
import os
import json
import pickle
import logging
import hashlib
import threading
import traceback
import signal
from datetime import datetime, timedelta, timezone
from typing import List, Dict, Any, Optional
import subprocess
import glob

# === LICENSE SERVER CONFIGURATION ===
# Thay Ä‘á»•i URL nÃ y khi deploy production
# Development: http://localhost:8000/api
# Ngrok:       https://xxx.ngrok-free.dev/api
# Production:  https://your-domain.com/api
LICENSE_SERVER_URL = "http://localhost:8000/api"

# === LICENSE GUARD INTEGRATION ===
try:
    from license_guard import get_license_guard, LicenseConfig
    LICENSE_GUARD_AVAILABLE = True
except ImportError:
    LICENSE_GUARD_AVAILABLE = False
    print("âš ï¸ license_guard.py not found - running without local protection")

# === REDIS CACHE INTEGRATION ===
try:
    from unified_auto_trading_system import CacheManager
    CACHE_MANAGER = CacheManager(host='localhost', port=6379)
    if CACHE_MANAGER.enabled:
        logger_cache = logging.getLogger('redis_cache')
        logger_cache.info("âœ… Redis cache initialized - 4-5x performance boost enabled")
    else:
        CACHE_MANAGER = None
        logger_cache = logging.getLogger('redis_cache')
        logger_cache.warning("âš ï¸ Redis cache disabled - running in normal mode (slower)")
except Exception as e:
    CACHE_MANAGER = None
    print(f"âš ï¸ Redis cache error: {e}")

# Setup logger for app.py
logger = logging.getLogger(__name__)
if not logger.handlers:
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler('logs/app.log', encoding='utf-8'),
            logging.StreamHandler(sys.stdout)  # Use stdout for proper encoding
        ]
    )
    # Force UTF-8 encoding on all handlers
    for handler in logging.getLogger().handlers:
        if hasattr(handler, 'setEncoding'):
            handler.setEncoding('utf-8')

# Global exception handler to prevent crashes
def global_exception_handler(exc_type, exc_value, exc_traceback):
    """Global exception handler - prevents app crash on unhandled exceptions"""
    try:
        # Log the error
        error_msg = f"CRITICAL ERROR: {exc_type.__name__}: {str(exc_value)}"
        # Print without emojis to avoid encoding issues
        print(f"\n[!] {error_msg}")
        
        # Save crash log
        crash_log = f"logs/crash_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log"
        os.makedirs("logs", exist_ok=True)
        
        with open(crash_log, 'w', encoding='utf-8') as f:
            f.write(f"Crash Time: {datetime.now()}\n")
            f.write(f"Error Type: {exc_type.__name__}\n")
            f.write(f"Error Message: {str(exc_value)}\n\n")
            f.write("Full Traceback:\n")
            traceback.print_exception(exc_type, exc_value, exc_traceback, file=f)
        
        print(f"[SAVE] Crash details saved to: {crash_log}")
        print("[CONTINUE] App will continue running...")
        
        # Continue running instead of crashing
        return True
        
    except Exception as e:
        print(f"[ERROR] Error in exception handler: {e}")
        # Last resort - don't crash even if logging fails
        return True

# Signal handler for graceful shutdown
def signal_handler(signum, frame):
    """Handle SIGTERM and SIGINT for graceful shutdown"""
    print(f"\n[STOP] Received signal {signum} - initiating graceful shutdown...")
    try:
        emergency_cleanup()
    except Exception as e:
        print(f"Emergency cleanup failed during shutdown: {e}")
    sys.exit(0)

# Install global exception handler and signal handlers
sys.excepthook = global_exception_handler
signal.signal(signal.SIGTERM, signal_handler)
signal.signal(signal.SIGINT, signal_handler)

def safe_method(func):
    """Decorator to make any method crash-proof"""
    def wrapper(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except Exception as e:
            method_name = getattr(func, '__name__', 'unknown_method')
            class_name = ""
            if args and hasattr(args[0], '__class__'):
                class_name = f"{args[0].__class__.__name__}."
            
            error_msg = f"ðŸ›¡ï¸ Safe method caught error in {class_name}{method_name}: {type(e).__name__}: {str(e)}"
            print(error_msg)
            
            # Log detailed error for debugging
            try:
                log_file = f"logs/method_errors_{datetime.now().strftime('%Y%m%d')}.log"
                os.makedirs("logs", exist_ok=True)
                with open(log_file, 'a', encoding='utf-8') as f:
                    f.write(f"\n{datetime.now()} - {error_msg}\n")
                    f.write(f"Traceback: {traceback.format_exc()}\n")
            except:
                pass  # Don't crash even if logging fails
            
            # Return safe defaults based on expected return type
            return None
    return wrapper

# Signal handlers for graceful shutdown
def signal_handler(signum, frame):
    """Handle system signals gracefully"""
    print(f"\nðŸ›‘ Received signal {signum} - shutting down gracefully...")
    try:
        # Try graceful cleanup
        if 'QApplication' in sys.modules:
            from PyQt5.QtWidgets import QApplication
            app = QApplication.instance()
            if app:
                app.quit()
    except Exception as e:
        print(f"Error during Qt cleanup: {e}")
    sys.exit(0)

# Install signal handlers
signal.signal(signal.SIGINT, signal_handler)
signal.signal(signal.SIGTERM, signal_handler)

# === NOTIFICATION SETTINGS UTILITY FUNCTIONS ===

def load_notification_settings():
    """Load notification settings from config file"""
    config_file = 'notification_config.json'
    default_settings = {
        'telegram_enabled': True,
        'discord_enabled': False,
        'email_enabled': False,
        'min_confidence': 50
    }
    
    try:
        if os.path.exists(config_file):
            with open(config_file, 'r', encoding='utf-8') as f:
                config = json.load(f)
                settings = config.get('settings', {})
                # Merge with defaults
                for key, value in default_settings.items():
                    if key not in settings:
                        settings[key] = value
                return settings
        return default_settings
    except Exception as e:
        print(f"Error loading notification settings: {e}")
        return default_settings

def save_notification_settings(settings):
    """Save notification settings to config file"""
    config_file = 'notification_config.json'
    
    try:
        # Load existing config
        config = {}
        if os.path.exists(config_file):
            with open(config_file, 'r', encoding='utf-8') as f:
                config = json.load(f)
        
        # Update settings section
        config['settings'] = settings
        
        # Save back to file
        with open(config_file, 'w', encoding='utf-8') as f:
            json.dump(config, f, indent=2, ensure_ascii=False)
        
        print(f"Notification settings saved: {settings}")
        
    except Exception as e:
        print(f"Error saving notification settings: {e}")

# === END UTILITY FUNCTIONS ===

# Try to import dotenv
try:
    from dotenv import load_dotenv
    DOTENV_AVAILABLE = True
except ImportError:
    DOTENV_AVAILABLE = False

# Try to import PyQt5 for GUI
try:
    from PyQt5.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QHBoxLayout, QTabWidget, QTableWidget, QTableWidgetItem, QHeaderView,
    QPushButton, QLabel, QLineEdit, QComboBox, QSpinBox, QDoubleSpinBox, QTextEdit, QCheckBox, QMessageBox,
    QGroupBox, QInputDialog, QToolButton, QMenu, QAction, QActionGroup, QDialog, QGridLayout, QTextBrowser,
    QStackedWidget, QFormLayout, QFrame
    )
    from PyQt5.QtCore import Qt, QThread, pyqtSignal, QTimer, QRunnable, QThreadPool, QObject, QUrl
    from PyQt5.QtGui import QIcon, QFont, QColor, QDesktopServices
    GUI_AVAILABLE = True
except ImportError:
    GUI_AVAILABLE = False

# Simple global app state for language preference
class AppState:
    _lang = 'vi'  # Back to Vietnamese

    @classmethod
    def set_language(cls, lang: str):
        if not lang:
            return
        lang = lang.lower()
        if lang not in ('en', 'vi'):
            return
        if cls._lang != lang:
            cls._lang = lang
            # Persist to user config
            try:
                cfg = load_user_config(apply_lang=False)
                cfg['language'] = cls._lang
                save_user_config(cfg)
            except Exception as e:
                logging.warning(f"Unable to persist language preference: {e}")

    @classmethod
    def language(cls) -> str:
        return cls._lang

# Simple i18n helper for UI notifications
class I18N:
    @staticmethod
    def t(en: str, vi: str | None = None, **kwargs) -> str:
        """Return localized text; format with kwargs if provided.
        Usage: I18N.t("Title EN", "TiÃªu Ä‘á» VI"); I18N.t("Hello {name}", "Xin chÃ o {name}", name="An")
        """
        txt = None
        if AppState.language() == 'vi' and vi:
            txt = vi
        else:
            txt = en
        try:
            return txt.format(**kwargs)
        except Exception:
            return txt

    # Common static UI translations to cover widgets without explicit retranslate methods
    EN_TO_VI = {
        # Main Tab Names (CRITICAL FOR LANGUAGE SWITCHING)
        "ðŸ¦ MT5 Account": "ðŸ¦ TÃ i khoáº£n MT5",
        "ðŸ’¹ Market Data": "ðŸ’¹ Dá»¯ liá»‡u thá»‹ trÆ°á»ng",
        "ðŸ“ˆ Trend Analysis": "ðŸ“ˆ PhÃ¢n tÃ­ch xu hÆ°á»›ng", 
        "âš™ï¸ Technical Indicators": "âš™ï¸ Chá»‰ bÃ¡o ká»¹ thuáº­t",
        "ðŸ•¯ï¸ Candlestick Patterns": "ðŸ•¯ï¸ MÃ´ hÃ¬nh náº¿n",
        "ðŸ“Š Price Patterns": "ðŸ“Š MÃ´ hÃ¬nh giÃ¡",
        "ðŸ“° Economic News": "ðŸ“° Tin tá»©c kinh táº¿",
        "ðŸ›¡ï¸ Risk Management": "ðŸ›¡ï¸ Quáº£n lÃ½ rá»§i ro",
        "ðŸ“¡ Signal": "ðŸ“¡ TÃ­n hiá»‡u",
        "ðŸ¤– Auto Trading": "ðŸ¤– Giao dá»‹ch tá»± Ä‘á»™ng",
        
        # Generic
        "One Click Trading": "Giao dá»‹ch má»™t cháº¡m",
        "Volume:": "Khá»‘i lÆ°á»£ng:",
        "Spread:": "ChÃªnh lá»‡ch:",
        "Remove": "XÃ³a",
        # Menu / global
        "Login": "ÄÄƒng nháº­p",
        "Register": "ÄÄƒng kÃ½",
        "Status: Connected": "Tráº¡ng thÃ¡i: ÄÃ£ káº¿t ná»‘i",
        "Status: Disconnected": "Tráº¡ng thÃ¡i: Máº¥t káº¿t ná»‘i",
        "ðŸŸ¢ Status: Connected": "ðŸŸ¢ Tráº¡ng thÃ¡i: ÄÃ£ káº¿t ná»‘i",
        "ðŸ”´ Status: Connection Failed": "ðŸ”´ Tráº¡ng thÃ¡i: Káº¿t ná»‘i tháº¥t báº¡i",
        # News tab headers
        "Impact": "TÃ¡c Ä‘á»™ng",
        "Event": "Sá»± kiá»‡n", 
        "Actual": "Thá»±c táº¿",
        "Forecast": "Dá»± bÃ¡o",
        # News tab UI elements
        "Filters": "Bá»™ lá»c",
        "Currency:": "Tiá»n tá»‡:",
        "Auto Trading Integration": "TÃ­ch há»£p giao dá»‹ch tá»± Ä‘á»™ng",
        "âœ… Enable News detection": "âœ… Báº­t phÃ¡t hiá»‡n tin tá»©c",
        "Data Source:": "Nguá»“n dá»¯ liá»‡u:",
        "System:": "Há»‡ thá»‘ng:",
        "Date:": "NgÃ y:",
        "Found": "TÃ¬m tháº¥y",
        "events": "sá»± kiá»‡n",
        "Timezone:": "MÃºi giá»:",
        "All times displayed in": "Táº¥t cáº£ thá»i gian hiá»ƒn thá»‹ theo",
        "Vietnam Time (UTC+7)": "Giá» Viá»‡t Nam (UTC+7)",
        # Auto Schedule translations
        "Auto News Schedule Status": "Tráº¡ng thÃ¡i lá»‹ch tin tá»©c tá»± Ä‘á»™ng",
        "ðŸ¤– Auto-schedule: Initializing...": "ðŸ¤– Lá»‹ch tá»± Ä‘á»™ng: Äang khá»Ÿi táº¡o...",
        "ðŸ“… Scheduled Times: None": "ðŸ“… Giá» Ä‘Ã£ lÃªn lá»‹ch: ChÆ°a cÃ³",
        "â° Next Auto-Fetch: Calculating...": "â° QuÃ©t tin tiáº¿p theo: Äang tÃ­nh...",
        "ðŸ¤– System Active": "ðŸ¤– Há»‡ thá»‘ng hoáº¡t Ä‘á»™ng",
        "âœ… Active": "âœ… Hoáº¡t Ä‘á»™ng",
        "ðŸ”„ Fallback Mode": "ðŸ”„ Cháº¿ Ä‘á»™ dá»± phÃ²ng",
        "âŒ Fetch Error": "âŒ Lá»—i táº£i tin",
        # Fix common typos
        "ThÃ¡i gian": "Thá»i gian",
        "Previous": "TrÆ°á»›c Ä‘Ã³",
        "Status": "Tráº¡ng thÃ¡i",
        # Chart controls
        "Start Chart": "Báº¯t Ä‘áº§u biá»ƒu Ä‘á»“",
        "Stop Chart": "Dá»«ng biá»ƒu Ä‘á»“",
        "Start Live Updates": "Báº¯t Ä‘áº§u cáº­p nháº­t trá»±c tiáº¿p", 
        "Stop": "Dá»«ng",
        # Market data
        "Fetch Data Now": "Láº¥y dá»¯ liá»‡u ngay",
        "Fetch News": "Láº¥y tin tá»©c",
        "Connected to MT5 - Ready to fetch data": "ÄÃ£ káº¿t ná»‘i MT5 - Sáºµn sÃ ng láº¥y dá»¯ liá»‡u",
        "Current Drawdown:": "Má»©c sá»¥t giáº£m hiá»‡n táº¡i:",
        "Active Positions:": "Vá»‹ tháº¿ Ä‘ang má»Ÿ:",
        "Today's P&L:": "LÃ£i/lá»— hÃ´m nay:",
        "Risk Level:": "Má»©c rá»§i ro:",
        "ðŸ“Š Recent Signal Validations": "ðŸ“Š Kiá»ƒm Ä‘á»‹nh tÃ­n hiá»‡u gáº§n Ä‘Ã¢y",
        "ðŸ’¼ Current Positions": "ðŸ’¼ Vá»‹ tháº¿ hiá»‡n táº¡i",
        "ðŸŽ® Control Panel": "ðŸŽ® Báº£ng Ä‘iá»u khiá»ƒn",
        "Trading Mode:": "Cháº¿ Ä‘á»™ giao dá»‹ch:",
        "ðŸ’¾ Save Settings": "ðŸ’¾ LÆ°u cÃ i Ä‘áº·t",
        "ðŸ“ Load Settings": "ðŸ“ Táº£i cÃ i Ä‘áº·t",
        "ðŸ”„ Reset to Default": "ðŸ”„ Äáº·t láº¡i máº·c Ä‘á»‹nh",
        "ðŸ“Š Generate Report": "ðŸ“Š Táº¡o bÃ¡o cÃ¡o",
        # Auto Trading tab
        "Auto Trading: OFF": "Giao dá»‹ch tá»± Ä‘á»™ng: Táº®T",
        "Auto Trading: ON": "Giao dá»‹ch tá»± Ä‘á»™ng: Báº¬T",
        "Start Auto Trading": "Báº¯t Ä‘áº§u giao dá»‹ch tá»± Ä‘á»™ng",
        # Indicator tab
        "Add Indicator": "ThÃªm chá»‰ bÃ¡o",
        "Add All": "ThÃªm táº¥t cáº£",
        "Calculate & Save Indicator": "TÃ­nh & lÆ°u chá»‰ bÃ¡o",
        "Period:": "Chu ká»³:",
        "Type:": "Loáº¡i:",
        "Fast:": "Nhanh:",
        "Slow:": "Cháº­m:",
        "Signal:": "TÃ­n hiá»‡u:",
        "Smooth:": "LÃ m mÆ°á»£t:",
        "Window:": "Cá»­a sá»•:",
        "Dev:": "Äá»™ lá»‡ch:",
        "Step:": "BÆ°á»›c:",
        "Max Step:": "BÆ°á»›c tá»‘i Ä‘a:",
        "Smooth1:": "LÃ m mÆ°á»£t1:",
        "Smooth2:": "LÃ m mÆ°á»£t2:",
        "Short:": "Ngáº¯n:",
        "Medium:": "Trung bÃ¬nh:",
        "Long:": "DÃ i:",
        "Lookback:": "NhÃ¬n láº¡i:",
        "Tenkan:": "Tenkan:",
        "Kijun:": "Kijun:",
        "Senkou:": "Senkou:",
        "Percent:": "Pháº§n trÄƒm:",
        # Pattern tabs
        "Enable candlestick pattern detection": "Báº­t phÃ¡t hiá»‡n mÃ´ hÃ¬nh náº¿n",
    "ðŸ“Š Min confidence:": "ðŸ“Š Äá»™ tin cáº­y tá»‘i thiá»ƒu:",
        "No patterns loaded": "ChÆ°a táº£i mÃ´ hÃ¬nh",
        "ðŸ” Fetch Candlestick Patterns": "ðŸ” Láº¥y mÃ´ hÃ¬nh náº¿n",
        "Enable price pattern detection": "Báº­t phÃ¡t hiá»‡n mÃ´ hÃ¬nh giÃ¡",
        "ðŸ“… Max age (days):": "ðŸ“… Tuá»•i tá»‘i Ä‘a (ngÃ y):",
        "ðŸ” Fetch Price Patterns": "ðŸ” Láº¥y mÃ´ hÃ¬nh giÃ¡",
        # Trend tab
        "Enable Trend Detection": "Báº­t phÃ¡t hiá»‡n xu hÆ°á»›ng",
        "Calculate Trendline & SR": "TÃ­nh Trendline & S/R",
    # Common table headers
    "Ticket": "MÃ£ lá»‡nh",
    "Symbol": "Cáº·p tiá»n",
    "Time": "Thá»i gian",
    "Action": "HÃ nh Ä‘á»™ng",
    "Actions": "HÃ nh Ä‘á»™ng",
    "Result": "Káº¿t quáº£",
    "Risk Score": "Äiá»ƒm rá»§i ro",
    "Volume": "Khá»‘i lÆ°á»£ng",
    "Type": "Loáº¡i",
    "Open Price": "GiÃ¡ má»Ÿ",
    "Current Price": "GiÃ¡ hiá»‡n táº¡i",
    "Stop Loss": "Cáº¯t lá»—",
    "Take Profit": "Chá»‘t lÃ£i",
    "Swap": "Swap",
    "Profit": "LÃ£i/Lá»—",
    
    # MT5 Account Tab
    "ðŸ“¡ Connection Status": "ðŸ“¡ Tráº¡ng thÃ¡i Káº¿t ná»‘i",
    "ðŸ”´ Status: Disconnected": "ðŸ”´ Tráº¡ng thÃ¡i: Ngáº¯t káº¿t ná»‘i",
    "ðŸŸ¢ Status: Connected": "ðŸŸ¢ Tráº¡ng thÃ¡i: ÄÃ£ káº¿t ná»‘i",
    "ðŸ”´ Status: Connection Failed": "ðŸ”´ Tráº¡ng thÃ¡i: Káº¿t ná»‘i Tháº¥t báº¡i",
    "ðŸ”„ Connecting...": "ðŸ”„ Äang káº¿t ná»‘i...",
    "âœ… Connected": "âœ… ÄÃ£ káº¿t ná»‘i",
    "MT5 Account Login": "ÄÄƒng nháº­p TÃ i khoáº£n MT5",
    "Account:": "TÃ i khoáº£n:",
    "Password:": "Máº­t kháº©u:",
    "Server:": "MÃ¡y chá»§:",
    "Save Account Info": "LÆ°u thÃ´ng tin tÃ i khoáº£n",
    "ðŸ”‘ Login to MT5": "ðŸ”‘ ÄÄƒng nháº­p MT5",
    "ðŸ”“ Disconnect": "ðŸ”“ Ngáº¯t káº¿t ná»‘i",
    "Account Information": "ThÃ´ng tin TÃ i khoáº£n",
    "Login:": "TÃ i khoáº£n:",
    "Name:": "TÃªn:",
    "Company:": "CÃ´ng ty:",
    "Currency:": "Tiá»n tá»‡:",
    "Leverage:": "ÄÃ²n báº©y:",
    "ðŸ’° Balance Information": "ðŸ’° ThÃ´ng tin Sá»‘ dÆ°",
    "Balance:": "Sá»‘ dÆ°:",
    "Equity:": "Vá»‘n thá»±c:",
    "Margin Used:": "KÃ½ quá»¹ sá»­ dá»¥ng:",
    "Free Margin:": "KÃ½ quá»¹ kháº£ dá»¥ng:",
    "Margin Level:": "Má»©c kÃ½ quá»¹:",
    "Profit/Loss:": "LÃ£i/Lá»—:",
    "ðŸ“ˆ Trading Status": "ðŸ“ˆ Tráº¡ng thÃ¡i Giao dá»‹ch",
    "Open Positions:": "Vá»‹ tháº¿ Ä‘ang má»Ÿ:",
    "Pending Orders:": "Lá»‡nh chá»:",
    "Trade Allowed:": "Cho phÃ©p giao dá»‹ch:",
    "ðŸ“Š Active Positions": "ðŸ“Š Vá»‹ tháº¿ Äang má»Ÿ",
    "ðŸš« Close All Positions": "ðŸš« ÄÃ³ng Táº¥t cáº£ Vá»‹ tháº¿",
    "ðŸ”„ Refresh Positions": "ðŸ”„ LÃ m má»›i Vá»‹ tháº¿",
    "ðŸ“‹ Pending Orders": "ðŸ“‹ Lá»‡nh Chá»",
    "âŒ Cancel All Orders": "âŒ Há»§y Táº¥t cáº£ Lá»‡nh",
    "ðŸ”„ Refresh Orders": "ðŸ”„ LÃ m má»›i Lá»‡nh",
    "Swap": "HoÃ¡n Ä‘á»•i",
    "Profit": "Lá»£i nhuáº­n",
    "Actions": "Thao tÃ¡c",
    "Price": "GiÃ¡",
    "P&L": "LÃ£i/Lá»—",
    "Max Exposure (lots)": "Khá»‘i lÆ°á»£ng tá»‘i Ä‘a (lot)",
    "Risk Multiplier": "Há»‡ sá»‘ rá»§i ro",
    "Indicator": "Chá»‰ bÃ¡o",
    "Value": "GiÃ¡ trá»‹",
    "Timeframe": "Khung thá»i gian",
    "Pattern": "MÃ´ hÃ¬nh",
    "Length": "Äá»™ dÃ i",
    "Signal": "TÃ­n hiá»‡u",
    "Confidence": "Äá»™ tin cáº­y",
    "Time Period": "Khoáº£ng thá»i gian",
    "Age": "Tuá»•i",
    # Additional risk management translations
    "Fixed Pips": "Pips cá»‘ Ä‘á»‹nh",
    "ATR Multiple": "Bá»™i sá»‘ ATR",
    "Support/Resistance": "Há»— trá»£/KhÃ¡ng cá»±",
    "Percentage": "Pháº§n trÄƒm",
    "Fixed Distance": "Khoáº£ng cÃ¡ch cá»‘ Ä‘á»‹nh",
    "Fibonacci Levels": "Má»©c Fibonacci",
    "Individual SL": "SL riÃªng láº»",
    "Average SL": "SL trung bÃ¬nh",
    # "Breakeven Only": "Chá»‰ hÃ²a vá»‘n", # REMOVED: No longer supported
    "âœ… Risk Management System: Active": "âœ… Há»‡ thá»‘ng quáº£n lÃ½ rá»§i ro: Hoáº¡t Ä‘á»™ng",
    "âŒ Risk Management System: Not Available": "âŒ Há»‡ thá»‘ng quáº£n lÃ½ rá»§i ro: KhÃ´ng kháº£ dá»¥ng",
    "âŒ Risk Manager Error:": "âŒ Lá»—i quáº£n lÃ½ rá»§i ro:",
    "ðŸ’¡ Enable Auto Mode": "ðŸ’¡ Báº­t cháº¿ Ä‘á»™ tá»± Ä‘á»™ng",
    "ðŸ”• Disable Emergency Stop": "ðŸ”• Táº¯t dá»«ng kháº©n cáº¥p",
    "ðŸ”• Disable News Avoidance": "ðŸ”• Táº¯t trÃ¡nh tin tá»©c",
    "ðŸ”• Disable Max DD Close": "ðŸ”• Táº¯t Ä‘Ã³ng khi Max DD",
    "Enable Auto Account Scanning": "Báº­t quÃ©t tÃ i khoáº£n tá»± Ä‘á»™ng",
    "Auto Scan Interval (hours):": "Khoáº£ng thá»i gian quÃ©t tá»± Ä‘á»™ng (giá»):",
    "Account Tier:": "Cáº¥p tÃ i khoáº£n:",
    "Last Auto Adjustment:": "Äiá»u chá»‰nh tá»± Ä‘á»™ng cuá»‘i:",
    "Emergency Stop Active": "Dá»«ng kháº©n cáº¥p hoáº¡t Ä‘á»™ng",
    "Emergency Stop Inactive": "Dá»«ng kháº©n cáº¥p khÃ´ng hoáº¡t Ä‘á»™ng",
    "News Avoidance Active": "TrÃ¡nh tin tá»©c hoáº¡t Ä‘á»™ng",
    "News Avoidance Inactive": "TrÃ¡nh tin tá»©c khÃ´ng hoáº¡t Ä‘á»™ng",
    "Max DD Close Active": "ÄÃ³ng Max DD hoáº¡t Ä‘á»™ng",
    "Max DD Close Inactive": "ÄÃ³ng Max DD khÃ´ng hoáº¡t Ä‘á»™ng",
    "Auto Scan Active": "QuÃ©t tá»± Ä‘á»™ng hoáº¡t Ä‘á»™ng",
    "Auto Scan Inactive": "QuÃ©t tá»± Ä‘á»™ng khÃ´ng hoáº¡t Ä‘á»™ng",
    # Risk Management Tab - GroupBoxes
    "ðŸ›¡ï¸ RISK MANAGEMENT CENTER": "ðŸ›¡ï¸ TRUNG TÃ‚M QUáº¢N LÃ Rá»¦I RO",
    "âš™ï¸ Basic Settings": "âš™ï¸ CÃ i Ä‘áº·t cÆ¡ báº£n",
    "ðŸ“Š Position Management": "ðŸ“Š Quáº£n lÃ½ vá»‹ tháº¿",
    "ðŸ”§ Advanced Controls": "ðŸ”§ Äiá»u khiá»ƒn nÃ¢ng cao",
    "ðŸ“ˆ DCA Strategy": "ðŸ“ˆ Chiáº¿n lÆ°á»£c DCA",
    "ðŸŽ¯ Risk Limits": "ðŸŽ¯ Giá»›i háº¡n rá»§i ro",
    "ðŸ“ Position Sizing": "ðŸ“ KÃ­ch thÆ°á»›c vá»‹ tháº¿",
    "ðŸŽ¯ Stop Loss / Take Profit": "ðŸŽ¯ Cáº¯t lá»— / Chá»‘t lá»i",
    "ðŸŽ¯ Breakeven & Trailing Stop": "ðŸŽ¯ Äiá»ƒm HÃ²a Vá»‘n - Dá»«ng Lá»— KÃ©o Theo",
    "ðŸ“Š Position Limits": "ðŸ“Š Giá»›i háº¡n vá»‹ tháº¿",
    "ðŸ’¼ Symbol Exposure Limits": "ðŸ’¼ Giá»›i háº¡n má»©c Ä‘á»™ theo mÃ£",
    "ðŸ• Trading Hours (UTC)": "ðŸ• Giá» giao dá»‹ch (UTC)",
    "ðŸ“Š Market Conditions": "ðŸ“Š Äiá»u kiá»‡n thá»‹ trÆ°á»ng",
    "ðŸš¨ Emergency Controls": "ðŸš¨ Äiá»u khiá»ƒn kháº©n cáº¥p",
    "ðŸ“ˆ DCA Strategy Settings": "ðŸ“ˆ CÃ i Ä‘áº·t chiáº¿n lÆ°á»£c DCA",
    "âš™ï¸ DCA Activation Conditions": "âš™ï¸ Äiá»u kiá»‡n kÃ­ch hoáº¡t DCA",
    # Risk Management Tab - Labels
    "Max Risk per Trade (%):": "Rá»§i ro tá»‘i Ä‘a má»—i lá»‡nh (%):",
    "Max Drawdown (%):": "Sá»¥t giáº£m tá»‘i Ä‘a (%):",
    "Daily Loss Limit (%):": "Giá»›i háº¡n lá»— ngÃ y (%):",
    "Volume Settings:": "CÃ i Ä‘áº·t khá»‘i lÆ°á»£ng:",
    "Risk-Based (Auto)": "Theo rá»§i ro (Tá»± Ä‘á»™ng)",
    "Fixed Volume": "Khá»‘i lÆ°á»£ng cá»‘ Ä‘á»‹nh",
    "Default Volume": "Khá»‘i lÆ°á»£ng máº·c Ä‘á»‹nh",
    "Min Lot Size:": "Khá»‘i lÆ°á»£ng nhá» nháº¥t (tá»± Ä‘á»™ng):",
    "Max Lot Size:": "Tá»•ng khá»‘i lÆ°á»£ng tá»‘i Ä‘a:",
    "Max Total Positions:": "Tá»‘i Ä‘a tá»•ng vá»‹ tháº¿:",
    "Max Positions per Symbol:": "Tá»‘i Ä‘a vá»‹ tháº¿ má»—i mÃ£:",
    "Max Correlation:": "TÆ°Æ¡ng quan tá»‘i Ä‘a:",
    "Start Time:": "Giá» báº¯t Ä‘áº§u:",
    "End Time:": "Giá» káº¿t thÃºc:",
    "Avoid News (minutes):": "TrÃ¡nh tin tá»©c (phÃºt):",
    "Max Spread Multiplier:": "Há»‡ sá»‘ spread tá»‘i Ä‘a:",
    "Max Slippage:": "Äá»™ trÆ°á»£t giÃ¡ tá»‘i Ä‘a:",
    "Emergency Stop DD (%):": "Dá»«ng kháº©n cáº¥p DD (%):",
    "Auto Reduce Position Size on Losses": "Tá»± Ä‘á»™ng giáº£m khá»‘i lÆ°á»£ng khi thua lá»—",
    "â„¹ï¸ Use Account Tab for position management and closing orders": "â„¹ï¸ DÃ¹ng tab TÃ i khoáº£n Ä‘á»ƒ quáº£n lÃ½ vÃ  Ä‘Ã³ng lá»‡nh",
    # DCA Settings Tab - Labels
    "Enable DCA Strategy": "Báº­t chiáº¿n lÆ°á»£c DCA",
    "Max DCA Levels:": "Sá»‘ táº§ng DCA tá»‘i Ä‘a:",
    "Volume Multiplier:": "Há»‡ sá»‘ nhÃ¢n khá»‘i lÆ°á»£ng:",
    "DCA Mode:": "Cháº¿ Ä‘á»™ DCA:",
    "ATR Multiple": "Bá»™i sá»‘ ATR",
    "Fixed Pips": "Pips cá»‘ Ä‘á»‹nh",
    "Fibonacci Levels": "Má»©c Fibonacci",
    "ATR Period:": "Chu ká»³ ATR:",
    "ATR Multiplier:": "Há»‡ sá»‘ ATR:",
    "DCA Distance (pips):": "Khoáº£ng CÃ¡ch DCA (Pips):",
    "Start Fibonacci Retracement (%):": "Báº¯t Ä‘áº§u tá»« má»©c Fibonacci (%):",
    "Fibonacci Exec Mode:": "Cháº¿ Ä‘á»™ thá»±c thi Fibonacci:",
    "On Touch (Market)": "Cháº¡m Má»©c (Market)",
    "Pending Limit at Level": "Äáº·t Lá»‡nh Chá» táº¡i Má»©c",
    "Min Drawdown for DCA (%):": "Sá»¥t giáº£m tá»‘i thiá»ƒu Ä‘á»ƒ DCA (%):",
    "DCA SL Mode:": "Cháº¿ Ä‘á»™ SL cho DCA:",
    "Individual SL": "SL riÃªng láº»",
    "Average SL": "SL trung bÃ¬nh",
    "Average SL Profit % (Per Symbol):": "% Lá»£i nhuáº­n SL trung bÃ¬nh (Theo Symbol):",
    # Auto Trading Tab
    "Auto Trading: OFF": "Giao dá»‹ch tá»± Ä‘á»™ng: Táº®T",
    "Auto Trading: ON": "Giao dá»‹ch tá»± Ä‘á»™ng: Báº¬T",
    "Start Auto Trading": "Báº¯t Ä‘áº§u giao dá»‹ch tá»± Ä‘á»™ng",
    "âšª Status: Not Started": "âšª Tráº¡ng thÃ¡i: ChÆ°a khá»Ÿi Ä‘á»™ng",
    "ðŸ“‹ Activity Log:": "ðŸ“‹ Nháº­t kÃ½ hoáº¡t Ä‘á»™ng:",
    "ðŸ“‹ Activity log will be displayed here...": "ðŸ“‹ Nháº­t kÃ½ hoáº¡t Ä‘á»™ng sáº½ hiá»ƒn thá»‹ á»Ÿ Ä‘Ã¢y...",
    "ðŸ”„ Starting Auto Trading...": "ðŸ”„ Äang khá»Ÿi Ä‘á»™ng Auto Trading...",
    "ðŸš€ Starting Auto Trading system": "ðŸš€ Báº¯t Ä‘áº§u khá»Ÿi Ä‘á»™ng há»‡ thá»‘ng Auto Trading",
    "âš ï¸ Auto Trading already running - ignoring duplicate request": "âš ï¸ Auto Trading Ä‘Ã£ Ä‘ang cháº¡y - bá» qua yÃªu cáº§u duplicate",
    }

    VI_TO_EN = {vi: en for en, vi in EN_TO_VI.items()}

    @staticmethod
    def _translate_runtime_text(txt: str, target_lang: str) -> str:
        if not isinstance(txt, str) or not txt:
            return txt
        base = txt
        if target_lang == 'vi':
            direct = I18N.EN_TO_VI.get(base)
            if direct:
                return direct
            # Fallback partial replacement
            for k, v in I18N.EN_TO_VI.items():
                if k in base:
                    base = base.replace(k, v)
            return base
        else:
            direct = I18N.VI_TO_EN.get(base)
            if direct:
                return direct
            for k, v in I18N.VI_TO_EN.items():  # k=VI, v=EN
                if k in base:
                    base = base.replace(k, v)
            return base

    @staticmethod
    def retranslate_widget_tree(root_widget: 'QWidget') -> None:
        """Recursively translate common widget texts using EN_TO_VI mapping.
        Safe no-op for texts not present in the mapping.
        """
        try:
            from PyQt5.QtWidgets import QWidget as _QW, QLabel, QPushButton, QGroupBox, QCheckBox, QRadioButton, QToolButton, QTableWidget, QComboBox
        except Exception:
            return
        target = AppState.language()

        def _apply(w):
            try:
                if isinstance(w, QGroupBox):
                    w.setTitle(I18N._translate_runtime_text(w.title(), target))
                elif isinstance(w, QLabel):
                    w.setText(I18N._translate_runtime_text(w.text(), target))
                elif isinstance(w, QPushButton):
                    txt0 = w.text()
                    new_txt = I18N._translate_runtime_text(txt0, target)
                    # Special handling for dynamic BUY/SELL buttons with newline values
                    try:
                        if target == 'vi':
                            new_txt = new_txt.replace('SELL', 'BÃN').replace('BUY', 'MUA')
                        else:
                            new_txt = new_txt.replace('BÃN', 'SELL').replace('MUA', 'BUY')
                    except Exception:
                        pass
                    w.setText(new_txt)
                elif isinstance(w, QCheckBox):
                    w.setText(I18N._translate_runtime_text(w.text(), target))
                elif isinstance(w, QRadioButton):
                    w.setText(I18N._translate_runtime_text(w.text(), target))
                elif isinstance(w, QToolButton):
                    w.setText(I18N._translate_runtime_text(w.text(), target))
                    w.setToolTip(I18N._translate_runtime_text(w.toolTip(), target))
                elif isinstance(w, QTableWidget):
                    # Translate header labels, if set
                    try:
                        cols = w.columnCount()
                        headers: list[str] = []
                        changed = False
                        for i in range(cols):
                            it = w.horizontalHeaderItem(i)
                            if it is not None:
                                old = it.text()
                                new = I18N._translate_runtime_text(old, target)
                                if new != old:
                                    it.setText(new)
                                    changed = True
                                headers.append(new)
                        # If no header items existed, set via labels is used; do nothing
                        if changed:
                            w.horizontalHeader().reset()
                    except Exception:
                        pass
                # Translate QTabWidget tab labels if encountered as a parent
                elif w.metaObject().className() == 'QTabWidget':
                    try:
                        count = w.count()
                        for i in range(count):
                            old = w.tabText(i)
                            new = I18N._translate_runtime_text(old, target)
                            if new != old:
                                w.setTabText(i, new)
                    except Exception as e:
                        logger.debug(f"Error translating tabs: {e}")
                        pass
                elif isinstance(w, QComboBox):
                    # Translate items while preserving current selection
                    try:
                        idx = w.currentIndex()
                        for i in range(w.count()):
                            txt = w.itemText(i)
                            w.setItemText(i, I18N._translate_runtime_text(txt, target))
                        if idx >= 0:
                            w.setCurrentIndex(idx)
                    except Exception:
                        pass
            except Exception:
                pass
            for c in w.children():
                if isinstance(c, _QW):
                    _apply(c)

        _apply(root_widget)

    @staticmethod
    def translate_application():
        """Translate all top-level widgets (broader than a single window)."""
        if not GUI_AVAILABLE:
            return
        try:
            from PyQt5.QtWidgets import QApplication
            app = QApplication.instance()
            if not app:
                return
            for w in app.topLevelWidgets():
                try:
                    I18N.retranslate_widget_tree(w)
                except Exception:
                    continue
        except Exception:
            pass

    @staticmethod
    def force_full_translation(root_widget=None, debug=False):
        """Aggressive pass: replace substrings for every widget text property.
        This helps when original text contains dynamic parts not exactly matched.
        """
        if not GUI_AVAILABLE:
            return
        try:
            from PyQt5.QtWidgets import QApplication, QLabel, QPushButton, QGroupBox, QCheckBox, QRadioButton, QToolButton, QTableWidget, QComboBox
            app = QApplication.instance()
            if not app:
                return
            target_lang = AppState.language()
            pairs = I18N.EN_TO_VI.items() if target_lang == 'vi' else I18N.VI_TO_EN.items()
            widgets = []
            if root_widget is not None:
                widgets.append(root_widget)
            else:
                widgets.extend(app.topLevelWidgets())
            visited = set()
            while widgets:
                w = widgets.pop(0)
                if id(w) in visited:
                    continue
                visited.add(id(w))
                # Determine text getters/setters
                for getter_name, setter_name in (("text", "setText"), ("title", "setTitle"), ("placeholderText", "setPlaceholderText")):
                    if hasattr(w, getter_name) and hasattr(w, setter_name):
                        try:
                            orig = getattr(w, getter_name)()
                        except Exception:
                            orig = None
                        if isinstance(orig, str) and orig:
                            new_txt = orig
                            for k, v in pairs:
                                new_txt = new_txt.replace(k, v)
                            if new_txt != orig:
                                try:
                                    getattr(w, setter_name)(new_txt)
                                    if debug:
                                        logger.debug(f"[LangForce] {getter_name} changed: '{orig}' -> '{new_txt}'")
                                except Exception:
                                    pass
                # Table headers
                if isinstance(w, QTableWidget):
                    try:
                        for c in range(w.columnCount()):
                            it = w.horizontalHeaderItem(c)
                            if it:
                                t0 = it.text()
                                t1 = t0
                                for k, v in pairs:
                                    t1 = t1.replace(k, v)
                                if t1 != t0:
                                    it.setText(t1)
                                    if debug:
                                        logger.debug(f"[LangForce] header: '{t0}' -> '{t1}'")
                    except Exception:
                        pass
                try:
                    widgets.extend([c for c in w.children() if hasattr(c, 'children')])
                except Exception:
                    pass
        except Exception as e:
            if debug:
                logger.debug(f"[LangForce] error: {e}")

# Try to import matplotlib for candlestick charts
try:
    import matplotlib.pyplot as plt
    from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
    from matplotlib.figure import Figure
    from matplotlib.patches import Rectangle
    from matplotlib.lines import Line2D
    import matplotlib.dates as mdates
    from datetime import datetime
    MATPLOTLIB_AVAILABLE = True
except ImportError:
    MATPLOTLIB_AVAILABLE = False
    print("âš ï¸ Matplotlib not available - candlestick charts disabled")

# Data fetcher
try:
    from mt5_data_fetcher import fetch_and_save_candles
    DATA_FETCHER_AVAILABLE = True
except ImportError:
    DATA_FETCHER_AVAILABLE = False

# Order executor for quick trading  
try:
    from order_executor import get_executor_instance, TradeSignal
    ORDER_EXECUTOR_AVAILABLE = True
except ImportError:
    ORDER_EXECUTOR_AVAILABLE = False
    print("âš ï¸ Order executor not available - quick trading disabled")

# Indicator exporter
try:
    from mt5_indicator_exporter import calculate_and_save_all
    INDICATOR_EXPORTER_AVAILABLE = True
except ImportError:
    INDICATOR_EXPORTER_AVAILABLE = False

# Pattern detector
try:
    from pattern_detector import analyze_patterns
    PATTERN_DETECTOR_AVAILABLE = True
except ImportError:
    PATTERN_DETECTOR_AVAILABLE = False

# News scraper
# News scraper - use Selenium version
try:
    from news_scraper import NewsScraperSelenium, get_today_news as scraper_get_today_news, save_recent_news_to_json as scraper_save_news
    # Create a compatible interface for the app
    def get_today_news(currencies=None, impacts=None):
        print("ðŸ”„ Using NewsScraperSeleniumâ€¦")
        # Use non-headless to improve reliability behind Cloudflare when launched from the app
        return scraper_get_today_news(currencies, impacts, headless=False, auto_cleanup=True)
    
    def save_recent_news_to_json(events, filename):
        return scraper_save_news(events, filename)
    
    NEWS_SCRAPER_AVAILABLE = True
    # print("âœ… NewsScraperSelenium imported successfully")
except ImportError as e:
    NEWS_SCRAPER_AVAILABLE = False
    print(f"âš ï¸ News scraper import failed: {e}")
    
    def get_today_news(*args): 
        return []
    def save_recent_news_to_json(*args): 
        return False

# Auto trading manager - unified version
try:
    from unified_auto_trading_system import UnifiedAutoTradingSystem as AutoTradingManager
    AUTO_TRADING_AVAILABLE = True
    print("[AUTO TRADING] Using unified auto trading system")
except ImportError:
    AUTO_TRADING_AVAILABLE = False
    print("[AUTO TRADING] Not available")
    class AutoTradingManagerStub:
        def __init__(self, *args): pass
        def start(self): pass
        def stop(self): pass
    AutoTradingManager = AutoTradingManagerStub

# Order tracking daemon - REMOVED (integrated into comprehensive_aggregator.py)
ORDER_DAEMON_AVAILABLE = False
class OrderTrackingDaemonStub:
    def __init__(self): 
        self.logfile = None
    def start(self): return False
    def stop(self): pass
    def status(self): return False
OrderTrackingDaemon = OrderTrackingDaemonStub

# Risk management system
try:
    # from risk_manager import AdvancedRiskManagementSystem, AdvancedRiskParameters, TradeSignal, ValidationResult
    RISK_MANAGER_AVAILABLE = False  # Disabled - file removed
except ImportError:
    RISK_MANAGER_AVAILABLE = False

import sys
import os
import logging
import json
from datetime import datetime, timedelta, timezone
import time
import re
import threading
import hashlib
import pickle
import traceback

# Import GUI helper functions from pattern_detector
try:
    from pattern_detector import (
        load_and_filter_patterns, sort_patterns_by_priority,
        get_pattern_statistics, format_status_message, is_candlestick_pattern,
        load_price_patterns_from_folder
    )
    GUI_HELPERS_AVAILABLE = True
    # print("âœ… GUI helpers loaded successfully from pattern_detector")
except ImportError as e:
    print(f"âš ï¸ GUI helpers not available: {e}")
    GUI_HELPERS_AVAILABLE = False
    # Default functions when GUI helpers not available
    def load_and_filter_patterns(*args, **kwargs): return []
    def sort_patterns_by_priority(patterns): return patterns
    def get_pattern_statistics(patterns): return {'total_count': 0, 'candlestick_count': 0}
    def format_status_message(stats, candlestick_only): return "Helper functions not available"
    def is_candlestick_pattern(pattern_name): return False
    def load_price_patterns_from_folder(*args, **kwargs): return []

# Enhanced import handling - GUI widgets  
try:
    from PyQt5.QtWidgets import (
        QApplication, QWidget, QPushButton, QVBoxLayout, QLabel, QTextEdit,
        QMessageBox, QLineEdit, QFormLayout, QListWidget, QListWidgetItem,
        QHBoxLayout, QSpinBox, QDoubleSpinBox, QGridLayout, QCheckBox, QTabWidget, QGroupBox,
        QRadioButton, QButtonGroup, QFrame, QSplitter, QScrollArea, QProgressBar, QSlider, QDial,
        QComboBox, QTableWidget, QTableWidgetItem, QHeaderView, QTimeEdit, QDateEdit
    )
    from PyQt5.QtCore import Qt, QTimer, QRunnable, QThreadPool, pyqtSignal, QObject, QThread, QTime, QDate
    from PyQt5.QtGui import QPixmap, QIcon, QFont
    GUI_AVAILABLE = True
    # print("âœ… GUI components loaded successfully")
except ImportError as e:
    print(f"âš ï¸ GUI not available: {e}")
    print("Running in console mode...")
    GUI_AVAILABLE = False
    # Default classes for non-GUI mode
    class QObject: pass
    class QThread: pass

# ============ LICENSE CHECK HELPER FUNCTIONS ============

def check_license_for_service(parent_widget=None, service_name: str = "this feature") -> bool:
    """
    Kiá»ƒm tra license cÃ²n hoáº¡t Ä‘á»™ng trÆ°á»›c khi cho phÃ©p sá»­ dá»¥ng service.
    
    Args:
        parent_widget: Widget cha Ä‘á»ƒ hiá»ƒn thá»‹ dialog (cÃ³ thá»ƒ None)
        service_name: TÃªn service Ä‘á»ƒ hiá»ƒn thá»‹ trong thÃ´ng bÃ¡o
        
    Returns:
        True náº¿u license cÃ²n hoáº¡t Ä‘á»™ng, False náº¿u háº¿t háº¡n
    """
    try:
        from license_client import get_license_client
        license_client = get_license_client(server_url=LICENSE_SERVER_URL)
        
        # Check if license is still active (not expired)
        if license_client.is_license_active:
            return True
        
        # License expired - show warning
        if GUI_AVAILABLE and parent_widget:
            QMessageBox.warning(
                parent_widget,
                I18N.t("âš ï¸ License Expired", "âš ï¸ License Háº¿t Háº¡n"),
                I18N.t(
                    f"Your license has expired.\n\nTo use {service_name}, please renew your license.\n\nGo to Menu â†’ Account â†’ View Pricing to renew.",
                    f"License cá»§a báº¡n Ä‘Ã£ háº¿t háº¡n.\n\nÄá»ƒ sá»­ dá»¥ng {service_name}, vui lÃ²ng gia háº¡n license.\n\nVÃ o Menu â†’ TÃ i khoáº£n â†’ Xem Báº£ng GiÃ¡ Ä‘á»ƒ gia háº¡n."
                )
            )
        else:
            print(f"âš ï¸ License expired - cannot use {service_name}")
        
        return False
        
    except Exception as e:
        print(f"âš ï¸ License check error: {e}")
        # On error, default to allowing access (fail-open for connectivity issues)
        return True

def is_license_active() -> bool:
    """
    Quick check if license is still active.
    Returns True if active, False if expired or no license.
    """
    try:
        from license_client import get_license_client
        license_client = get_license_client(server_url=LICENSE_SERVER_URL)
        return license_client.is_license_active
    except Exception as e:
        print(f"âš ï¸ License check error: {e}")
        return True  # Fail-open for connectivity issues

# ============ END LICENSE CHECK HELPER FUNCTIONS ============

# ------------------------------
# Signal Tab - UI for comprehensive_aggregator.py
# ------------------------------
if GUI_AVAILABLE:
    class RunAggregatorWorker(QThread):
        def __init__(self, args: List[str], parent: Optional[QObject] = None):
            super().__init__(parent)
            self.args = args
            self.returncode = None
            self.stdout = None
            self.stderr = None
            self._should_stop = False

        def stop(self):
            """Safe thread stop request"""
            self._should_stop = True

        def run(self):
            """Enhanced crash-proof QThread run method"""
            try:
                if self._should_stop:
                    logger.debug("Thread stop requested before start")
                    return
                    
                # Use current Python executable for reliability
                cmd = [sys.executable, 'comprehensive_aggregator.py'] + self.args
                logger.debug(f"Running command: {' '.join(cmd)}")
                
                # Set proper working directory and environment
                env = os.environ.copy()
                env['PYTHONIOENCODING'] = 'utf-8'  # Force UTF-8 encoding for subprocess
                
                proc = subprocess.run(
                    cmd, 
                    capture_output=True, 
                    text=True, 
                    shell=False,
                    cwd=os.getcwd(),  # Ensure correct working directory
                    timeout=300,  # 5 minute timeout
                    env=env,  # Use UTF-8 environment
                    encoding='utf-8',  # Explicit UTF-8 encoding
                    errors='replace'  # Replace problematic chars instead of crashing
                )
                
                if self._should_stop:
                    logger.debug("Thread stopped during execution")
                    return
                
                self.returncode = proc.returncode
                self.stdout = proc.stdout
                self.stderr = proc.stderr
                
                logger.debug(f"Return code: {self.returncode}")
                if self.stderr:
                    logger.debug(f"Stderr: {self.stderr[:500]}")
                if self.stdout:
                    logger.debug(f"Stdout length: {len(self.stdout)} chars")
                    
            except subprocess.TimeoutExpired as e:
                self.returncode = -2
                self.stderr = f"Process timed out after 5 minutes: {str(e)}"
                logger.error(f"Process timeout: {self.stderr}")
                
            except subprocess.CalledProcessError as e:
                self.returncode = e.returncode
                self.stderr = f"Process failed with exit code {e.returncode}: {str(e)}"
                logger.error(f"Process error: {self.stderr}")
                
            except KeyboardInterrupt:
                self.returncode = -3
                self.stderr = "Process interrupted by user"
                logger.warning(f"Process interrupted: {self.stderr}")
                
            except Exception as e:
                self.returncode = -1
                self.stderr = f"Critical thread error: {type(e).__name__}: {str(e)}"
                logger.critical(f"QThread exception: {self.stderr}")
                
                # Log the error for debugging
                try:
                    import traceback
                    error_trace = traceback.format_exc()
                    logger.critical(f"TRACEBACK:\n{error_trace}")
                    
                    # Save crash log
                    crash_log = f"logs/qthread_crash_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log"
                    os.makedirs("logs", exist_ok=True)
                    with open(crash_log, 'w', encoding='utf-8') as f:
                        f.write(f"QThread Crash: {datetime.now()}\n")
                        f.write(f"Error: {self.stderr}\n\n")
                        f.write(f"Traceback:\n{error_trace}\n")
                    logger.info(f"QThread crash log saved: {crash_log}")
                except:
                    logger.error("Could not save crash log")
            finally:
                # Ensure thread always completes cleanly
                logger.debug("QThread run method completed")

    class AIServerAnalysisWorker(QThread):
        """Worker thread for remote XGBoost AI Server analysis"""
        
        finished = pyqtSignal()
        error = pyqtSignal(str)
        
        DEFAULT_SERVER_URL = "http://localhost:8080"
        
        def __init__(self, symbols: List[str], prompt: str, server_url: str = None, parent: Optional[QObject] = None):
            super().__init__(parent)
            self.symbols = symbols
            self.prompt = prompt
            self.server_url = server_url or self._load_server_url()
            self.result = {"success": False, "error": None, "data": None}
        
        def _load_server_url(self):
            """Load server URL from config file"""
            try:
                config_file = os.path.join(os.path.dirname(__file__), "ai_server_config.json")
                if os.path.exists(config_file):
                    with open(config_file, 'r', encoding='utf-8') as f:
                        config = json.load(f)
                        return config.get('server_url', self.DEFAULT_SERVER_URL)
            except:
                pass
            return self.DEFAULT_SERVER_URL
        
        def run(self):
            """Run AI Server analysis in background"""
            try:
                import requests
                
                print(f"ðŸ¤– [AIServer] Connecting to: {self.server_url}")
                print(f"ðŸ¤– [AIServer] Analyzing symbols: {self.symbols}")
                
                # Collect market data for analysis
                market_data = self._collect_market_data()
                
                if not market_data:
                    self.result = {"success": False, "error": "No market data found. Please run indicator export first."}
                    self.finished.emit()
                    return
                
                # Call remote AI Server for each symbol
                all_signals = []
                for symbol, data in market_data.items():
                    signal = self._analyze_symbol(symbol, data)
                    if signal:
                        all_signals.append(signal)
                
                if all_signals:
                    # Save results
                    self._save_analysis_results(all_signals)
                    self.result = {"success": True, "data": all_signals}
                else:
                    self.result = {"success": False, "error": "AI Server returned no signals"}
                
                self.finished.emit()
                    
            except Exception as e:
                import traceback
                error_msg = f"{e}\n{traceback.format_exc()}"
                self.result = {"success": False, "error": error_msg}
                print(f"âŒ AI Server Analysis Error: {e}")
                self.error.emit(str(e))
                self.finished.emit()
        
        def _collect_market_data(self) -> dict:
            """Collect indicator data for symbols"""
            data = {}
            indicator_dir = os.path.join(os.getcwd(), "indicator_output")
            
            for symbol in self.symbols or []:
                symbol_data = {}
                pattern = os.path.join(indicator_dir, f"{symbol}*.json")
                for fp in glob.glob(pattern):
                    try:
                        with open(fp, 'r', encoding='utf-8') as f:
                            content = json.load(f)
                            tf = os.path.basename(fp).replace(symbol, '').replace('.json', '').strip('_')
                            symbol_data[tf] = content
                    except:
                        pass
                if symbol_data:
                    data[symbol] = symbol_data
            
            # Fallback: get any available data if no symbols specified
            if not data:
                for fp in glob.glob(os.path.join(indicator_dir, "*.json"))[:5]:
                    try:
                        with open(fp, 'r', encoding='utf-8') as f:
                            content = json.load(f)
                            # Extract symbol from filename
                            basename = os.path.basename(fp)
                            symbol = basename.split('_')[0] if '_' in basename else basename.replace('.json', '')
                            if symbol not in data:
                                data[symbol] = {}
                            data[symbol][basename] = content
                    except:
                        pass
            
            return data
        
        def _get_current_user_info(self) -> dict:
            """Get current logged in user info for AI Server tracking"""
            user_info = {
                'email': 'anonymous',
                'name': 'Anonymous User',
                'phone': 'N/A'
            }
            
            try:
                # Try to get from license client
                from license_client import get_license_client
                lc = get_license_client(server_url=LICENSE_SERVER_URL)
                
                # Get cached user info
                cached_email = lc.get_cached_username()
                if cached_email:
                    user_info['email'] = cached_email
                    user_info['name'] = cached_email.split('@')[0]
                
                # Try to get more info from remember file
                remember_file = os.path.join(os.path.dirname(os.path.abspath(__file__)), '.login_remember.json')
                if os.path.exists(remember_file):
                    with open(remember_file, 'r', encoding='utf-8') as f:
                        remember_data = json.load(f)
                        if remember_data.get('email'):
                            user_info['email'] = remember_data['email']
                            user_info['name'] = remember_data.get('name', remember_data['email'].split('@')[0])
                        if remember_data.get('phone'):
                            user_info['phone'] = remember_data['phone']
                            
            except Exception as e:
                print(f"[AIServer] Cannot get user info: {e}")
            
            return user_info
        
        def _analyze_symbol(self, symbol: str, symbol_data: dict) -> Optional[dict]:
            """Call remote XGBoost AI Server to analyze a symbol"""
            try:
                import requests
                
                # Get latest price from data
                price = 0
                indicators_m15 = {}
                indicators_h1 = {}
                
                for tf_name, tf_data in symbol_data.items():
                    if isinstance(tf_data, dict):
                        if 'close' in tf_data or 'Close' in tf_data:
                            price = tf_data.get('close', tf_data.get('Close', 0))
                        # Collect indicators by timeframe
                        if 'M15' in tf_name or 'm15' in tf_name.lower():
                            indicators_m15 = tf_data
                        elif 'H1' in tf_name or 'h1' in tf_name.lower():
                            indicators_h1 = tf_data
                
                # If no specific timeframe found, use what we have
                if not indicators_m15 and not indicators_h1:
                    for tf_name, tf_data in symbol_data.items():
                        if isinstance(tf_data, dict):
                            if not indicators_h1:
                                indicators_h1 = tf_data
                            elif not indicators_m15:
                                indicators_m15 = tf_data
                
                # Get current user info for tracking
                user_info = self._get_current_user_info()
                
                # Call XGBoost AI Server /api/predict endpoint
                payload = {
                    "symbol": symbol,
                    "user_info": user_info,
                    "indicators": {
                        "M15": indicators_m15,
                        "H1": indicators_h1
                    },
                    "patterns": {},
                    "trendline_sr": {},
                    "news": []
                }
                
                print(f"ðŸŒ [XGBoost] Calling {self.server_url}/api/predict for {symbol}...")
                print(f"ðŸŒ [XGBoost] User: {user_info.get('email', 'anonymous')}")
                
                response = requests.post(
                    f"{self.server_url}/api/predict",
                    json=payload,
                    timeout=30  # XGBoost is fast
                )
                
                if response.status_code == 200:
                    result = response.json()
                    if result.get("success"):
                        signal = result.get("signal", "HOLD")
                        confidence = result.get("confidence", 50)
                        probabilities = result.get("probabilities", {})
                        
                        print(f"âœ… [XGBoost] {symbol}: {signal} ({confidence:.1f}%)")
                        print(f"   Probabilities: BUY={probabilities.get('BUY', 0):.1f}%, SELL={probabilities.get('SELL', 0):.1f}%, HOLD={probabilities.get('HOLD', 0):.1f}%")
                        
                        # Calculate SL/TP based on signal
                        if signal == "BUY":
                            sl = round(price * 0.995, 5)  # 0.5% SL
                            tp = round(price * 1.015, 5)  # 1.5% TP
                        elif signal == "SELL":
                            sl = round(price * 1.005, 5)
                            tp = round(price * 0.985, 5)
                        else:
                            sl = tp = price
                        
                        return {
                            "symbol": symbol,
                            "signal": signal,
                            "confidence": confidence,
                            "entry": price,
                            "stoploss": sl,
                            "takeprofit": tp,
                            "probabilities": probabilities,
                            "reasoning": f"XGBoost AI: {signal} with {confidence:.1f}% confidence"
                        }
                    else:
                        print(f"âš ï¸ XGBoost error for {symbol}: {result.get('error')}")
                        return None
                elif response.status_code == 503:
                    print(f"âŒ XGBoost Server: Model not loaded")
                    return None
                else:
                    print(f"âŒ XGBoost HTTP error: {response.status_code}")
                    return None
                    
            except Exception as e:
                print(f"âŒ XGBoost call error for {symbol}: {e}")
                return None
        
        def _parse_ai_response(self, symbol: str, price: float, analysis: str) -> dict:
            """Parse AI response text to extract trading signal"""
            analysis_upper = analysis.upper()
            
            # Detect signal type
            if "BUY" in analysis_upper or "MUA" in analysis_upper or "LONG" in analysis_upper:
                signal = "BUY"
            elif "SELL" in analysis_upper or "BÃN" in analysis_upper or "SHORT" in analysis_upper:
                signal = "SELL"
            else:
                signal = "HOLD"
            
            # Try to extract confidence
            confidence = 50  # Default
            import re
            conf_match = re.search(r'(\d{1,3})\s*%', analysis)
            if conf_match:
                confidence = min(100, int(conf_match.group(1)))
            
            # Calculate basic SL/TP based on signal
            if signal == "BUY":
                sl = round(price * 0.995, 5)  # 0.5% SL
                tp = round(price * 1.015, 5)  # 1.5% TP
            elif signal == "SELL":
                sl = round(price * 1.005, 5)  # 0.5% SL
                tp = round(price * 0.985, 5)  # 1.5% TP
            else:
                sl = tp = price
            
            return {
                "symbol": symbol,
                "signal": signal,
                "confidence": confidence,
                "entry": price,
                "stoploss": sl,
                "takeprofit": tp,
                "reasoning": analysis[:500] if len(analysis) > 500 else analysis
            }
        
        def _save_analysis_results(self, signals: List[dict]):
            """Save AI analysis results as signal files"""
            try:
                out_dir = os.path.join(os.getcwd(), "analysis_results")
                os.makedirs(out_dir, exist_ok=True)
                
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                
                for sig in signals:
                    symbol = sig.get("symbol", "UNKNOWN")
                    signal_data = {
                        "symbol": symbol,
                        "generated_by": "XGBoost AI Server",
                        "timestamp": timestamp,
                        "final_signal": {
                            "signal": sig.get("signal", "HOLD"),
                            "confidence": sig.get("confidence", 0),
                            "entry": sig.get("entry"),
                            "stoploss": sig.get("stoploss"),
                            "takeprofit": sig.get("takeprofit"),
                            "reasoning": sig.get("reasoning", "")
                        }
                    }
                    
                    fp = os.path.join(out_dir, f"{symbol}_signal_{timestamp}.json")
                    with open(fp, 'w', encoding='utf-8') as f:
                        json.dump(signal_data, f, indent=2, ensure_ascii=False)
                    print(f"âœ… Saved AI Server signal: {fp}")
                    
            except Exception as e:
                print(f"âŒ Error saving AI results: {e}")

    class NotificationDialog(QDialog):
        """Enhanced notification dialog with multiple platforms and Vietnamese support"""
        
        def __init__(self, parent=None):
            try:
                logger.debug("NotificationDialog.__init__ starting...")
                super().__init__(parent)
                
                self.setWindowTitle(I18N.t("ðŸ“± Notification Settings", "ðŸ“± CÃ i Ä‘áº·t ThÃ´ng bÃ¡o"))
                
                self.setMinimumSize(800, 700)
                self.setModal(True)
                
                # Platform configurations storage
                self.platform_configs = {}
                
                self._build_ui()
                
                # Initialize loading flag
                self._is_loading_settings = True
                
                # Load config with delay to ensure UI is fully ready
                # Then connect auto-save signals AFTER loading completes
                from PyQt5.QtCore import QTimer
                QTimer.singleShot(500, self._load_config_and_connect_signals)
                
                logger.debug("NotificationDialog initialization completed successfully")
                
            except Exception as e:
                logger.error(f"NotificationDialog.__init__ failed: {e}")
                import traceback
                logger.error(f"TRACEBACK: {traceback.format_exc()}")
                raise
        
        def _build_ui(self):
            try:
                print("ðŸ” [DEBUG] _build_ui() starting...")
                layout = QVBoxLayout(self)
                print("âœ… [DEBUG] QVBoxLayout created")
                
                # Title
                title = QLabel(I18N.t("ðŸ“± Global Messaging Platform Setup", "ðŸ“± CÃ i Ä‘áº·t Ná»n táº£ng Nháº¯n tin ToÃ n cáº§u"))
                title.setFont(QFont("Segoe UI", 14, QFont.Bold))
                layout.addWidget(title)
                print("âœ… [DEBUG] Title added")
                
                # Main tab widget for platform configuration
                self.main_tabs = QTabWidget()
                print("âœ… [DEBUG] QTabWidget created")
                
                # Tab 1: Platform Selection
                print("ðŸ” [DEBUG] Creating platform selection tab...")
                self._create_platform_selection_tab()
                print("âœ… [DEBUG] Platform selection tab created")
                
                # Tab 2: Configuration tabs for each platform
                print("ðŸ” [DEBUG] Creating platform config tabs...")
                self._create_platform_config_tabs()
                print("âœ… [DEBUG] Platform config tabs created")
                
                # Tab 3: Message & Send
                print("ðŸ” [DEBUG] Creating message send tab...")
                self._create_message_send_tab()
                print("âœ… [DEBUG] Message send tab created")
                
                # Tab 4: Branding & Contact Settings - INTEGRATED INTO MESSAGE TAB
                print("ðŸ” [DEBUG] Branding settings integrated into message tab")
                # self._create_branding_settings_tab() - Removed, integrated into message tab
                print("âœ… [DEBUG] Branding settings integration completed")
                
                # Tab 5: Smart Trading Monitor - REMOVED
                # User requested to remove this tab
                
                layout.addWidget(self.main_tabs)
                print("âœ… [DEBUG] Main tabs added to layout")
                
                # Connect tab change signal to update footer preview
                self.main_tabs.currentChanged.connect(self._on_tab_changed)
                
                # Bottom action buttons
                print("ðŸ” [DEBUG] Creating action buttons...")
                self._create_action_buttons(layout)
                print("âœ… [DEBUG] Action buttons created")
                
                print("âœ… [DEBUG] _build_ui() completed successfully")
                
            except Exception as e:
                print(f"âŒ [ERROR] _build_ui() failed: {e}")
                import traceback
                print(f"âŒ [TRACEBACK] {traceback.format_exc()}")
                raise
        
        def _create_platform_selection_tab(self):
            """Create platform selection tab with all popular messaging apps"""
            selection_tab = QWidget()
            layout = QVBoxLayout(selection_tab)
            
            # Instruction
            instruction = QLabel(I18N.t(
                "Select messaging platforms you want to use for trading notifications:",
                "Chá»n cÃ¡c ná»n táº£ng nháº¯n tin báº¡n muá»‘n dÃ¹ng cho thÃ´ng bÃ¡o giao dá»‹ch:"
            ))
            instruction.setFont(QFont("Segoe UI", 10))
            layout.addWidget(instruction)
            
            # Platform categories
            self._create_platform_categories(layout)
            
            self.main_tabs.addTab(selection_tab, I18N.t("ðŸŒ Select Platforms", "ðŸŒ Chá»n Ná»n táº£ng"))
        
        def _create_platform_categories(self, layout):
            """Create categorized platform selection"""
            
            # Popular Messaging Apps
            popular_group = QGroupBox(I18N.t("ðŸ“± Popular Messaging Apps", "ðŸ“± á»¨ng dá»¥ng Nháº¯n tin Phá»• biáº¿n"))
            popular_layout = QGridLayout(popular_group)
            
            # Row 1: Top global platforms
            self.telegram_cb = QCheckBox("ðŸ“Ÿ Telegram")
            self.whatsapp_cb = QCheckBox("ðŸ’¬ WhatsApp")
            self.signal_cb = QCheckBox("ðŸ” Signal")
            self.discord_cb = QCheckBox("ðŸŽ® Discord")
            
            popular_layout.addWidget(self.telegram_cb, 0, 0)
            popular_layout.addWidget(self.whatsapp_cb, 0, 1)
            popular_layout.addWidget(self.signal_cb, 0, 2)
            popular_layout.addWidget(self.discord_cb, 0, 3)
            
            # Row 2: Regional popular
            self.zalo_cb = QCheckBox("ðŸ‡»ðŸ‡³ Zalo")
            self.wechat_cb = QCheckBox("ðŸ‡¨ðŸ‡³ WeChat")
            self.line_cb = QCheckBox("ðŸ‡¯ðŸ‡µ LINE")
            self.kakaotalk_cb = QCheckBox("ðŸ‡°ðŸ‡· KakaoTalk")
            
            popular_layout.addWidget(self.zalo_cb, 1, 0)
            popular_layout.addWidget(self.wechat_cb, 1, 1)
            popular_layout.addWidget(self.line_cb, 1, 2)
            popular_layout.addWidget(self.kakaotalk_cb, 1, 3)
            
            layout.addWidget(popular_group)
            
            # Social Media Platforms
            social_group = QGroupBox(I18N.t("ðŸ“¢ Social Media Platforms", "ðŸ“¢ Ná»n táº£ng Máº¡ng xÃ£ há»™i"))
            social_layout = QGridLayout(social_group)
            
            self.facebook_cb = QCheckBox("ðŸ“˜ Facebook Messenger")
            self.instagram_cb = QCheckBox("ðŸ“· Instagram DM")
            self.twitter_cb = QCheckBox("ðŸ¦ Twitter/X DM")
            self.linkedin_cb = QCheckBox("ðŸ’¼ LinkedIn")
            
            social_layout.addWidget(self.facebook_cb, 0, 0)
            social_layout.addWidget(self.instagram_cb, 0, 1)
            social_layout.addWidget(self.twitter_cb, 0, 2)
            social_layout.addWidget(self.linkedin_cb, 0, 3)
            
            layout.addWidget(social_group)
            
            # Business/Enterprise
            business_group = QGroupBox(I18N.t("ðŸ¢ Business Platforms", "ðŸ¢ Ná»n táº£ng Doanh nghiá»‡p"))
            business_layout = QGridLayout(business_group)
            
            self.slack_cb = QCheckBox("ðŸ’¬ Slack")
            self.teams_cb = QCheckBox("ðŸ‘¥ Microsoft Teams")
            self.skype_cb = QCheckBox("ðŸ“ž Skype")
            self.viber_cb = QCheckBox("ðŸ’œ Viber")
            
            business_layout.addWidget(self.slack_cb, 0, 0)
            business_layout.addWidget(self.teams_cb, 0, 1)
            business_layout.addWidget(self.skype_cb, 0, 2)
            business_layout.addWidget(self.viber_cb, 0, 3)
            
            layout.addWidget(business_group)
            
            # Email & SMS
            other_group = QGroupBox(I18N.t("ðŸ“§ Email & SMS", "ðŸ“§ Email & SMS"))
            other_layout = QGridLayout(other_group)
            
            self.email_cb = QCheckBox("ðŸ“§ Email")
            self.sms_cb = QCheckBox("ðŸ“± SMS")
            self.webhook_cb = QCheckBox("ðŸ”— Custom Webhook")
            self.pushbullet_cb = QCheckBox("ðŸ“‹ Pushbullet")
            
            other_layout.addWidget(self.email_cb, 0, 0)
            other_layout.addWidget(self.sms_cb, 0, 1)
            other_layout.addWidget(self.webhook_cb, 0, 2)
            other_layout.addWidget(self.pushbullet_cb, 0, 3)
            
            layout.addWidget(other_group)
            
            # Store all checkboxes for easy access
            self.all_platform_checkboxes = [
                # Popular
                self.telegram_cb, self.whatsapp_cb, self.signal_cb, self.discord_cb,
                self.zalo_cb, self.wechat_cb, self.line_cb, self.kakaotalk_cb,
                # Social
                self.facebook_cb, self.instagram_cb, self.twitter_cb, self.linkedin_cb,
                # Business
                self.slack_cb, self.teams_cb, self.skype_cb, self.viber_cb,
                # Other
                self.email_cb, self.sms_cb, self.webhook_cb, self.pushbullet_cb
            ]
            
            # Connect selection signals
            for cb in self.all_platform_checkboxes:
                cb.toggled.connect(self._on_platform_selection_changed)
        
        def _create_platform_config_tabs(self):
            """Create configuration tabs for selected platforms"""
            config_tab = QWidget()
            layout = QVBoxLayout(config_tab)
            
            # Sub tab widget for individual platform configs
            self.config_tabs = QTabWidget()
            layout.addWidget(self.config_tabs)
            
            # Initially create tabs for main platforms
            self._create_telegram_config_tab()
            self._create_zalo_config_tab()
            self._create_whatsapp_config_tab()
            self._create_discord_config_tab()
            self._create_email_config_tab()
            self._create_webhook_config_tab()
            
            self.main_tabs.addTab(config_tab, I18N.t("âš™ï¸ Configuration", "âš™ï¸ Cáº¥u hÃ¬nh"))
        
        def _create_telegram_config_tab(self):
            """Create Telegram configuration tab"""
            tab = QWidget()
            layout = QVBoxLayout(tab)
            
            # Instructions
            instructions = QLabel(I18N.t(
                "Telegram Setup Instructions:\n1. Message @BotFather on Telegram\n2. Send /newbot command\n3. Copy the Bot Token\n4. Add bot to your group\n5. Get Chat ID",
                "HÆ°á»›ng dáº«n Telegram:\n1. Nháº¯n @BotFather trÃªn Telegram\n2. Gá»­i lá»‡nh /newbot\n3. Sao chÃ©p Bot Token\n4. ThÃªm bot vÃ o nhÃ³m\n5. Láº¥y Chat ID"
            ))
            instructions.setStyleSheet("color: #666; font-size: 10px;")
            layout.addWidget(instructions)
            
            # Form
            form_layout = QGridLayout()
            
            form_layout.addWidget(QLabel(I18N.t("Bot Token:", "Bot Token:")), 0, 0)
            self.telegram_token = QLineEdit()
            self.telegram_token.setPlaceholderText("1234567890:ABCdefghijk...")
            form_layout.addWidget(self.telegram_token, 0, 1)
            
            form_layout.addWidget(QLabel(I18N.t("Chat ID:", "Chat ID:")), 1, 0)
            self.telegram_chat_id = QLineEdit()
            self.telegram_chat_id.setPlaceholderText("-1001234567890")
            form_layout.addWidget(self.telegram_chat_id, 1, 1)
            
            # Quick buttons
            button_layout = QHBoxLayout()
            auto_setup_btn = QPushButton(I18N.t("ðŸ”§ Auto Setup", "ðŸ”§ Setup Tá»± Ä‘á»™ng"))
            get_chat_id_btn = QPushButton(I18N.t("ðŸ” Get Chat ID", "ðŸ” Láº¥y Chat ID"))
            test_btn = QPushButton(I18N.t("ðŸ§ª Test", "ðŸ§ª Test"))
            
            auto_setup_btn.clicked.connect(self._telegram_auto_setup)
            get_chat_id_btn.clicked.connect(self._telegram_get_chat_id)
            test_btn.clicked.connect(self._test_telegram)
            
            button_layout.addWidget(auto_setup_btn)
            button_layout.addWidget(get_chat_id_btn)
            button_layout.addWidget(test_btn)
            button_layout.addStretch()
            
            layout.addLayout(form_layout)
            layout.addLayout(button_layout)
            layout.addStretch()
            
            self.config_tabs.addTab(tab, "ðŸ“Ÿ Telegram")
        
        def _create_zalo_config_tab(self):
            """Create Zalo configuration tab"""
            tab = QWidget()
            layout = QVBoxLayout(tab)
            
            instructions = QLabel(I18N.t(
                "Zalo requires webhook setup. You can use services like Zapier or IFTTT to connect.",
                "Zalo yÃªu cáº§u cÃ i Ä‘áº·t webhook. Báº¡n cÃ³ thá»ƒ dÃ¹ng Zapier hoáº·c IFTTT Ä‘á»ƒ káº¿t ná»‘i."
            ))
            instructions.setStyleSheet("color: #666; font-size: 10px;")
            layout.addWidget(instructions)
            
            form_layout = QGridLayout()
            
            form_layout.addWidget(QLabel(I18N.t("Webhook URL:", "Webhook URL:")), 0, 0)
            self.zalo_webhook = QLineEdit()
            self.zalo_webhook.setPlaceholderText("https://hooks.zapier.com/...")
            form_layout.addWidget(self.zalo_webhook, 0, 1)
            
            form_layout.addWidget(QLabel(I18N.t("Access Token:", "Access Token:")), 1, 0)
            self.zalo_token = QLineEdit()
            self.zalo_token.setPlaceholderText(I18N.t("Optional", "TÃ¹y chá»n"))
            form_layout.addWidget(self.zalo_token, 1, 1)
            
            layout.addLayout(form_layout)
            layout.addStretch()
            
            self.config_tabs.addTab(tab, "ðŸ‡»ðŸ‡³ Zalo")
        
        def _create_whatsapp_config_tab(self):
            """Create WhatsApp configuration tab"""
            tab = QWidget()
            layout = QVBoxLayout(tab)
            
            instructions = QLabel(I18N.t(
                "WhatsApp Business API required. Use services like Twilio WhatsApp API.",
                "Cáº§n WhatsApp Business API. Sá»­ dá»¥ng dá»‹ch vá»¥ nhÆ° Twilio WhatsApp API."
            ))
            instructions.setStyleSheet("color: #666; font-size: 10px;")
            layout.addWidget(instructions)
            
            form_layout = QGridLayout()
            
            form_layout.addWidget(QLabel(I18N.t("API Key:", "API Key:")), 0, 0)
            self.whatsapp_api_key = QLineEdit()
            form_layout.addWidget(self.whatsapp_api_key, 0, 1)
            
            form_layout.addWidget(QLabel(I18N.t("Phone Number:", "Sá»‘ Ä‘iá»‡n thoáº¡i:")), 1, 0)
            self.whatsapp_phone = QLineEdit()
            self.whatsapp_phone.setPlaceholderText("+84123456789")
            form_layout.addWidget(self.whatsapp_phone, 1, 1)
            
            layout.addLayout(form_layout)
            layout.addStretch()
            
            self.config_tabs.addTab(tab, "ðŸ’¬ WhatsApp")
        
        def _create_discord_config_tab(self):
            """Create Discord configuration tab"""
            tab = QWidget()
            layout = QVBoxLayout(tab)
            
            instructions = QLabel(I18N.t(
                "Discord webhook setup:\n1. Go to your Discord server\n2. Edit channel â†’ Integrations â†’ Webhooks\n3. Create webhook and copy URL",
                "CÃ i Ä‘áº·t Discord webhook:\n1. VÃ o Discord server\n2. Chá»‰nh sá»­a kÃªnh â†’ Integrations â†’ Webhooks\n3. Táº¡o webhook vÃ  copy URL"
            ))
            instructions.setStyleSheet("color: #666; font-size: 10px;")
            layout.addWidget(instructions)
            
            form_layout = QGridLayout()
            
            form_layout.addWidget(QLabel(I18N.t("Webhook URL:", "Webhook URL:")), 0, 0)
            self.discord_webhook = QLineEdit()
            self.discord_webhook.setPlaceholderText("https://discord.com/api/webhooks/...")
            form_layout.addWidget(self.discord_webhook, 0, 1)
            
            layout.addLayout(form_layout)
            layout.addStretch()
            
            self.config_tabs.addTab(tab, "ðŸŽ® Discord")
        
        def _create_email_config_tab(self):
            """Create Email configuration tab"""
            tab = QWidget()
            layout = QVBoxLayout(tab)
            
            form_layout = QGridLayout()
            
            form_layout.addWidget(QLabel(I18N.t("SMTP Server:", "SMTP Server:")), 0, 0)
            self.email_smtp = QLineEdit()
            self.email_smtp.setPlaceholderText("smtp.gmail.com")
            form_layout.addWidget(self.email_smtp, 0, 1)
            
            form_layout.addWidget(QLabel(I18N.t("Port:", "Port:")), 1, 0)
            self.email_port = QLineEdit()
            self.email_port.setPlaceholderText("587")
            form_layout.addWidget(self.email_port, 1, 1)
            
            form_layout.addWidget(QLabel(I18N.t("Email:", "Email:")), 2, 0)
            self.email_address = QLineEdit()
            form_layout.addWidget(self.email_address, 2, 1)
            
            form_layout.addWidget(QLabel(I18N.t("Password:", "Máº­t kháº©u:")), 3, 0)
            self.email_password = QLineEdit()
            self.email_password.setEchoMode(QLineEdit.Password)
            form_layout.addWidget(self.email_password, 3, 1)
            
            form_layout.addWidget(QLabel(I18N.t("To Email:", "Gá»­i Ä‘áº¿n:")), 4, 0)
            self.email_to = QLineEdit()
            form_layout.addWidget(self.email_to, 4, 1)
            
            layout.addLayout(form_layout)
            layout.addStretch()
            
            self.config_tabs.addTab(tab, "ðŸ“§ Email")
        
        def _create_webhook_config_tab(self):
            """Create Custom Webhook configuration tab"""
            tab = QWidget()
            layout = QVBoxLayout(tab)
            
            instructions = QLabel(I18N.t(
                "Custom webhook for integrating with any service (Zapier, IFTTT, Make, etc.)",
                "Webhook tÃ¹y chá»‰nh Ä‘á»ƒ tÃ­ch há»£p vá»›i báº¥t ká»³ dá»‹ch vá»¥ nÃ o (Zapier, IFTTT, Make, v.v.)"
            ))
            instructions.setStyleSheet("color: #666; font-size: 10px;")
            layout.addWidget(instructions)
            
            form_layout = QGridLayout()
            
            form_layout.addWidget(QLabel(I18N.t("Webhook URL:", "Webhook URL:")), 0, 0)
            self.webhook_url = QLineEdit()
            self.webhook_url.setPlaceholderText("https://hooks.zapier.com/...")
            form_layout.addWidget(self.webhook_url, 0, 1)
            
            form_layout.addWidget(QLabel(I18N.t("Method:", "PhÆ°Æ¡ng thá»©c:")), 1, 0)
            self.webhook_method = QComboBox()
            self.webhook_method.addItems(["POST", "GET", "PUT"])
            form_layout.addWidget(self.webhook_method, 1, 1)
            
            form_layout.addWidget(QLabel(I18N.t("Headers:", "Headers:")), 2, 0)
            self.webhook_headers = QTextEdit()
            self.webhook_headers.setPlaceholderText('{"Content-Type": "application/json"}')
            self.webhook_headers.setMaximumHeight(60)
            form_layout.addWidget(self.webhook_headers, 2, 1)
            
            layout.addLayout(form_layout)
            layout.addStretch()
            
            self.config_tabs.addTab(tab, "ðŸ”— Webhook")
        
        def _create_signal_config_tab(self):
            """Create Signal configuration tab"""
            tab = QWidget()
            layout = QVBoxLayout(tab)
            
            instructions = QLabel(I18N.t(
                "Signal requires webhook integration or third-party services.",
                "Signal yÃªu cáº§u tÃ­ch há»£p webhook hoáº·c dá»‹ch vá»¥ bÃªn thá»© ba."
            ))
            instructions.setStyleSheet("color: #666; font-size: 10px;")
            layout.addWidget(instructions)
            
            form_layout = QGridLayout()
            form_layout.addWidget(QLabel(I18N.t("Webhook URL:", "Webhook URL:")), 0, 0)
            self.signal_webhook = QLineEdit()
            self.signal_webhook.setPlaceholderText("https://signal-webhook-service.com/...")
            form_layout.addWidget(self.signal_webhook, 0, 1)
            
            layout.addLayout(form_layout)
            layout.addStretch()
            self.config_tabs.addTab(tab, "ðŸ” Signal")
        
        def _create_wechat_config_tab(self):
            """Create WeChat configuration tab"""
            tab = QWidget()
            layout = QVBoxLayout(tab)
            
            instructions = QLabel(I18N.t(
                "WeChat requires official API registration and approval from Tencent.",
                "WeChat yÃªu cáº§u Ä‘Äƒng kÃ½ API chÃ­nh thá»©c vÃ  phÃª duyá»‡t tá»« Tencent."
            ))
            instructions.setStyleSheet("color: #666; font-size: 10px;")
            layout.addWidget(instructions)
            
            form_layout = QGridLayout()
            form_layout.addWidget(QLabel(I18N.t("App ID:", "App ID:")), 0, 0)
            self.wechat_app_id = QLineEdit()
            form_layout.addWidget(self.wechat_app_id, 0, 1)
            
            form_layout.addWidget(QLabel(I18N.t("App Secret:", "App Secret:")), 1, 0)
            self.wechat_app_secret = QLineEdit()
            self.wechat_app_secret.setEchoMode(QLineEdit.Password)
            form_layout.addWidget(self.wechat_app_secret, 1, 1)
            
            layout.addLayout(form_layout)
            layout.addStretch()
            self.config_tabs.addTab(tab, "ðŸ‡¨ðŸ‡³ WeChat")
        
        def _create_line_config_tab(self):
            """Create LINE configuration tab"""
            tab = QWidget()
            layout = QVBoxLayout(tab)
            
            instructions = QLabel(I18N.t(
                "LINE Bot setup:\n1. Create LINE Developers account\n2. Create new bot\n3. Get Channel Access Token",
                "CÃ i Ä‘áº·t LINE Bot:\n1. Táº¡o tÃ i khoáº£n LINE Developers\n2. Táº¡o bot má»›i\n3. Láº¥y Channel Access Token"
            ))
            instructions.setStyleSheet("color: #666; font-size: 10px;")
            layout.addWidget(instructions)
            
            form_layout = QGridLayout()
            form_layout.addWidget(QLabel(I18N.t("Channel Access Token:", "Channel Access Token:")), 0, 0)
            self.line_access_token = QLineEdit()
            form_layout.addWidget(self.line_access_token, 0, 1)
            
            form_layout.addWidget(QLabel(I18N.t("User ID:", "User ID:")), 1, 0)
            self.line_user_id = QLineEdit()
            form_layout.addWidget(self.line_user_id, 1, 1)
            
            layout.addLayout(form_layout)
            layout.addStretch()
            self.config_tabs.addTab(tab, "ðŸ‡¯ðŸ‡µ LINE")
        
        def _create_kakaotalk_config_tab(self):
            """Create KakaoTalk configuration tab"""
            tab = QWidget()
            layout = QVBoxLayout(tab)
            
            instructions = QLabel(I18N.t(
                "KakaoTalk requires official API from Kakao Corp.",
                "KakaoTalk yÃªu cáº§u API chÃ­nh thá»©c tá»« Kakao Corp."
            ))
            instructions.setStyleSheet("color: #666; font-size: 10px;")
            layout.addWidget(instructions)
            
            form_layout = QGridLayout()
            form_layout.addWidget(QLabel(I18N.t("App Key:", "App Key:")), 0, 0)
            self.kakaotalk_app_key = QLineEdit()
            form_layout.addWidget(self.kakaotalk_app_key, 0, 1)
            
            layout.addLayout(form_layout)
            layout.addStretch()
            self.config_tabs.addTab(tab, "ðŸ‡°ðŸ‡· KakaoTalk")
        
        def _create_facebook_config_tab(self):
            """Create Facebook Messenger configuration tab"""
            tab = QWidget()
            layout = QVBoxLayout(tab)
            
            instructions = QLabel(I18N.t(
                "Facebook Messenger requires Graph API setup and page access token.",
                "Facebook Messenger yÃªu cáº§u cÃ i Ä‘áº·t Graph API vÃ  page access token."
            ))
            instructions.setStyleSheet("color: #666; font-size: 10px;")
            layout.addWidget(instructions)
            
            form_layout = QGridLayout()
            form_layout.addWidget(QLabel(I18N.t("Page Access Token:", "Page Access Token:")), 0, 0)
            self.facebook_token = QLineEdit()
            form_layout.addWidget(self.facebook_token, 0, 1)
            
            form_layout.addWidget(QLabel(I18N.t("Recipient ID:", "Recipient ID:")), 1, 0)
            self.facebook_recipient = QLineEdit()
            form_layout.addWidget(self.facebook_recipient, 1, 1)
            
            layout.addLayout(form_layout)
            layout.addStretch()
            self.config_tabs.addTab(tab, "ðŸ“˜ Facebook")
        
        def _create_instagram_config_tab(self):
            """Create Instagram DM configuration tab"""
            tab = QWidget()
            layout = QVBoxLayout(tab)
            
            instructions = QLabel(I18N.t(
                "Instagram DM uses Facebook Graph API. Business account required.",
                "Instagram DM sá»­ dá»¥ng Facebook Graph API. Cáº§n tÃ i khoáº£n doanh nghiá»‡p."
            ))
            instructions.setStyleSheet("color: #666; font-size: 10px;")
            layout.addWidget(instructions)
            
            form_layout = QGridLayout()
            form_layout.addWidget(QLabel(I18N.t("Access Token:", "Access Token:")), 0, 0)
            self.instagram_token = QLineEdit()
            form_layout.addWidget(self.instagram_token, 0, 1)
            
            layout.addLayout(form_layout)
            layout.addStretch()
            self.config_tabs.addTab(tab, "ðŸ“· Instagram")
        
        def _create_twitter_config_tab(self):
            """Create Twitter/X DM configuration tab"""
            tab = QWidget()
            layout = QVBoxLayout(tab)
            
            instructions = QLabel(I18N.t(
                "Twitter/X DM requires API v2 with elevated access.",
                "Twitter/X DM cáº§n API v2 vá»›i quyá»n truy cáº­p nÃ¢ng cao."
            ))
            instructions.setStyleSheet("color: #666; font-size: 10px;")
            layout.addWidget(instructions)
            
            form_layout = QGridLayout()
            form_layout.addWidget(QLabel(I18N.t("API Key:", "API Key:")), 0, 0)
            self.twitter_api_key = QLineEdit()
            form_layout.addWidget(self.twitter_api_key, 0, 1)
            
            form_layout.addWidget(QLabel(I18N.t("API Secret:", "API Secret:")), 1, 0)
            self.twitter_api_secret = QLineEdit()
            self.twitter_api_secret.setEchoMode(QLineEdit.Password)
            form_layout.addWidget(self.twitter_api_secret, 1, 1)
            
            layout.addLayout(form_layout)
            layout.addStretch()
            self.config_tabs.addTab(tab, "ðŸ¦ Twitter/X")
        
        def _create_linkedin_config_tab(self):
            """Create LinkedIn configuration tab"""
            tab = QWidget()
            layout = QVBoxLayout(tab)
            
            instructions = QLabel(I18N.t(
                "LinkedIn messaging requires LinkedIn API and company page.",
                "Nháº¯n tin LinkedIn cáº§n LinkedIn API vÃ  trang cÃ´ng ty."
            ))
            instructions.setStyleSheet("color: #666; font-size: 10px;")
            layout.addWidget(instructions)
            
            form_layout = QGridLayout()
            form_layout.addWidget(QLabel(I18N.t("Access Token:", "Access Token:")), 0, 0)
            self.linkedin_token = QLineEdit()
            form_layout.addWidget(self.linkedin_token, 0, 1)
            
            layout.addLayout(form_layout)
            layout.addStretch()
            self.config_tabs.addTab(tab, "ðŸ’¼ LinkedIn")
        
        def _create_slack_config_tab(self):
            """Create Slack configuration tab"""
            tab = QWidget()
            layout = QVBoxLayout(tab)
            
            instructions = QLabel(I18N.t(
                "Slack setup:\n1. Create Slack app\n2. Add Incoming Webhooks\n3. Copy webhook URL",
                "CÃ i Ä‘áº·t Slack:\n1. Táº¡o Slack app\n2. ThÃªm Incoming Webhooks\n3. Sao chÃ©p webhook URL"
            ))
            instructions.setStyleSheet("color: #666; font-size: 10px;")
            layout.addWidget(instructions)
            
            form_layout = QGridLayout()
            form_layout.addWidget(QLabel(I18N.t("Webhook URL:", "Webhook URL:")), 0, 0)
            self.slack_webhook = QLineEdit()
            self.slack_webhook.setPlaceholderText("https://hooks.slack.com/services/...")
            form_layout.addWidget(self.slack_webhook, 0, 1)
            
            layout.addLayout(form_layout)
            layout.addStretch()
            self.config_tabs.addTab(tab, "ðŸ’¬ Slack")
        
        def _create_teams_config_tab(self):
            """Create Microsoft Teams configuration tab"""
            tab = QWidget()
            layout = QVBoxLayout(tab)
            
            instructions = QLabel(I18N.t(
                "Teams setup:\n1. Go to Teams channel\n2. Add Incoming Webhook connector\n3. Copy webhook URL",
                "CÃ i Ä‘áº·t Teams:\n1. VÃ o kÃªnh Teams\n2. ThÃªm Incoming Webhook connector\n3. Sao chÃ©p webhook URL"
            ))
            instructions.setStyleSheet("color: #666; font-size: 10px;")
            layout.addWidget(instructions)
            
            form_layout = QGridLayout()
            form_layout.addWidget(QLabel(I18N.t("Webhook URL:", "Webhook URL:")), 0, 0)
            self.teams_webhook = QLineEdit()
            self.teams_webhook.setPlaceholderText("https://outlook.office.com/webhook/...")
            form_layout.addWidget(self.teams_webhook, 0, 1)
            
            layout.addLayout(form_layout)
            layout.addStretch()
            self.config_tabs.addTab(tab, "ðŸ‘¥ Teams")
        
        def _create_skype_config_tab(self):
            """Create Skype configuration tab"""
            tab = QWidget()
            layout = QVBoxLayout(tab)
            
            instructions = QLabel(I18N.t(
                "Skype messaging through Microsoft Bot Framework.",
                "Nháº¯n tin Skype qua Microsoft Bot Framework."
            ))
            instructions.setStyleSheet("color: #666; font-size: 10px;")
            layout.addWidget(instructions)
            
            form_layout = QGridLayout()
            form_layout.addWidget(QLabel(I18N.t("Bot ID:", "Bot ID:")), 0, 0)
            self.skype_bot_id = QLineEdit()
            form_layout.addWidget(self.skype_bot_id, 0, 1)
            
            layout.addLayout(form_layout)
            layout.addStretch()
            self.config_tabs.addTab(tab, "ðŸ“ž Skype")
        
        def _create_viber_config_tab(self):
            """Create Viber configuration tab"""
            tab = QWidget()
            layout = QVBoxLayout(tab)
            
            instructions = QLabel(I18N.t(
                "Viber Bot setup requires Viber Bot API registration.",
                "CÃ i Ä‘áº·t Viber Bot cáº§n Ä‘Äƒng kÃ½ Viber Bot API."
            ))
            instructions.setStyleSheet("color: #666; font-size: 10px;")
            layout.addWidget(instructions)
            
            form_layout = QGridLayout()
            form_layout.addWidget(QLabel(I18N.t("Auth Token:", "Auth Token:")), 0, 0)
            self.viber_token = QLineEdit()
            form_layout.addWidget(self.viber_token, 0, 1)
            
            layout.addLayout(form_layout)
            layout.addStretch()
            self.config_tabs.addTab(tab, "ðŸ’œ Viber")
        
        def _create_sms_config_tab(self):
            """Create SMS configuration tab"""
            tab = QWidget()
            layout = QVBoxLayout(tab)
            
            instructions = QLabel(I18N.t(
                "SMS sending via Twilio or other SMS providers.",
                "Gá»­i SMS qua Twilio hoáº·c nhÃ  cung cáº¥p SMS khÃ¡c."
            ))
            instructions.setStyleSheet("color: #666; font-size: 10px;")
            layout.addWidget(instructions)
            
            form_layout = QGridLayout()
            form_layout.addWidget(QLabel(I18N.t("Account SID:", "Account SID:")), 0, 0)
            self.sms_sid = QLineEdit()
            form_layout.addWidget(self.sms_sid, 0, 1)
            
            form_layout.addWidget(QLabel(I18N.t("Auth Token:", "Auth Token:")), 1, 0)
            self.sms_token = QLineEdit()
            self.sms_token.setEchoMode(QLineEdit.Password)
            form_layout.addWidget(self.sms_token, 1, 1)
            
            form_layout.addWidget(QLabel(I18N.t("From Number:", "Tá»« sá»‘:")), 2, 0)
            self.sms_from = QLineEdit()
            self.sms_from.setPlaceholderText("+1234567890")
            form_layout.addWidget(self.sms_from, 2, 1)
            
            form_layout.addWidget(QLabel(I18N.t("To Number:", "Äáº¿n sá»‘:")), 3, 0)
            self.sms_to = QLineEdit()
            self.sms_to.setPlaceholderText("+84987654321")
            form_layout.addWidget(self.sms_to, 3, 1)
            
            layout.addLayout(form_layout)
            layout.addStretch()
            self.config_tabs.addTab(tab, "ðŸ“± SMS")
        
        def _create_pushbullet_config_tab(self):
            """Create Pushbullet configuration tab"""
            tab = QWidget()
            layout = QVBoxLayout(tab)
            
            instructions = QLabel(I18N.t(
                "Pushbullet push notifications to your devices.",
                "Pushbullet gá»­i thÃ´ng bÃ¡o Ä‘áº¿n cÃ¡c thiáº¿t bá»‹ cá»§a báº¡n."
            ))
            instructions.setStyleSheet("color: #666; font-size: 10px;")
            layout.addWidget(instructions)
            
            form_layout = QGridLayout()
            form_layout.addWidget(QLabel(I18N.t("Access Token:", "Access Token:")), 0, 0)
            self.pushbullet_token = QLineEdit()
            form_layout.addWidget(self.pushbullet_token, 0, 1)
            
            layout.addLayout(form_layout)
            layout.addStretch()
            self.config_tabs.addTab(tab, "ðŸ“‹ Pushbullet")
        
        def _create_generic_config_tab(self, platform_name, tab_title):
            """Create a generic configuration tab for unknown platforms"""
            tab = QWidget()
            layout = QVBoxLayout(tab)
            
            instructions = QLabel(I18N.t(
                f"Configuration for {platform_name} is not yet implemented.",
                f"Cáº¥u hÃ¬nh cho {platform_name} chÆ°a Ä‘Æ°á»£c triá»ƒn khai."
            ))
            instructions.setStyleSheet("color: #666; font-size: 10px;")
            layout.addWidget(instructions)
            
            form_layout = QGridLayout()
            form_layout.addWidget(QLabel(I18N.t("API Endpoint:", "API Endpoint:")), 0, 0)
            generic_endpoint = QLineEdit()
            generic_endpoint.setPlaceholderText("https://api.example.com/...")
            form_layout.addWidget(generic_endpoint, 0, 1)
            
            form_layout.addWidget(QLabel(I18N.t("API Key:", "API Key:")), 1, 0)
            generic_key = QLineEdit()
            form_layout.addWidget(generic_key, 1, 1)
            
            layout.addLayout(form_layout)
            layout.addStretch()
            self.config_tabs.addTab(tab, tab_title)
        
        def _create_message_send_tab(self):
            """Create message composition and send tab with integrated branding settings"""
            message_tab = QWidget()
            layout = QVBoxLayout(message_tab)
            
            # Custom Message Area
            message_group = QGroupBox(I18N.t("âœï¸ Custom Message Content", "âœï¸ Ná»™i dung Tin nháº¯n TÃ¹y chá»‰nh"))
            message_layout = QVBoxLayout(message_group)
            
            # Checkbox to enable custom message
            self.send_custom_message = QCheckBox(I18N.t(
                "Enable custom message in notifications",
                "Báº­t tin nháº¯n tÃ¹y chá»‰nh trong thÃ´ng bÃ¡o"
            ))
            self.send_custom_message.setChecked(False)
            message_layout.addWidget(self.send_custom_message)
            
            self.custom_message = QTextEdit()
            self.custom_message.setPlaceholderText(I18N.t(
                "Enter your custom message here...",
                "Nháº­p tin nháº¯n tÃ¹y chá»‰nh táº¡i Ä‘Ã¢y..."
            ))
            self.custom_message.setMaximumHeight(120)
            message_layout.addWidget(self.custom_message)
            
            layout.addWidget(message_group)


            self.candlestick_patterns_btn = QPushButton(I18N.t("ï¿½ï¸ Candlestick Patterns", "ðŸ•¯ï¸ MÃ´ HÃ¬nh Náº¿n"))


            
            self.price_patterns_btn = QPushButton(I18N.t("ðŸ“Š Price Patterns", "ï¿½ MÃ´ HÃ¬nh GiÃ¡"))


            
            # All custom notification buttons and layouts removed
            
            # Custom message area removed - converted to checkbox below
            
            # Hidden radio buttons for backward compatibility (to prevent errors)
            from PyQt5.QtWidgets import QRadioButton
            self.signal_radio = QRadioButton()
            self.custom_radio = QRadioButton()
            self.report_radio = QRadioButton()
            self.signal_radio.hide()
            self.custom_radio.hide() 
            self.report_radio.hide()
            # Set default state
            self.custom_radio.setChecked(True)
            
            # Branding settings button (integrated)
            branding_section = QHBoxLayout()
            branding_btn = QPushButton(I18N.t("ðŸ·ï¸ Branding Settings", "ðŸ·ï¸ CÃ i Ä‘áº·t ThÆ°Æ¡ng hiá»‡u"))
            branding_btn.setStyleSheet("QPushButton { background-color: #007bff; color: white; font-weight: bold; padding: 8px 16px; }")
            branding_btn.clicked.connect(self._show_branding_settings)
            
            branding_status = QLabel(I18N.t("Custom footer: Enabled", "ChÃ¢n trang tÃ¹y chá»‰nh: Báº­t"))
            branding_status.setStyleSheet("color: #28a745; font-size: 10px; margin-left: 10px;")
            
            branding_section.addWidget(branding_btn)
            branding_section.addWidget(branding_status)
            branding_section.addStretch()
            
            layout.addLayout(branding_section)
            
            # ðŸ¤– AUTO NOTIFICATION SETTINGS
            auto_group = QGroupBox(I18N.t("ðŸ¤– Auto Notification Settings", "ðŸ¤– CÃ i Ä‘áº·t ThÃ´ng bÃ¡o Tá»± Ä‘á»™ng"))
            auto_layout = QVBoxLayout(auto_group)
            
            # Main auto notification toggle removed per user request
            # Order tracking options moved to Order Tracking Service section
            
            # ðŸ“Š NOTIFICATION FORMAT OPTIONS
            format_group = QGroupBox(I18N.t("ðŸ“Š Notification Format", "ðŸ“Š Äá»‹nh dáº¡ng ThÃ´ng bÃ¡o"))
            format_group_layout = QVBoxLayout(format_group)
            
            # Format selection with proper button group
            format_selection_layout = QHBoxLayout()
            self.format_summary_rb = QRadioButton(I18N.t("ðŸ“¡ Signal Only", "ðŸ“¡ Chá»‰ Signal"))
            # Don't set default here - will be set when loading config
            
            self.format_full_rb = QRadioButton(I18N.t("ðŸ“Š Signal + Analysis", "ðŸ“Š Signal + PhÃ¢n tÃ­ch"))
            
            # Create button group to ensure mutual exclusion
            self.format_button_group = QButtonGroup()
            self.format_button_group.addButton(self.format_summary_rb, 0)  # ID 0 for summary
            self.format_button_group.addButton(self.format_full_rb, 1)     # ID 1 for full
            
            format_selection_layout.addWidget(self.format_summary_rb)
            format_selection_layout.addWidget(self.format_full_rb)
            format_selection_layout.addStretch()
            
            format_group_layout.addLayout(format_selection_layout)
            
            # 5 Notification Type Checkboxes - All in one row
            options_layout = QHBoxLayout()  # Single horizontal row
            
            # Row 1: Technical Analysis and Indicators
            row1_layout = QHBoxLayout()
            self.include_technical_cb = QCheckBox(I18N.t("âš—ï¸ Technical Analysis", "âš—ï¸ PhÃ¢n TÃ­ch Ká»¹ Thuáº­t"))
            self.include_indicators_cb = QCheckBox(I18N.t("ðŸ§® Indicators", "ðŸ§® Chá»‰ BÃ¡o"))
            self.include_summary_cb = QCheckBox(I18N.t("ðŸ“‹ Summary", "ðŸ“‹ TÃ³m Táº¯t"))
            self.include_candlestick_cb = QCheckBox(I18N.t("ðŸ•¯ï¸ Candlestick Patterns", "ðŸ•¯ï¸ MÃ´ HÃ¬nh Náº¿n")) 
            self.include_price_patterns_cb = QCheckBox(I18N.t("ðŸ’¹ Price Patterns", "ðŸ’¹ MÃ´ HÃ¬nh GiÃ¡"))
            
            # ðŸ”§ FIX: Don't set default checked state here!
            # Let _load_auto_notification_settings() set the correct states from config
            # Default to False - will be updated when config loads
            
            # Add all 5 checkboxes to single horizontal row
            options_layout.addWidget(self.include_technical_cb)
            options_layout.addWidget(self.include_indicators_cb)
            options_layout.addWidget(self.include_summary_cb)
            options_layout.addWidget(self.include_candlestick_cb)
            options_layout.addWidget(self.include_price_patterns_cb)
            options_layout.addStretch()

            
            format_group_layout.addLayout(options_layout)
            
            # ðŸ”§ FIX: Don't call _trigger_whitelist_update() here!
            # It will be called after settings are loaded from config
            
            # ðŸ”§ FIX: Don't set default format here - let config decide
            # Will be set properly in _load_auto_notification_settings()
            
            # ðŸ”§ FIX: Don't call _on_format_changed() here - it will be called after load
            
            # Format preview info
            format_info = QLabel(I18N.t("ðŸ’¡ Full format includes technical analysis from reports", "ðŸ’¡ Äá»‹nh dáº¡ng Ä‘áº§y Ä‘á»§ bao gá»“m phÃ¢n tÃ­ch ká»¹ thuáº­t tá»« bÃ¡o cÃ¡o"))
            format_info.setStyleSheet("color: #666; font-size: 9px; font-style: italic;")
            format_group_layout.addWidget(format_info)
            

            
            auto_layout.addWidget(format_group)
            
            # Status info
            status_label = QLabel(I18N.t("ðŸ’¡ Auto notifications will be sent to enabled platforms", "ðŸ’¡ ThÃ´ng bÃ¡o tá»± Ä‘á»™ng sáº½ Ä‘Æ°á»£c gá»­i Ä‘áº¿n cÃ¡c ná»n táº£ng Ä‘Ã£ báº­t"))
            status_label.setStyleSheet("color: #666; font-size: 9px; font-style: italic;")
            auto_layout.addWidget(status_label)
            
            layout.addWidget(auto_group)
            
            # ðŸ”§ ORDER TRACKING OPTIONS - DIRECT CHECKBOX CONTROL
            service_group = QGroupBox(I18N.t("ðŸ”§ Auto Notification Settings", "ðŸ”§ CÃ i Ä‘áº·t ThÃ´ng bÃ¡o Tá»± Ä‘á»™ng"))
            service_layout = QVBoxLayout(service_group)
            
            # Logs button (keep for debugging)
            service_controls_layout = QHBoxLayout()
            self.service_logs_btn = QPushButton(I18N.t("ðŸ“ Logs", "ðŸ“ Nháº­t kÃ½"))
            self.service_logs_btn.setStyleSheet("QPushButton { background-color: #6c757d; color: white; font-weight: bold; padding: 6px 12px; }")
            self.service_logs_btn.clicked.connect(self._view_service_logs)
            
            service_controls_layout.addWidget(self.service_logs_btn)
            service_controls_layout.addStretch()
            service_layout.addLayout(service_controls_layout)
            
            # Order tracking options - each checkbox controls its own functionality
            tracking_layout = QHBoxLayout()
            

            self.track_orders_cb = QCheckBox(I18N.t("âœ…ðŸ“Š Track order changes", "âœ…ðŸ“Š Theo dÃµi thay Ä‘á»•i lá»‡nh"))
            self.notify_sl_tp_cb = QCheckBox(I18N.t("ðŸ›¡ï¸ SL/TP changes", "ðŸ›¡ï¸ Thay Ä‘á»•i SL/TP"))
            self.notify_close_cb = QCheckBox(I18N.t("ðŸ Order close", "ðŸ ÄÃ³ng lá»‡nh"))
            

            tracking_layout.addWidget(self.track_orders_cb)
            tracking_layout.addWidget(self.notify_sl_tp_cb)
            tracking_layout.addWidget(self.notify_close_cb)
            tracking_layout.addStretch()
            
            service_layout.addLayout(tracking_layout)
            
            # ðŸ†• Pip threshold settings for tracking notifications
            pip_threshold_layout = QHBoxLayout()
            
            # Track orders pip threshold
            self.track_pips_label = QLabel(I18N.t("ðŸ“Š Order change threshold:", "ðŸ“Š NgÆ°á»¡ng thay Ä‘á»•i lá»‡nh:"))
            self.track_pips_label.setStyleSheet("font-size: 10px;")
            self.track_orders_pips_spin = QSpinBox()
            self.track_orders_pips_spin.setRange(0, 500)
            self.track_orders_pips_spin.setValue(50)
            self.track_orders_pips_spin.setSuffix(" pips")
            self.track_orders_pips_spin.setToolTip(I18N.t(
                "Notify when order P/L changes by this many pips from last notification (0 = notify every interval)",
                "ThÃ´ng bÃ¡o khi P/L thay Ä‘á»•i bao nhiÃªu pips so vá»›i láº§n thÃ´ng bÃ¡o trÆ°á»›c (0 = thÃ´ng bÃ¡o má»—i interval)"
            ))
            self.track_orders_pips_spin.setFixedWidth(90)
            
            pip_threshold_layout.addWidget(self.track_pips_label)
            pip_threshold_layout.addWidget(self.track_orders_pips_spin)
            
            pip_threshold_layout.addSpacing(20)
            
            # SL/TP pip threshold
            self.sltp_pips_label = QLabel(I18N.t("ðŸ›¡ï¸ SL/TP threshold:", "ðŸ›¡ï¸ NgÆ°á»¡ng SL/TP:"))
            self.sltp_pips_label.setStyleSheet("font-size: 10px;")
            self.sltp_pips_spin = QSpinBox()
            self.sltp_pips_spin.setRange(0, 500)
            self.sltp_pips_spin.setValue(10)
            self.sltp_pips_spin.setSuffix(" pips")
            self.sltp_pips_spin.setToolTip(I18N.t(
                "Only notify when SL/TP changes by at least this many pips (0 = notify any change)",
                "Chá»‰ thÃ´ng bÃ¡o khi SL/TP thay Ä‘á»•i Ã­t nháº¥t bao nhiÃªu pips (0 = thÃ´ng bÃ¡o má»i thay Ä‘á»•i)"
            ))
            self.sltp_pips_spin.setFixedWidth(90)
            
            pip_threshold_layout.addWidget(self.sltp_pips_label)
            pip_threshold_layout.addWidget(self.sltp_pips_spin)
            pip_threshold_layout.addStretch()
            
            service_layout.addLayout(pip_threshold_layout)
            
            # ðŸ†• Initially disable spinboxes (will be enabled when checkbox is checked)
            self.track_pips_label.setEnabled(False)
            self.track_orders_pips_spin.setEnabled(False)
            self.sltp_pips_label.setEnabled(False)
            self.sltp_pips_spin.setEnabled(False)
            
            service_info = QLabel(I18N.t("ðŸ’¡ Background service monitors executed orders for changes", "ðŸ’¡ Dá»‹ch vá»¥ ná»n theo dÃµi cÃ¡c lá»‡nh Ä‘Ã£ thá»±c hiá»‡n"))
            service_info.setStyleSheet("color: #666; font-size: 9px; font-style: italic;")
            service_layout.addWidget(service_info)
            
            layout.addWidget(service_group)
            
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # ðŸ†• ADVANCED TRADING HISTORY REPORT - BÃ¡o cÃ¡o LSGD nÃ¢ng cao
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            history_report_group = QGroupBox(I18N.t("ðŸ“Š Trading History Report", "ðŸ“Š BÃ¡o cÃ¡o Lá»‹ch sá»­ Giao dá»‹ch"))
            history_report_layout = QVBoxLayout(history_report_group)
            history_report_layout.setSpacing(8)
            
            # === Row 1: Period Selection ===
            period_row = QHBoxLayout()
            period_row.setSpacing(8)
            
            period_label = QLabel(I18N.t("ðŸ“… Report Period:", "ðŸ“… Khoáº£ng thá»i gian:"))
            period_label.setStyleSheet("font-weight: bold; font-size: 10px;")
            period_row.addWidget(period_label)
            
            # Period type combo box
            self.history_period_combo = QComboBox()
            self.history_period_combo.addItems([
                I18N.t("Today", "HÃ´m nay"),
                I18N.t("Yesterday", "HÃ´m qua"),
                I18N.t("Last 24 hours", "24 giá» qua"),
                I18N.t("This Week", "Tuáº§n nÃ y"),
                I18N.t("Last Week", "Tuáº§n trÆ°á»›c"),
                I18N.t("This Month", "ThÃ¡ng nÃ y"),
                I18N.t("Last Month", "ThÃ¡ng trÆ°á»›c"),
                I18N.t("Custom Range", "TÃ¹y chá»‰nh")
            ])
            self.history_period_combo.setFixedWidth(120)
            self.history_period_combo.setToolTip(I18N.t(
                "Select time period for trading history report",
                "Chá»n khoáº£ng thá»i gian cho bÃ¡o cÃ¡o lá»‹ch sá»­ giao dá»‹ch"
            ))
            period_row.addWidget(self.history_period_combo)
            
            # Symbol filter combo box
            symbol_label = QLabel(I18N.t("ðŸ“Š Symbol:", "ðŸ“Š KÃ½ hiá»‡u:"))
            symbol_label.setStyleSheet("font-weight: bold; font-size: 10px;")
            period_row.addWidget(symbol_label)
            
            self.history_symbol_combo = QComboBox()
            self.history_symbol_combo.addItem(I18N.t("All Symbols", "Táº¥t cáº£ kÃ½ hiá»‡u"))
            self.history_symbol_combo.addItems(["EURUSD", "GBPUSD", "XAUUSD", "BNBUSD", "LTCUSD", "SOLUSD"])
            self.history_symbol_combo.setFixedWidth(100)
            self.history_symbol_combo.setToolTip(I18N.t(
                "Filter by symbol",
                "Lá»c theo kÃ½ hiá»‡u"
            ))
            period_row.addWidget(self.history_symbol_combo)
            
            # Custom date range (from - to)
            self.history_from_label = QLabel(I18N.t("From:", "Tá»«:"))
            self.history_from_label.setStyleSheet("font-size: 9px;")
            self.history_from_label.setVisible(False)
            period_row.addWidget(self.history_from_label)
            
            self.history_from_date = QDateEdit()
            self.history_from_date.setCalendarPopup(True)
            self.history_from_date.setDate(QDate.currentDate().addDays(-7))
            self.history_from_date.setDisplayFormat("dd/MM/yyyy")
            self.history_from_date.setFixedWidth(100)
            self.history_from_date.setVisible(False)
            period_row.addWidget(self.history_from_date)
            
            self.history_to_label = QLabel(I18N.t("To:", "Äáº¿n:"))
            self.history_to_label.setStyleSheet("font-size: 9px;")
            self.history_to_label.setVisible(False)
            period_row.addWidget(self.history_to_label)
            
            self.history_to_date = QDateEdit()
            self.history_to_date.setCalendarPopup(True)
            self.history_to_date.setDate(QDate.currentDate())
            self.history_to_date.setDisplayFormat("dd/MM/yyyy")
            self.history_to_date.setFixedWidth(100)
            self.history_to_date.setVisible(False)
            period_row.addWidget(self.history_to_date)
            
            period_row.addStretch()
            history_report_layout.addLayout(period_row)
            
            # === Row 2: Report Options ===
            options_row = QHBoxLayout()
            options_row.setSpacing(10)
            
            # Include options (removed "Open trades" - only closed trades for history)
            self.history_include_closed = QCheckBox(I18N.t("Closed trades", "Lá»‡nh Ä‘Ã£ Ä‘Ã³ng"))
            self.history_include_closed.setChecked(True)
            self.history_include_closed.setToolTip(I18N.t("Include closed positions", "Bao gá»“m cÃ¡c lá»‡nh Ä‘Ã£ Ä‘Ã³ng"))
            options_row.addWidget(self.history_include_closed)
            
            self.history_include_stats = QCheckBox(I18N.t("Statistics", "Thá»‘ng kÃª"))
            self.history_include_stats.setChecked(True)
            self.history_include_stats.setToolTip(I18N.t("Include profit/loss statistics", "Bao gá»“m thá»‘ng kÃª lÃ£i/lá»—"))
            options_row.addWidget(self.history_include_stats)
            
            self.history_include_chart = QCheckBox(I18N.t("Summary chart", "Biá»ƒu Ä‘á»“ tÃ³m táº¯t"))
            self.history_include_chart.setChecked(False)
            self.history_include_chart.setToolTip(I18N.t("Include text-based summary chart", "Bao gá»“m biá»ƒu Ä‘á»“ tÃ³m táº¯t dáº¡ng text"))
            options_row.addWidget(self.history_include_chart)
            
            options_row.addStretch()
            history_report_layout.addLayout(options_row)
            
            # === Row 3: Auto-send Schedule ===
            schedule_row = QHBoxLayout()
            schedule_row.setSpacing(8)
            
            self.daily_summary_cb = QCheckBox(I18N.t("â° Auto-send", "â° Tá»± Ä‘á»™ng gá»­i"))
            self.daily_summary_cb.setToolTip(I18N.t(
                "Automatically send trading history report at scheduled time",
                "Tá»± Ä‘á»™ng gá»­i bÃ¡o cÃ¡o lá»‹ch sá»­ giao dá»‹ch vÃ o giá» Ä‘Ã£ Ä‘áº·t"
            ))
            schedule_row.addWidget(self.daily_summary_cb)
            
            # Schedule type combo - simplified to hourly/daily only
            self.history_schedule_type = QComboBox()
            self.history_schedule_type.addItems([
                I18N.t("Hourly", "Theo giá»"),
                I18N.t("Daily", "Háº±ng ngÃ y")
            ])
            self.history_schedule_type.setFixedWidth(100)
            self.history_schedule_type.setEnabled(False)
            schedule_row.addWidget(self.history_schedule_type)
            
            # ðŸ†• Hourly interval spin box
            self.history_hourly_label = QLabel(I18N.t("Every:", "Má»—i:"))
            self.history_hourly_label.setStyleSheet("font-size: 10px;")
            self.history_hourly_label.setVisible(False)  # Hidden by default, shown when "Hourly" selected
            schedule_row.addWidget(self.history_hourly_label)
            self.history_hourly_interval = QSpinBox()
            self.history_hourly_interval.setMinimum(1)
            self.history_hourly_interval.setMaximum(24)
            self.history_hourly_interval.setValue(1)
            self.history_hourly_interval.setSuffix(I18N.t(" hour(s)", " giá»"))
            self.history_hourly_interval.setFixedWidth(80)
            self.history_hourly_interval.setVisible(False)  # Hidden by default
            self.history_hourly_interval.setToolTip(I18N.t(
                "Send report every N hours (1-24)",
                "Gá»­i bÃ¡o cÃ¡o má»—i N giá» (1-24)"
            ))
            schedule_row.addWidget(self.history_hourly_interval)
            
            time_label = QLabel(I18N.t("at:", "lÃºc:"))
            time_label.setStyleSheet("font-size: 10px;")
            schedule_row.addWidget(time_label)
            
            self.daily_summary_time = QTimeEdit()
            self.daily_summary_time.setDisplayFormat("HH:mm")
            self.daily_summary_time.setTime(QTime(20, 0))  # Default 20:00
            self.daily_summary_time.setToolTip(I18N.t(
                "Time to send trading report (24h format)",
                "Giá» gá»­i bÃ¡o cÃ¡o giao dá»‹ch (Ä‘á»‹nh dáº¡ng 24h)"
            ))
            self.daily_summary_time.setFixedWidth(70)
            self.daily_summary_time.setEnabled(False)
            schedule_row.addWidget(self.daily_summary_time)
            
            schedule_row.addStretch()
            history_report_layout.addLayout(schedule_row)
            
            # === Row 4: Preview and Send Buttons ===
            button_row = QHBoxLayout()
            button_row.setSpacing(10)
            
            # Preview button
            self.preview_history_btn = QPushButton(I18N.t("ðŸ‘ï¸ Preview Report", "ðŸ‘ï¸ Xem trÆ°á»›c BÃ¡o cÃ¡o"))
            self.preview_history_btn.setToolTip(I18N.t(
                "Preview the trading history report before sending",
                "Xem trÆ°á»›c bÃ¡o cÃ¡o lá»‹ch sá»­ giao dá»‹ch trÆ°á»›c khi gá»­i"
            ))
            self.preview_history_btn.setFixedWidth(140)
            self.preview_history_btn.setStyleSheet("background-color: #2196F3; color: white; font-weight: bold;")
            button_row.addWidget(self.preview_history_btn)
            
            # Send now button
            self.send_daily_summary_btn = QPushButton(I18N.t("ðŸ“¤ Send Report", "ðŸ“¤ Gá»­i BÃ¡o cÃ¡o"))
            self.send_daily_summary_btn.setToolTip(I18N.t(
                "Send trading history report immediately",
                "Gá»­i bÃ¡o cÃ¡o lá»‹ch sá»­ giao dá»‹ch ngay láº­p tá»©c"
            ))
            self.send_daily_summary_btn.setFixedWidth(120)
            self.send_daily_summary_btn.setStyleSheet("background-color: #4CAF50; color: white; font-weight: bold;")
            button_row.addWidget(self.send_daily_summary_btn)
            
            button_row.addStretch()
            history_report_layout.addLayout(button_row)
            
            layout.addWidget(history_report_group)
            
            # Connect history report signals
            self.history_period_combo.currentIndexChanged.connect(self._on_history_period_changed)
            self.preview_history_btn.clicked.connect(self._preview_history_report)
            self.daily_summary_cb.toggled.connect(lambda checked: (
                self.history_schedule_type.setEnabled(checked),
                self.daily_summary_time.setEnabled(checked)
            ))
            
            # ðŸ†• Connect history schedule type to toggle hourly interval visibility
            self.history_schedule_type.currentIndexChanged.connect(self._on_history_schedule_type_changed)
            
            # ðŸ”§ FIX: Load current auto notification settings FIRST (before connecting signals)
            self._load_auto_notification_settings()
            
            # ðŸ”§ FIX: NOW connect signals AFTER loading settings to prevent save during load
            # Connect auto notification signals  
            # Connect each checkbox to both save settings AND manage its own service

            self.track_orders_cb.toggled.connect(self._on_track_orders_toggled)
            self.notify_sl_tp_cb.toggled.connect(self._on_sl_tp_toggled)
            self.notify_close_cb.toggled.connect(self._on_close_toggled)
            self.format_summary_rb.toggled.connect(self._save_auto_notification_settings)
            self.format_full_rb.toggled.connect(self._save_auto_notification_settings)
            
            # Connect pip threshold spinboxes to save settings
            self.track_orders_pips_spin.valueChanged.connect(self._save_auto_notification_settings)
            self.sltp_pips_spin.valueChanged.connect(self._save_auto_notification_settings)
            
            # ðŸ†• Connect checkboxes to enable/disable corresponding spinboxes
            self.track_orders_cb.toggled.connect(self._update_pip_threshold_state)
            self.notify_sl_tp_cb.toggled.connect(self._update_pip_threshold_state)
            
            # Connect format radio buttons to enable/disable report checkboxes
            self.format_summary_rb.toggled.connect(self._on_format_changed)
            self.format_full_rb.toggled.connect(self._on_format_changed)
            
            # Connect 5 new notification type checkboxes
            self.include_technical_cb.toggled.connect(self._save_auto_notification_settings)
            self.include_indicators_cb.toggled.connect(self._save_auto_notification_settings)
            self.include_summary_cb.toggled.connect(self._save_auto_notification_settings)
            self.include_candlestick_cb.toggled.connect(self._save_auto_notification_settings)
            self.include_price_patterns_cb.toggled.connect(self._save_auto_notification_settings)
            
            # ðŸŽ¯ UPDATE WHITELIST when pattern checkboxes change
            self.include_candlestick_cb.toggled.connect(lambda checked: (print(f"ðŸ”” Candlestick checkbox toggled: {checked}"), self._trigger_whitelist_update()))
            self.include_price_patterns_cb.toggled.connect(lambda checked: (print(f"ðŸ”” Price patterns checkbox toggled: {checked}"), self._trigger_whitelist_update()))
            
            # Also update preview when checkboxes change
            self.include_technical_cb.toggled.connect(lambda: self._update_preview() if hasattr(self, '_update_preview') else None)
            self.include_indicators_cb.toggled.connect(lambda: self._update_preview() if hasattr(self, '_update_preview') else None)
            self.include_summary_cb.toggled.connect(lambda: self._update_preview() if hasattr(self, '_update_preview') else None)
            self.include_candlestick_cb.toggled.connect(lambda: self._update_preview() if hasattr(self, '_update_preview') else None)
            self.include_price_patterns_cb.toggled.connect(lambda: self._update_preview() if hasattr(self, '_update_preview') else None)
            
            # Connect custom message controls to auto-save
            self.send_custom_message.toggled.connect(self._save_auto_notification_settings)
            self.custom_message.textChanged.connect(self._save_auto_notification_settings)
            
            # ðŸ†• Connect daily summary controls
            self.daily_summary_cb.toggled.connect(self._on_daily_summary_toggled)
            self.daily_summary_time.timeChanged.connect(self._save_auto_notification_settings)
            self.send_daily_summary_btn.clicked.connect(self._send_history_report_now)  # Use new enhanced function
            
            # Preview section
            preview_group = QGroupBox(I18N.t("Message Preview", "Xem trÆ°á»›c tin nháº¯n"))
            preview_layout = QVBoxLayout(preview_group)
            
            self.preview_area = QTextBrowser()
            self.preview_area.setMaximumHeight(200)
            preview_layout.addWidget(self.preview_area)
            
            layout.addWidget(preview_group)
            
            self.main_tabs.addTab(message_tab, I18N.t("ðŸ“¤ Message & Send", "ðŸ“¤ Tin nháº¯n & Gá»­i"))
        
        def _show_branding_settings(self):
            """Show branding settings popup dialog"""
            try:
                from PyQt5.QtWidgets import QDialog, QVBoxLayout, QHBoxLayout, QGridLayout, QGroupBox, QLabel, QLineEdit, QTextEdit, QCheckBox, QPushButton, QTextBrowser
                from PyQt5.QtCore import Qt
                
                dialog = QDialog(self)
                dialog.setWindowTitle(I18N.t("ðŸ·ï¸ Branding Settings", "ðŸ·ï¸ CÃ i Ä‘áº·t ThÆ°Æ¡ng hiá»‡u"))
                dialog.setModal(True)
                dialog.resize(550, 600)
                
                layout = QVBoxLayout(dialog)
                
                # Simplified branding settings
                branding_group = QGroupBox(I18N.t("ðŸ·ï¸ System Information", "ðŸ·ï¸ ThÃ´ng tin Há»‡ thá»‘ng"))
                branding_layout = QGridLayout(branding_group)
                
                # System Names (simplified)
                branding_layout.addWidget(QLabel(I18N.t("System Name (EN):", "TÃªn há»‡ thá»‘ng (EN):")), 0, 0)
                self.popup_system_name_en = QLineEdit()
                self.popup_system_name_en.setText("")  # Will be loaded from config
                branding_layout.addWidget(self.popup_system_name_en, 0, 1)
                
                branding_layout.addWidget(QLabel(I18N.t("System Name (VI):", "TÃªn há»‡ thá»‘ng (VI):")), 1, 0)
                self.popup_system_name_vi = QLineEdit()
                self.popup_system_name_vi.setText("")  # Will be loaded from config
                branding_layout.addWidget(self.popup_system_name_vi, 1, 1)
                
                layout.addWidget(branding_group)
                
                # Contact info (simplified)
                contact_group = QGroupBox(I18N.t("ðŸ“ž Contact Information", "ðŸ“ž ThÃ´ng tin LiÃªn há»‡"))
                contact_layout = QGridLayout(contact_group)
                
                contact_layout.addWidget(QLabel(I18N.t("Phone:", "Äiá»‡n thoáº¡i:")), 0, 0)
                self.popup_contact_phone = QLineEdit()
                self.popup_contact_phone.setText("")  # Will be loaded from config
                contact_layout.addWidget(self.popup_contact_phone, 0, 1)
                
                contact_layout.addWidget(QLabel(I18N.t("Email:", "Email:")), 1, 0)
                self.popup_contact_email = QLineEdit()
                self.popup_contact_email.setText("")  # Will be loaded from config
                contact_layout.addWidget(self.popup_contact_email, 1, 1)
                
                layout.addWidget(contact_group)
                
                # Footer settings (simplified)
                footer_group = QGroupBox(I18N.t("ðŸ“ Footer Settings", "ðŸ“ CÃ i Ä‘áº·t ChÃ¢n trang"))
                footer_layout = QVBoxLayout(footer_group)
                
                self.popup_enable_custom_footer = QCheckBox(I18N.t("Enable custom footer", "Báº­t chÃ¢n trang tÃ¹y chá»‰nh"))
                self.popup_enable_custom_footer.setChecked(True)
                footer_layout.addWidget(self.popup_enable_custom_footer)
                
                layout.addWidget(footer_group)
                
                # Preview
                preview_group = QGroupBox(I18N.t("ðŸ‘€ Preview", "ðŸ‘€ Xem trÆ°á»›c"))
                preview_layout = QVBoxLayout(preview_group)
                
                self.popup_preview = QTextBrowser()
                self.popup_preview.setMaximumHeight(100)
                preview_layout.addWidget(self.popup_preview)
                
                layout.addWidget(preview_group)
                
                # Buttons
                button_layout = QHBoxLayout()
                
                save_btn = QPushButton(I18N.t("ðŸ’¾ Save", "ðŸ’¾ LÆ°u"))
                save_btn.setStyleSheet("QPushButton { background-color: #28a745; color: white; font-weight: bold; padding: 8px 16px; }")
                save_btn.clicked.connect(lambda: self._save_branding_settings(dialog))
                
                cancel_btn = QPushButton(I18N.t("âŒ Cancel", "âŒ Há»§y"))
                cancel_btn.setStyleSheet("QPushButton { background-color: #dc3545; color: white; font-weight: bold; padding: 8px 16px; }")
                cancel_btn.clicked.connect(dialog.reject)
                
                button_layout.addWidget(save_btn)
                button_layout.addWidget(cancel_btn)
                button_layout.addStretch()
                
                layout.addLayout(button_layout)
                
                # Load current settings and update preview
                self._load_branding_settings_to_popup()
                self._update_popup_preview()
                
                # Connect signals for real-time preview
                self.popup_system_name_en.textChanged.connect(self._update_popup_preview)
                self.popup_system_name_vi.textChanged.connect(self._update_popup_preview)
                self.popup_contact_phone.textChanged.connect(self._update_popup_preview)
                self.popup_contact_email.textChanged.connect(self._update_popup_preview)
                self.popup_enable_custom_footer.toggled.connect(self._update_popup_preview)
                
                dialog.exec_()
                
            except Exception as e:
                print(f"âŒ [ERROR] Failed to show branding settings: {e}")
                QMessageBox.warning(self, I18N.t("Error", "Lá»—i"), 
                                  I18N.t("Failed to show branding settings: {error}", "KhÃ´ng thá»ƒ hiá»‡n cÃ i Ä‘áº·t thÆ°Æ¡ng hiá»‡u: {error}", error=str(e)))
        
        def _load_branding_settings_to_popup(self):
            """Load current branding settings from config file to popup"""
            try:
                # Check if popup widgets exist
                if not hasattr(self, 'popup_system_name_en'):
                    print("âš ï¸ [DEBUG] Popup widgets not yet created")
                    return
                
                # Load from notification_config.json
                config_file = "notification_config.json"
                if os.path.exists(config_file):
                    with open(config_file, 'r', encoding='utf-8') as f:
                        config = json.load(f)
                        
                    branding = config.get('branding', {})
                    
                    # Set values in popup fields - only if widgets exist
                    if hasattr(self, 'popup_system_name_en'):
                        self.popup_system_name_en.setText(branding.get('system_name_en', 'VU HIEN CFDs Smart Trading'))
                    if hasattr(self, 'popup_system_name_vi'):
                        self.popup_system_name_vi.setText(branding.get('system_name_vi', 'Há»‡ thá»‘ng AI VU HIEN CFDs'))
                    if hasattr(self, 'popup_contact_phone'):
                        self.popup_contact_phone.setText(branding.get('phone', '+84 39 65 60 888'))
                    if hasattr(self, 'popup_contact_email'):
                        self.popup_contact_email.setText(branding.get('email', ''))
                    if hasattr(self, 'popup_enable_custom_footer'):
                        self.popup_enable_custom_footer.setChecked(branding.get('enable_custom_footer', True))
                    
            except Exception as e:
                print(f"âš ï¸ [WARNING] Failed to load branding settings: {e}")
        
        def _save_branding_settings(self, dialog):
            """Save branding settings from popup to config file"""
            try:
                # Load existing config
                config_file = "notification_config.json"
                config = {}
                if os.path.exists(config_file):
                    with open(config_file, 'r', encoding='utf-8') as f:
                        config = json.load(f)
                
                # Update branding section
                if 'branding' not in config:
                    config['branding'] = {}
                
                # Only update values if popup widgets exist
                branding_data = {}
                if hasattr(self, 'popup_system_name_en'):
                    branding_data['system_name_en'] = self.popup_system_name_en.text()
                if hasattr(self, 'popup_system_name_vi'):
                    branding_data['system_name_vi'] = self.popup_system_name_vi.text()
                if hasattr(self, 'popup_contact_phone'):
                    branding_data['phone'] = self.popup_contact_phone.text()
                if hasattr(self, 'popup_contact_email'):
                    branding_data['email'] = self.popup_contact_email.text()
                if hasattr(self, 'popup_enable_custom_footer'):
                    branding_data['enable_custom_footer'] = self.popup_enable_custom_footer.isChecked()
                
                config['branding'].update(branding_data)
                
                # Save back to file
                with open(config_file, 'w', encoding='utf-8') as f:
                    json.dump(config, f, indent=2, ensure_ascii=False)
                
                # Show success message and close dialog
                QMessageBox.information(dialog, I18N.t("Success", "ThÃ nh cÃ´ng"), 
                                      I18N.t("Branding settings saved successfully!", "CÃ i Ä‘áº·t thÆ°Æ¡ng hiá»‡u Ä‘Ã£ lÆ°u thÃ nh cÃ´ng!"))
                dialog.accept()
                
            except Exception as e:
                print(f"âŒ [ERROR] Failed to save branding settings: {e}")
                QMessageBox.critical(dialog, I18N.t("Error", "Lá»—i"), 
                                   I18N.t("Failed to save branding settings: {error}", "KhÃ´ng thá»ƒ lÆ°u cÃ i Ä‘áº·t thÆ°Æ¡ng hiá»‡u: {error}", error=str(e)))
        
        def _update_popup_preview(self):
            """Update preview in branding settings popup"""
            try:
                # Check if all popup widgets exist
                if not (hasattr(self, 'popup_preview') and hasattr(self, 'popup_enable_custom_footer')):
                    return
                    
                if self.popup_enable_custom_footer.isChecked():
                    system_name = ""
                    phone = ""
                    email = ""
                    
                    # Safely get values from widgets
                    if hasattr(self, 'popup_system_name_vi') and self.popup_system_name_vi:
                        system_name = self.popup_system_name_vi.text() or "Há»‡ thá»‘ng AI VU HIEN CFDs"
                    else:
                        system_name = "Há»‡ thá»‘ng AI VU HIEN CFDs"
                        
                    if hasattr(self, 'popup_contact_phone') and self.popup_contact_phone:
                        phone = self.popup_contact_phone.text() or "+84 39 65 60 888"
                    else:
                        phone = "+84 39 65 60 888"
                        
                    if hasattr(self, 'popup_contact_email') and self.popup_contact_email:
                        email = self.popup_contact_email.text()
                    
                    preview = f"ðŸ¤– {system_name}"
                    if phone:
                        preview += f"\nðŸ“± {phone}"
                    if email:
                        preview += f"\nðŸ“§ {email}"
                    
                    self.popup_preview.setText(preview)
                else:
                    self.popup_preview.setText(I18N.t("Footer disabled", "ChÃ¢n trang Ä‘Ã£ táº¯t"))
            except Exception as e:
                print(f"âš ï¸ [WARNING] Failed to update popup preview: {e}")
                # Set fallback preview to prevent crash
                if hasattr(self, 'popup_preview') and self.popup_preview:
                    self.popup_preview.setText(I18N.t("Cannot display preview", "KhÃ´ng thá»ƒ hiá»ƒn thá»‹ xem trÆ°á»›c"))
        
        # _create_branding_settings_tab method removed - functionality integrated into message tab popup
        # All branding settings now accessible via "ðŸ·ï¸ Branding Settings" button in message tab
            
            # Message Footer Settings
            footer_group = QGroupBox(I18N.t("ðŸ“ Message Footer Settings", "ðŸ“ CÃ i Ä‘áº·t ChÃ¢n trang Tin nháº¯n"))
            footer_layout = QVBoxLayout(footer_group)
            
            # Custom footer checkbox
            self.enable_custom_footer = QCheckBox(I18N.t(
                "Enable custom footer in messages",
                "Báº­t chÃ¢n trang tÃ¹y chá»‰nh trong tin nháº¯n"
            ))
            self.enable_custom_footer.setChecked(True)
            footer_layout.addWidget(self.enable_custom_footer)
            
            # Footer template
            footer_template_label = QLabel(I18N.t(
                "Footer Template (use {system_name}, {phone}, {email}, {website}, {social}):",
                "Máº«u chÃ¢n trang (sá»­ dá»¥ng {system_name}, {phone}, {email}, {website}, {social}):"
            ))
            footer_layout.addWidget(footer_template_label)
        
        def _update_footer_preview(self):
            """Legacy method stub - footer preview functionality moved to popup"""
            # This method was referencing widgets from the old branding tab
            # Footer preview is now handled in the popup branding settings dialog
            pass
        
        def _on_tab_changed(self, index):
            """Handle tab change event - trigger footer preview update when switching to branding tab"""
            try:
                tab_text = self.main_tabs.tabText(index)
                print(f"ðŸ” [DEBUG] Tab changed to: {tab_text} (index: {index})")
                
                # Update button visibility for current tab
                self._update_button_visibility()
                
                # If switching to config tab, force reload values
                if "Cáº¥u hÃ¬nh" in tab_text or "Config" in tab_text:
                    print("ðŸ” [DEBUG] Switched to config tab, force loading values...")
                    from PyQt5.QtCore import QTimer
                    QTimer.singleShot(50, self._force_reload_config_values)
                
                # If switching to branding tab, update footer preview
                if "Branding" in tab_text or "ThÆ°Æ¡ng hiá»‡u" in tab_text:
                    print("ðŸ” [DEBUG] Switched to branding tab, triggering footer update...")
                    # Add a small delay to ensure the tab is fully loaded
                    from PyQt5.QtCore import QTimer
                    QTimer.singleShot(100, self._update_footer_preview)
                    
            except Exception as e:
                print(f"âŒ [ERROR] _on_tab_changed failed: {e}")
        
        def _force_reload_config_values(self):
            """Force reload config values into UI fields"""
            try:
                print("ðŸ” [DEBUG] Force reloading config values...")
                import json
                config_file = os.path.join(os.getcwd(), 'notification_config.json')
                if os.path.exists(config_file):
                    with open(config_file, 'r', encoding='utf-8') as f:
                        config = json.load(f)
                    
                    telegram = config.get('telegram', {})
                    bot_token = telegram.get('bot_token', '')
                    chat_id = telegram.get('chat_id', '')
                    
                    if bot_token and hasattr(self, 'telegram_token'):
                        self.telegram_token.setText(bot_token)
                        print(f"âœ… [DEBUG] Force set bot_token: {bot_token[:10]}...")
                    
                    if chat_id and hasattr(self, 'telegram_chat_id'):
                        self.telegram_chat_id.setText(chat_id)
                        print(f"âœ… [DEBUG] Force set chat_id: {chat_id}")
                        
                    if telegram.get('enabled', False):
                        self.telegram_cb.setChecked(True)
                        
            except Exception as e:
                print(f"âŒ [ERROR] Force reload config failed: {e}")
        
        def _manual_update_footer_preview(self):
            """Manually triggered footer preview update (from button click)"""
            print("ðŸ” [DEBUG] Manual footer preview update requested")
            self._update_footer_status("Updating preview...")
            self._update_footer_preview()
        
        def _update_footer_status(self, message):
            """Update footer status label if it exists"""
            if hasattr(self, 'footer_status') and self.footer_status:
                self.footer_status.setText(message)
                print(f"ðŸ“‹ [STATUS] {message}")
        
        def _reset_branding_to_defaults(self):
            """Legacy method stub - branding reset functionality moved to popup"""
            # This method was referencing widgets from the old branding tab
            # Branding functionality is now handled in the popup branding settings dialog
            from PyQt5.QtWidgets import QMessageBox
            QMessageBox.information(self, I18N.t("Reset", "Äáº·t láº¡i"), 
                                  I18N.t("Branding settings reset to defaults", "ÄÃ£ Ä‘áº·t láº¡i cÃ i Ä‘áº·t thÆ°Æ¡ng hiá»‡u vá» máº·c Ä‘á»‹nh"))
        
        def _get_branded_footer(self, language='auto'):
            """Get formatted footer based on current branding settings from config file"""
            try:
                # Load branding settings from config file
                config_file = "notification_config.json"
                if os.path.exists(config_file):
                    with open(config_file, 'r', encoding='utf-8') as f:
                        config = json.load(f)
                    branding = config.get('branding', {})
                else:
                    branding = {}
                
                # Check if footer is enabled
                if not branding.get('enable_custom_footer', True):
                    return ""
                
                # Determine language
                if language == 'auto':
                    is_vietnamese = AppState.language() == 'vi'
                else:
                    is_vietnamese = language == 'vi'
                
                # Get values from config
                if is_vietnamese:
                    system_name = branding.get('system_name_vi', 'Há»‡ thá»‘ng AI VU HIEN CFDs')
                else:
                    system_name = branding.get('system_name_en', 'VU HIEN CFDs AI System')
                
                phone = branding.get('phone', '+84 39 65 60 888')
                email = branding.get('email', '')
                
                # Build footer
                footer_parts = [f"ðŸ¤– {system_name}"]
                if phone:
                    footer_parts.append(f"ðŸ“± {phone}")
                if email:
                    footer_parts.append(f"ðŸ“§ {email}")
                
                return '\n'.join(footer_parts)
                
            except Exception as e:
                print(f"âŒ [ERROR] Failed to get branded footer: {e}")
                # Fallback to default
                if language == 'auto':
                    is_vietnamese = AppState.language() == 'vi'
                else:
                    is_vietnamese = language == 'vi'
                    
                if is_vietnamese:
                    return "ðŸ¤– Há»‡ thá»‘ng AI VU HIEN CFDs\nðŸ“± +84 39 65 60 888"
                else:
                    return "ðŸ¤– VU HIEN CFDs AI System\nðŸ“± +84 39 65 60 888"
        
        # ðŸ¤– AUTO NOTIFICATION METHODS
        def _load_auto_notification_settings(self):
            """Load auto notification settings from config"""
            try:
                import json
                import os
                
                # ðŸ”§ FIX: Mark loading mode BEFORE any operations
                self._is_loading_settings = True
                
                config_path = os.path.join(os.getcwd(), 'notification_config.json')
                if os.path.exists(config_path):
                    with open(config_path, 'r', encoding='utf-8') as f:
                        config = json.load(f)
                    
                    settings = config.get('settings', {})
                    print(f"ðŸ“‚ [LOAD] Loading notification settings from config...")
                    print(f"ðŸ“‚ [LOAD] Raw settings: send_custom_message={settings.get('send_custom_message')}, include_candlestick={settings.get('include_candlestick')}, include_summary={settings.get('include_summary')}")
                    
                    # Track orders checkbox
                    if hasattr(self, 'track_orders_cb'):
                        self.track_orders_cb.blockSignals(True)
                        self.track_orders_cb.setChecked(settings.get('track_order_updates', False))
                        self.track_orders_cb.blockSignals(False)
                    
                    # SL/TP checkbox
                    if hasattr(self, 'notify_sl_tp_cb'):
                        self.notify_sl_tp_cb.blockSignals(True)
                        self.notify_sl_tp_cb.setChecked(settings.get('notify_sl_tp_changes', False))
                        self.notify_sl_tp_cb.blockSignals(False)
                    
                    # Close checkbox
                    if hasattr(self, 'notify_close_cb'):
                        self.notify_close_cb.blockSignals(True)
                        self.notify_close_cb.setChecked(settings.get('notify_order_close', False))
                        self.notify_close_cb.blockSignals(False)
                    
                    # ðŸ†• Load pip threshold settings
                    if hasattr(self, 'track_orders_pips_spin'):
                        self.track_orders_pips_spin.blockSignals(True)
                        self.track_orders_pips_spin.setValue(settings.get('track_orders_pip_threshold', 50))
                        self.track_orders_pips_spin.blockSignals(False)
                    
                    if hasattr(self, 'sltp_pips_spin'):
                        self.sltp_pips_spin.blockSignals(True)
                        self.sltp_pips_spin.setValue(settings.get('sltp_pip_threshold', 10))
                        self.sltp_pips_spin.blockSignals(False)
                    
                    # ðŸ†• Load daily summary settings
                    if hasattr(self, 'daily_summary_cb'):
                        self.daily_summary_cb.blockSignals(True)
                        daily_enabled = settings.get('daily_summary_enabled', False)
                        self.daily_summary_cb.setChecked(daily_enabled)
                        self.daily_summary_cb.blockSignals(False)
                        
                        # Enable/disable time picker based on checkbox
                        if hasattr(self, 'daily_summary_time'):
                            self.daily_summary_time.setEnabled(daily_enabled)
                    
                    if hasattr(self, 'daily_summary_time'):
                        self.daily_summary_time.blockSignals(True)
                        time_str = settings.get('daily_summary_time', '20:00')
                        self.daily_summary_time.setTime(QTime.fromString(time_str, "HH:mm"))
                        self.daily_summary_time.blockSignals(False)
                    
                    # Load format settings
                    format_type = settings.get('notification_format', 'full')
                    print(f"ðŸ“‚ [LOAD] Format type: {format_type}")
                    
                    # Set format radio buttons
                    if hasattr(self, 'format_summary_rb') and hasattr(self, 'format_full_rb'):
                        self.format_summary_rb.blockSignals(True)
                        self.format_full_rb.blockSignals(True)
                        
                        if format_type == 'full':
                            self.format_full_rb.setChecked(True)
                            self.format_summary_rb.setChecked(False)
                        else:
                            self.format_summary_rb.setChecked(True)
                            self.format_full_rb.setChecked(False)
                        
                        self.format_summary_rb.blockSignals(False)
                        self.format_full_rb.blockSignals(False)
                    
                    # ðŸ”§ FIX: Load ALL checkboxes from notification_config.json DIRECTLY
                    # Don't use whitelist for these settings - notification_config is the source of truth
                    if hasattr(self, 'include_technical_cb'):
                        self.include_technical_cb.blockSignals(True)
                        val = settings.get('include_technical', True)
                        self.include_technical_cb.setChecked(val)
                        self.include_technical_cb.blockSignals(False)
                        print(f"ðŸ“‚ [LOAD] include_technical = {val}")
                    
                    if hasattr(self, 'include_indicators_cb'):
                        self.include_indicators_cb.blockSignals(True)
                        val = settings.get('include_indicators', False)
                        self.include_indicators_cb.setChecked(val)
                        self.include_indicators_cb.blockSignals(False)
                        print(f"ðŸ“‚ [LOAD] include_indicators = {val}")
                    
                    if hasattr(self, 'include_summary_cb'):
                        self.include_summary_cb.blockSignals(True)
                        val = settings.get('include_summary', True)
                        self.include_summary_cb.setChecked(val)
                        self.include_summary_cb.blockSignals(False)
                        print(f"ðŸ“‚ [LOAD] include_summary = {val}")
                    
                    if hasattr(self, 'include_candlestick_cb'):
                        self.include_candlestick_cb.blockSignals(True)
                        val = settings.get('include_candlestick', True)
                        self.include_candlestick_cb.setChecked(val)
                        self.include_candlestick_cb.blockSignals(False)
                        print(f"ðŸ“‚ [LOAD] include_candlestick = {val}")
                    
                    if hasattr(self, 'include_price_patterns_cb'):
                        self.include_price_patterns_cb.blockSignals(True)
                        val = settings.get('include_price_patterns', False)
                        self.include_price_patterns_cb.setChecked(val)
                        self.include_price_patterns_cb.blockSignals(False)
                        print(f"ðŸ“‚ [LOAD] include_price_patterns = {val}")
                    
                    # Load custom message settings
                    send_custom_enabled = settings.get('send_custom_message', False)
                    if hasattr(self, 'send_custom_message'):
                        self.send_custom_message.blockSignals(True)
                        self.send_custom_message.setChecked(send_custom_enabled)
                        self.send_custom_message.blockSignals(False)
                        print(f"ðŸ“‚ [LOAD] send_custom_message = {send_custom_enabled}")
                    
                    if hasattr(self, 'custom_message'):
                        self.custom_message.blockSignals(True)
                        custom_content = settings.get('custom_message', '')
                        self.custom_message.setPlainText(custom_content)
                        self.custom_message.blockSignals(False)
                        
                        # Visual feedback
                        if send_custom_enabled:
                            self.custom_message.setStyleSheet("QTextEdit { border: 2px solid #4CAF50; }")
                        else:
                            self.custom_message.setStyleSheet("QTextEdit { border: 2px solid #ddd; }")
                    
                    # ðŸ”§ FIX: Update enable/disable state based on format AFTER loading values
                    # This only changes enabled state, not checked state
                    if format_type == 'full':
                        self.include_technical_cb.setEnabled(True)
                        self.include_indicators_cb.setEnabled(True)
                        self.include_summary_cb.setEnabled(True)
                        self.include_candlestick_cb.setEnabled(True)
                        self.include_price_patterns_cb.setEnabled(True)
                    else:
                        self.include_technical_cb.setEnabled(False)
                        self.include_indicators_cb.setEnabled(False)
                        self.include_summary_cb.setEnabled(False)
                        self.include_candlestick_cb.setEnabled(False)
                        self.include_price_patterns_cb.setEnabled(False)
                    
                    # Mark that config has been loaded
                    self._config_loaded = True
                    
                    # Update whitelist based on loaded checkbox states
                    if hasattr(self, '_trigger_whitelist_update'):
                        from PyQt5.QtCore import QTimer
                        QTimer.singleShot(500, self._trigger_whitelist_update)
                    
                    # ðŸ†• Update pip threshold spinbox enabled state based on checkbox states
                    if hasattr(self, '_update_pip_threshold_state'):
                        self._update_pip_threshold_state()
                    
                    # ðŸ†• AUTO-START DAILY SUMMARY SCHEDULER if enabled
                    if settings.get('daily_summary_enabled', False):
                        if hasattr(self, '_start_daily_summary_scheduler'):
                            self._start_daily_summary_scheduler()
                            print("ðŸ—“ï¸ Auto-started daily summary scheduler")
                    
                    # AUTO-START MONITORING if settings are enabled
                    try:
                        if (settings.get('track_order_updates', False) or 
                            settings.get('notify_sl_tp_changes', False) or 
                            settings.get('notify_order_close', False)):
                            
                            from unified_notification_system import get_unified_notification_system
                            notification_system = get_unified_notification_system()
                            
                            if not notification_system.monitoring_enabled:
                                notification_system.start_monitoring()
                                print("ðŸš€ Auto-started unified monitoring system")
                    except Exception as monitor_e:
                        print(f"âš ï¸ Could not auto-start monitoring: {monitor_e}")
                        
                    print("âœ… Auto notification settings loaded successfully")
                else:
                    print("âš ï¸ notification_config.json not found - using defaults")
                    # Set defaults when no config exists
                    if hasattr(self, 'format_full_rb'):
                        self.format_full_rb.setChecked(True)
                    self._config_loaded = True
                    
            except Exception as e:
                print(f"âŒ Error loading auto notification settings: {e}")
                import traceback
                traceback.print_exc()
            finally:
                # ðŸ”§ FIX: Always clear loading flag
                self._is_loading_settings = False
        
        def _on_format_changed(self):
            """Enable/disable report checkboxes based on format selection"""
            try:
                # Debug current state
                summary_checked = self.format_summary_rb.isChecked() if hasattr(self, 'format_summary_rb') else False
                full_checked = self.format_full_rb.isChecked() if hasattr(self, 'format_full_rb') else False
                print(f"ðŸ” [FORMAT_CHANGE_DEBUG] _on_format_changed called - Summary: {summary_checked}, Full: {full_checked}")
                
                # ðŸ”§ FIX: Check if we're in loading mode - don't modify checkboxes during load
                is_loading = getattr(self, '_is_loading_settings', False)
                
                # If "Chá»‰ Signal" is selected, disable all report checkboxes
                if hasattr(self, 'format_summary_rb') and self.format_summary_rb.isChecked():
                    print("ðŸ” [FORMAT_CHANGE_DEBUG] Summary selected - disabling advanced options")
                    # Disable all report checkboxes
                    self.include_technical_cb.setEnabled(False)
                    self.include_indicators_cb.setEnabled(False)  
                    self.include_summary_cb.setEnabled(False)
                    self.include_candlestick_cb.setEnabled(False)
                    self.include_price_patterns_cb.setEnabled(False)
                    
                    # ðŸ”§ FIX: Only uncheck when user changes format, not during load
                    if not is_loading:
                        print("ðŸ” [FORMAT_CHANGE_DEBUG] User changed format - unchecking options")
                        self.include_technical_cb.setChecked(False)
                        self.include_indicators_cb.setChecked(False)
                        self.include_summary_cb.setChecked(False)
                        self.include_candlestick_cb.setChecked(False)
                        self.include_price_patterns_cb.setChecked(False)
                    else:
                        print("ðŸ” [FORMAT_CHANGE_DEBUG] Loading mode - preserving checkbox states")
                    
                # If "Signal + PhÃ¢n tÃ­ch" is selected, enable all report checkboxes
                elif hasattr(self, 'format_full_rb') and self.format_full_rb.isChecked():
                    print("ðŸ” [FORMAT_CHANGE_DEBUG] Full selected - enabling advanced options")
                    # Enable all report checkboxes
                    self.include_technical_cb.setEnabled(True)
                    self.include_indicators_cb.setEnabled(True)
                    self.include_summary_cb.setEnabled(True)
                    self.include_candlestick_cb.setEnabled(True)
                    self.include_price_patterns_cb.setEnabled(True)
                    
                    # Don't force check - let user control their selection
                    # Don't change checked state at all - just enable the checkboxes
                    
            except Exception as e:
                print(f"âŒ Error in format change handler: {e}")
        
        def _debug_test_save(self):
            """Debug method to test save functionality"""
            try:
                print("ðŸ§ª [DEBUG_SAVE] Testing save functionality...")
                
                # Show current UI state
                summary_checked = self.format_summary_rb.isChecked() if hasattr(self, 'format_summary_rb') else False
                full_checked = self.format_full_rb.isChecked() if hasattr(self, 'format_full_rb') else False
                
                print(f"ðŸ” [DEBUG_SAVE] Current UI state:")
                print(f"  Summary button: {summary_checked}")
                print(f"  Full button: {full_checked}")
                
                # Force save current settings
                self._save_auto_notification_settings()
                
                # Read back and verify
                import json
                import os
                config_path = os.path.join(os.getcwd(), 'notification_config.json')
                if os.path.exists(config_path):
                    with open(config_path, 'r', encoding='utf-8') as f:
                        config = json.load(f)
                    
                    saved_format = config.get('settings', {}).get('notification_format', 'NOT_FOUND')
                    print(f"âœ… [DEBUG_SAVE] Saved format: {saved_format}")
                    
                    # Show popup confirmation
                    from PyQt5.QtWidgets import QMessageBox
                    msg = QMessageBox()
                    msg.setWindowTitle("Test Save Result")
                    msg.setText(f"UI State: Summary={summary_checked}, Full={full_checked}\nSaved format: {saved_format}")
                    msg.exec_()
                    
            except Exception as e:
                print(f"âŒ [DEBUG_SAVE] Error: {e}")
        
        def _trigger_whitelist_update(self):
            """ðŸŽ¯ Update whitelist directly when pattern checkboxes change"""
            try:
                print(f"\n{'='*60}")
                print(f"ðŸ”¥ [WHITELIST_UPDATE] Function called!")
                print(f"{'='*60}")
                
                # ðŸ”¥ ALWAYS handle whitelist update directly from AnalysisTab
                # Don't delegate to IndicatorTab because it can't read Analysis checkboxes!
                
                # ðŸ”¥ READ CURRENT INDICATOR WHITELIST (don't create default list, preserve user's indicator choices!)
                wl = []
                try:
                    import os, json
                    wl_path = os.path.join(os.getcwd(), 'analysis_results', 'indicator_whitelist.json')
                    if os.path.exists(wl_path):
                        with open(wl_path, 'r', encoding='utf-8') as f:
                            current_wl = json.load(f)
                        # Keep all indicator tokens, remove pattern tokens (we'll re-add based on checkboxes)
                        wl = [t for t in current_wl if t not in ('candlestick', 'price_patterns', 'patterns')]
                        print(f"ðŸ“– Read existing indicator tokens from whitelist: {wl}")
                    else:
                        # Build basic whitelist with common indicators ONLY if file doesn't exist
                        wl = [
                            "atr", "bollinger", "donchian", "ema10", "ema100", "ema20", 
                            "ema200", "ema50", "fibonacci", "ichimoku", "stochastic"
                        ]
                        print(f"ðŸ“ Created default indicator list (file didn't exist)")
                except Exception as e:
                    print(f"âš ï¸ Error reading existing whitelist, using defaults: {e}")
                
                # Add pattern tokens based on checkbox state
                candlestick_enabled = hasattr(self, 'include_candlestick_cb') and self.include_candlestick_cb.isChecked()
                price_patterns_enabled = hasattr(self, 'include_price_patterns_cb') and self.include_price_patterns_cb.isChecked()
                
                print(f"ðŸ” [WHITELIST_UPDATE] Checkbox states:")
                print(f"  â€¢ Candlestick: {candlestick_enabled}")
                print(f"  â€¢ Price Patterns: {price_patterns_enabled}")
                
                if candlestick_enabled:
                    wl.append('candlestick')
                    print(f"  âœ… Added 'candlestick' token")
                else:
                    print(f"  âš ï¸ Skipped 'candlestick' token (disabled)")
                
                if price_patterns_enabled:
                    wl.append('price_patterns')
                    print(f"  âœ… Added 'price_patterns' token")
                else:
                    print(f"  âš ï¸ Skipped 'price_patterns' token (disabled)")
                
                # Save to file
                import os, json
                out_dir = os.path.join(os.getcwd(), "analysis_results")
                os.makedirs(out_dir, exist_ok=True)
                out_fp = os.path.join(out_dir, "indicator_whitelist.json")
                with open(out_fp, "w", encoding="utf-8") as f:
                    json.dump(wl, f, ensure_ascii=False, indent=2)
                
                print(f"âœ… [WHITELIST_UPDATE] Saved whitelist to {out_fp}")
                print(f"ðŸ“„ Final whitelist: {wl}")
                
                # Show success message in GUI
                if hasattr(self, 'log_output') and self.log_output:
                    self.log_output.append(I18N.t("âœ… Updated whitelist: {count} indicators", "âœ… ÄÃ£ cáº­p nháº­t whitelist: {count} chá»‰ bÃ¡o", count=len(wl)))
                    if candlestick_enabled or price_patterns_enabled:
                        enabled = []
                        if candlestick_enabled:
                            enabled.append(I18N.t("Candlestick patterns", "MÃ´ hÃ¬nh náº¿n"))
                        if price_patterns_enabled:
                            enabled.append(I18N.t("Price patterns", "MÃ´ hÃ¬nh giÃ¡"))
                        self.log_output.append(f"   ðŸ“Š Pattern: {', '.join(enabled)}")
                    else:
                        self.log_output.append(I18N.t("   âš ï¸ Both pattern tabs are OFF", "   âš ï¸ Cáº£ 2 tab pattern Ä‘Ã£ Táº®T"))
                
            except Exception as e:
                print(f"âŒ Failed to update whitelist: {e}")
                import traceback
                traceback.print_exc()
        
        def _get_analysis_reports(self, symbols: List[str] = None) -> List[str]:
            """Äá»c cÃ¡c bÃ¡o cÃ¡o phÃ¢n tÃ­ch tá»« analysis_results theo lá»±a chá»n user"""
            try:
                import os
                import glob
                from datetime import datetime
                
                reports = []
                analysis_dir = os.path.join(os.getcwd(), 'analysis_results')
                
                if not os.path.exists(analysis_dir):
                    return reports
                
                # Determine language based on UI language
                lang_suffix = "vi"  # Default to Vietnamese
                try:
                    # Check if there's a language setting
                    if hasattr(self, 'current_language'):
                        lang_suffix = "vi" if self.current_language == "vi" else "en"
                except:
                    pass
                
                # Get symbols from executed orders if not provided
                if not symbols:
                    symbols = []
                    
                # If no specific symbols, get latest reports
                if not symbols:
                    pattern = os.path.join(analysis_dir, f"*_report_{lang_suffix}_*.txt")
                    report_files = glob.glob(pattern)
                    # Sort by modification time, get latest 3
                    report_files.sort(key=os.path.getmtime, reverse=True)
                    report_files = report_files[:3]
                else:
                    # Get reports for specific symbols
                    report_files = []
                    for symbol in symbols:
                        pattern = os.path.join(analysis_dir, f"{symbol}_report_{lang_suffix}_*.txt")
                        symbol_files = glob.glob(pattern)
                        if symbol_files:
                            # Get latest file for this symbol
                            symbol_files.sort(key=os.path.getmtime, reverse=True)
                            report_files.append(symbol_files[0])
                
                # Read selected report types based on user checkboxes
                for file_path in report_files:
                    try:
                        with open(file_path, 'r', encoding='utf-8') as f:
                            content = f.read().strip()
                            
                        if not content:
                            continue
                            
                        # Extract relevant sections based on user selections
                        filtered_content = self._filter_report_content(content)
                        
                        if filtered_content:
                            # Add symbol info and content
                            filename = os.path.basename(file_path)
                            symbol_name = filename.split('_')[0]
                            report_header = f"ðŸ“Š {symbol_name} Analysis"
                            reports.append(f"{report_header}\n{filtered_content}")
                            
                    except Exception as e:
                        print(f"âŒ Error reading report {file_path}: {e}")
                        continue
                
                return reports[:3]  # Limit to 3 reports max
                
            except Exception as e:
                print(f"âŒ Error getting analysis reports: {e}")
                return []
        
        def _filter_report_content(self, content: str) -> str:
            """Lá»c ná»™i dung bÃ¡o cÃ¡o theo lá»±a chá»n checkbox cá»§a user"""
            try:
                # ðŸŽ¯ NEW LOGIC: LuÃ´n kiá»ƒm tra checkboxes khi format_full_rb Ä‘Æ°á»£c chá»n
                if not hasattr(self, 'format_full_rb') or not self.format_full_rb.isChecked():
                    return ""  # Only return content for full format
                    
                # Check what user wants to include
                include_technical = hasattr(self, 'include_technical_cb') and self.include_technical_cb.isChecked()
                include_indicators = hasattr(self, 'include_indicators_cb') and self.include_indicators_cb.isChecked() 
                include_summary = hasattr(self, 'include_summary_cb') and self.include_summary_cb.isChecked()
                include_candlestick = hasattr(self, 'include_candlestick_cb') and self.include_candlestick_cb.isChecked()
                include_price_patterns = hasattr(self, 'include_price_patterns_cb') and self.include_price_patterns_cb.isChecked()
                
                # ðŸŽ¯ LOG DEBUG: Show what user selected
                print(f"ðŸ” Report sections selected:")
                print(f"   Technical Analysis: {include_technical}")
                print(f"   Indicators: {include_indicators}")
                print(f"   Summary: {include_summary}")
                print(f"   Candlestick: {include_candlestick}")
                print(f"   Price Patterns: {include_price_patterns}")
                
                if not any([include_technical, include_indicators, include_summary, include_candlestick, include_price_patterns]):
                    return ""  # Nothing selected
                
                sections = []
                lines = content.split('\n')
                
                # ðŸ“Š SIGNAL INFO - Always include if any section is selected
                signal_info = []
                for i, line in enumerate(lines[:10]):
                    if any(keyword in line.lower() for keyword in ['kÃ½ hiá»‡u', 'symbol', 'tÃ­n hiá»‡u', 'signal', 'Ä‘á»™ tin cáº­y', 'confidence', 'entry', 'stoploss', 'takeprofit']):
                        signal_info.append(line)
                if signal_info:
                    sections.extend(['ðŸ“Š THÃ”NG TIN TÃN HIá»†U:', ''] + signal_info + [''])
                
                # ðŸ” TECHNICAL ANALYSIS - "PhÃ¢n tÃ­ch ká»¹ thuáº­t:" (FULL CONTENT)
                if include_technical:
                    tech_section = []
                    in_tech_section = False
                    for line in lines:
                        line_lower = line.lower().strip()
                        if 'phÃ¢n tÃ­ch ká»¹ thuáº­t:' in line_lower:
                            in_tech_section = True
                            tech_section.append('ðŸ” PHÃ‚N TÃCH Ká»¸ THUáº¬T:')
                            continue
                        elif in_tech_section:
                            if 'tÃ³m táº¯t:' in line_lower:
                                break  # End of section
                            elif line.strip():  # Add ALL non-empty lines
                                tech_section.append(line)
                            else:
                                tech_section.append('')  # Keep empty lines for formatting
                    
                    if tech_section and len(tech_section) > 1:
                        sections.extend(tech_section + [''])
                
                # ðŸ“ˆ TECHNICAL INDICATORS - "Chá»‰ bÃ¡o ká»¹ thuáº­t:" (FULL CONTENT)
                if include_indicators:
                    indicator_section = []
                    in_indicator_section = False
                    for line in lines:
                        line_lower = line.lower().strip()
                        if 'chá»‰ bÃ¡o ká»¹ thuáº­t:' in line_lower:
                            in_indicator_section = True
                            indicator_section.append('ðŸ“ˆ CHá»ˆ BÃO Ká»¸ THUáº¬T:')
                            continue
                        elif in_indicator_section:
                            if 'tÃ³m táº¯t:' in line_lower:
                                break  # End of section
                            elif line.strip():  # Add ALL content lines
                                indicator_section.append(line)
                            else:
                                indicator_section.append('')  # Keep formatting
                    
                    if indicator_section and len(indicator_section) > 1:
                        sections.extend(indicator_section + [''])
                
                # ðŸ“‹ SUMMARY - "TÃ³m táº¯t:"  
                if include_summary:
                    summary_section = []
                    in_summary_section = False
                    for line in lines:
                        line_lower = line.lower().strip()
                        if line_lower.startswith('tÃ³m táº¯t:'):
                            in_summary_section = True
                            summary_section.append('ï¿½ TÃ“M Táº®T:')
                            continue
                        elif in_summary_section:
                            if line_lower.startswith('- mÃ´ hÃ¬nh'):
                                break  # Next section started
                            elif line.strip() and line.strip().startswith('-'):  # Summary bullet points
                                summary_section.append(line)
                    
                    if summary_section and len(summary_section) > 1:
                        sections.extend(summary_section + [''])
                
                # ðŸ’¹ PRICE PATTERNS - "- MÃ´ hÃ¬nh giÃ¡:"
                if include_price_patterns:
                    price_section = []
                    in_price_section = False
                    for line in lines:
                        line_lower = line.lower().strip()
                        if '- mÃ´ hÃ¬nh giÃ¡:' in line_lower:
                            in_price_section = True
                            price_section.append('ðŸ’¹ MÃ” HÃŒNH GIÃ:')
                            continue
                        elif in_price_section:
                            if '- mÃ´ hÃ¬nh náº¿n:' in line_lower:
                                break  # Next section started
                            elif line.strip() and line.strip().startswith('â€¢'):  # Price pattern bullet points
                                price_section.append(line)
                    
                    if price_section and len(price_section) > 1:
                        sections.extend(price_section + [''])
                
                # ðŸ•¯ï¸ CANDLESTICK PATTERNS - "- MÃ´ hÃ¬nh náº¿n:"
                if include_candlestick:
                    candle_section = []
                    in_candle_section = False
                    for line in lines:
                        line_lower = line.lower().strip()
                        if '- mÃ´ hÃ¬nh náº¿n:' in line_lower:
                            in_candle_section = True
                            candle_section.append('ðŸ•¯ï¸ MÃ” HÃŒNH Náº¾N:')
                            continue
                        elif in_candle_section:
                            if line.strip() and not line.strip().startswith('â€¢'):
                                break  # End of section
                            elif line.strip().startswith('â€¢'):  # Candlestick pattern bullet points
                                candle_section.append(line)
                    
                    if candle_section and len(candle_section) > 1:
                        sections.extend(candle_section + [''])
                
                # Limit total length
                result = '\n'.join(sections)
                if len(result) > 1000:  # Limit to 1000 characters
                    result = result[:1000] + "..."
                
                return result
                
            except Exception as e:
                print(f"âŒ Error filtering report content: {e}")
                return content[:500]  # Return first 500 chars if error
        
        def _save_auto_notification_settings(self):
            """Save auto notification settings to config"""
            try:
                import json
                import os
                
                # ðŸ”§ FIX: Don't save while loading settings
                if getattr(self, '_is_loading_settings', False):
                    print("â³ [SAVE] Skipping save - currently loading settings")
                    return
                
                config_path = os.path.join(os.getcwd(), 'notification_config.json')
                
                # Load existing config
                config = {}
                if os.path.exists(config_path):
                    with open(config_path, 'r', encoding='utf-8') as f:
                        config = json.load(f)
                
                # Update settings
                if 'settings' not in config:
                    config['settings'] = {}
                
                # Basic notification settings

                # Safe checkbox access - protect against deleted widgets
                try:
                    if hasattr(self, 'track_orders_cb') and self.track_orders_cb:
                        config['settings']['track_order_updates'] = self.track_orders_cb.isChecked()
                except RuntimeError:
                    config['settings']['track_order_updates'] = False
                    
                try:
                    if hasattr(self, 'notify_sl_tp_cb') and self.notify_sl_tp_cb:
                        config['settings']['notify_sl_tp_changes'] = self.notify_sl_tp_cb.isChecked()
                except RuntimeError:
                    config['settings']['notify_sl_tp_changes'] = False
                    
                try:
                    if hasattr(self, 'notify_close_cb') and self.notify_close_cb:
                        config['settings']['notify_order_close'] = self.notify_close_cb.isChecked()
                except RuntimeError:
                    config['settings']['notify_order_close'] = False
                
                # ðŸ†• Save pip threshold settings
                try:
                    if hasattr(self, 'track_orders_pips_spin') and self.track_orders_pips_spin:
                        config['settings']['track_orders_pip_threshold'] = self.track_orders_pips_spin.value()
                except RuntimeError:
                    config['settings']['track_orders_pip_threshold'] = 50
                    
                try:
                    if hasattr(self, 'sltp_pips_spin') and self.sltp_pips_spin:
                        config['settings']['sltp_pip_threshold'] = self.sltp_pips_spin.value()
                except RuntimeError:
                    config['settings']['sltp_pip_threshold'] = 10
                
                # ðŸ†• Save daily summary settings
                try:
                    if hasattr(self, 'daily_summary_cb') and self.daily_summary_cb:
                        config['settings']['daily_summary_enabled'] = self.daily_summary_cb.isChecked()
                except RuntimeError:
                    config['settings']['daily_summary_enabled'] = False
                    
                try:
                    if hasattr(self, 'daily_summary_time') and self.daily_summary_time:
                        config['settings']['daily_summary_time'] = self.daily_summary_time.time().toString("HH:mm")
                except RuntimeError:
                    config['settings']['daily_summary_time'] = "20:00"
                
                # Update unified notification system settings
                try:
                    from unified_notification_system import get_unified_notification_system
                    notification_system = get_unified_notification_system()
                    if notification_system:
                        # Safe checkbox access with deleted object protection
                        try:
                            track_orders = self.track_orders_cb.isChecked() if hasattr(self, 'track_orders_cb') and self.track_orders_cb else False
                        except RuntimeError:
                            track_orders = False  # Widget deleted
                            
                        try:
                            notify_sl_tp = self.notify_sl_tp_cb.isChecked() if hasattr(self, 'notify_sl_tp_cb') and self.notify_sl_tp_cb else False
                        except RuntimeError:
                            notify_sl_tp = False  # Widget deleted
                            
                        try:
                            notify_close = self.notify_close_cb.isChecked() if hasattr(self, 'notify_close_cb') and self.notify_close_cb else False
                        except RuntimeError:
                            notify_close = False  # Widget deleted
                        
                        notification_system.update_tracking_settings(
                            track_orders=track_orders, 
                            sl_tp_changes=notify_sl_tp, 
                            order_close=notify_close
                        )
                        
                        # Start monitoring based on enabled options - use unified method
                        if track_orders or notify_sl_tp or notify_close:
                            # Start unified monitoring if any tracking enabled
                            if not notification_system.monitoring_enabled:
                                notification_system.start_monitoring()
                                print("ðŸš€ Started unified monitoring for tracking settings")
                            
                except Exception as e:
                    print(f"âš ï¸ Error updating notification tracking settings: {e}")
                
                # Format settings
                if hasattr(self, 'format_summary_rb') and hasattr(self, 'format_full_rb'):
                    summary_checked = self.format_summary_rb.isChecked()
                    full_checked = self.format_full_rb.isChecked()
                    print(f"ðŸ” [SAVE_DEBUG] Format buttons - Summary: {summary_checked}, Full: {full_checked}")
                    
                    if summary_checked:
                        config['settings']['notification_format'] = 'summary'
                        print(f"âš ï¸ [SAVE_DEBUG] USER CHANGED TO SUMMARY FORMAT!")
                        print(f"âœ… [SAVE_DEBUG] Set notification_format = 'summary'")
                    elif full_checked:
                        config['settings']['notification_format'] = 'full'
                        print(f"âœ… [SAVE_DEBUG] Set notification_format = 'full'")
                        print(f"ðŸŽ¯ [SAVE_DEBUG] User selected FULL format (Signal + PhÃ¢n tÃ­ch)")
                    else:
                        # Fallback: if neither checked, default to full (Signal + PhÃ¢n tÃ­ch)
                        config['settings']['notification_format'] = 'full'
                        print(f"âš ï¸ [SAVE_DEBUG] Neither button checked, defaulting to 'full'")
                else:
                    print(f"âŒ [SAVE_DEBUG] Format radio buttons not found")
                    config['settings']['notification_format'] = 'full'  # Default to full format                # Advanced options - 5 notification types
                if hasattr(self, 'include_technical_cb'):
                    config['settings']['include_technical'] = self.include_technical_cb.isChecked()
                if hasattr(self, 'include_indicators_cb'):
                    config['settings']['include_indicators'] = self.include_indicators_cb.isChecked()
                if hasattr(self, 'include_summary_cb'):
                    config['settings']['include_summary'] = self.include_summary_cb.isChecked()
                if hasattr(self, 'include_candlestick_cb'):
                    candlestick_checked = self.include_candlestick_cb.isChecked()
                    config['settings']['include_candlestick'] = candlestick_checked
                    print(f"ðŸ’¾ [SAVE] include_candlestick = {candlestick_checked}")
                if hasattr(self, 'include_price_patterns_cb'):
                    price_patterns_checked = self.include_price_patterns_cb.isChecked()
                    config['settings']['include_price_patterns'] = price_patterns_checked
                    print(f"ðŸ’¾ [SAVE] include_price_patterns = {price_patterns_checked}")
                
                # Custom message settings - ðŸ”§ FIX: Save checkbox state correctly, don't override based on text content
                send_custom_checked = False  # Default value
                if hasattr(self, 'send_custom_message'):
                    send_custom_checked = self.send_custom_message.isChecked()
                    config['settings']['send_custom_message'] = send_custom_checked
                    print(f"ðŸ’¾ [SAVE] send_custom_message checkbox = {send_custom_checked}")
                
                if hasattr(self, 'custom_message'):
                    custom_text = self.custom_message.toPlainText().strip()
                    config['settings']['custom_message'] = custom_text
                    # ðŸ”§ FIX: Don't override send_custom_message here! Let checkbox control it
                    
                    # Visual feedback: change placeholder when enabled/disabled
                    if send_custom_checked:
                        self.custom_message.setStyleSheet("QTextEdit { border: 2px solid #4CAF50; }")  # Green border when active
                    else:
                        self.custom_message.setStyleSheet("QTextEdit { border: 2px solid #ddd; }")     # Default border when not enabled
                    
                # Keep technical analysis setting for compatibility
                if hasattr(self, 'format_full_rb') and self.format_full_rb.isChecked():
                    config['settings']['include_technical_analysis'] = True
                else:
                    config['settings']['include_technical_analysis'] = False
                
                # Save config
                with open(config_path, 'w', encoding='utf-8') as f:
                    json.dump(config, f, indent=2, ensure_ascii=False)
                
                print("âœ… Auto notification settings saved")
                
            except Exception as e:
                print(f"âŒ Error saving auto notification settings: {e}")
        
        def _update_pip_threshold_state(self):
            """Enable/disable pip threshold spinboxes based on checkbox state"""
            try:
                # Track orders pip threshold - enabled when track_orders_cb is checked
                track_orders_enabled = self.track_orders_cb.isChecked() if hasattr(self, 'track_orders_cb') else False
                if hasattr(self, 'track_pips_label'):
                    self.track_pips_label.setEnabled(track_orders_enabled)
                if hasattr(self, 'track_orders_pips_spin'):
                    self.track_orders_pips_spin.setEnabled(track_orders_enabled)
                
                # SL/TP pip threshold - enabled when notify_sl_tp_cb is checked
                sltp_enabled = self.notify_sl_tp_cb.isChecked() if hasattr(self, 'notify_sl_tp_cb') else False
                if hasattr(self, 'sltp_pips_label'):
                    self.sltp_pips_label.setEnabled(sltp_enabled)
                if hasattr(self, 'sltp_pips_spin'):
                    self.sltp_pips_spin.setEnabled(sltp_enabled)
                    
            except Exception as e:
                print(f"âŒ Error updating pip threshold state: {e}")
        
        def _on_daily_summary_toggled(self, checked):
            """Handle daily summary checkbox toggle"""
            try:
                # Enable/disable time picker based on checkbox
                if hasattr(self, 'daily_summary_time'):
                    self.daily_summary_time.setEnabled(checked)
                
                # Save settings
                self._save_auto_notification_settings()
                
                # Start/stop daily summary scheduler
                if checked:
                    self._start_daily_summary_scheduler()
                    print("ðŸ—“ï¸ Daily trading summary scheduler ENABLED")
                else:
                    self._stop_daily_summary_scheduler()
                    print("ðŸ—“ï¸ Daily trading summary scheduler DISABLED")
                    
            except Exception as e:
                print(f"âŒ Error toggling daily summary: {e}")
        
        def _on_history_schedule_type_changed(self, index):
            """Handle history schedule type change (Hourly vs Daily)"""
            try:
                if index == 0:  # Hourly selected
                    print("â° Schedule type changed to HOURLY")
                    if hasattr(self, 'history_hourly_interval'):
                        self.history_hourly_interval.setVisible(True)
                    if hasattr(self, 'history_hourly_label'):
                        self.history_hourly_label.setVisible(True)
                    # Hide time label and widget when hourly is selected
                    if hasattr(self, 'daily_summary_time'):
                        self.daily_summary_time.setVisible(False)
                    # Find and hide "at:" label
                    for child in self.findChildren(QLabel):
                        if "at:" in child.text() or "lÃºc:" in child.text():
                            child.setVisible(False)
                            break
                else:  # Daily selected (index == 1)
                    print("â° Schedule type changed to DAILY")
                    if hasattr(self, 'history_hourly_interval'):
                        self.history_hourly_interval.setVisible(False)
                    if hasattr(self, 'history_hourly_label'):
                        self.history_hourly_label.setVisible(False)
                    # Show time label and widget when daily is selected
                    if hasattr(self, 'daily_summary_time'):
                        self.daily_summary_time.setVisible(True)
                    # Find and show "at:" label
                    for child in self.findChildren(QLabel):
                        if "at:" in child.text() or "lÃºc:" in child.text():
                            child.setVisible(True)
                            break
                
                # Save settings
                self._save_auto_notification_settings()
                
            except Exception as e:
                print(f"âŒ Error changing history schedule type: {e}")
        
        
        def _start_daily_summary_scheduler(self):
            """Start the daily summary scheduler timer"""
            try:
                if not hasattr(self, '_daily_summary_timer'):
                    self._daily_summary_timer = QTimer(self)
                    self._daily_summary_timer.timeout.connect(self._check_daily_summary_time)
                
                # Check every minute
                self._daily_summary_timer.start(60000)  # 60 seconds
                self._last_summary_date = None  # Track last sent date
                print("â° Daily summary scheduler started - checking every minute")
            except Exception as e:
                print(f"âŒ Error starting daily summary scheduler: {e}")
        
        def _stop_daily_summary_scheduler(self):
            """Stop the daily summary scheduler timer"""
            try:
                if hasattr(self, '_daily_summary_timer'):
                    self._daily_summary_timer.stop()
                    print("â° Daily summary scheduler stopped")
            except Exception as e:
                print(f"âŒ Error stopping daily summary scheduler: {e}")
        
        def _check_daily_summary_time(self):
            """Check if it's time to send the daily summary"""
            try:
                from datetime import datetime
                
                now = datetime.now()
                current_time = now.strftime("%H:%M")
                current_date = now.strftime("%Y-%m-%d")
                
                # Get scheduled time from widget
                if hasattr(self, 'daily_summary_time'):
                    scheduled_time = self.daily_summary_time.time().toString("HH:mm")
                else:
                    scheduled_time = "20:00"
                
                # Check if we already sent today
                if hasattr(self, '_last_summary_date') and self._last_summary_date == current_date:
                    return  # Already sent today
                
                # Check if it's time to send
                if current_time == scheduled_time:
                    print(f"â° It's {scheduled_time}! Sending daily trading summary...")
                    self._last_summary_date = current_date  # Mark as sent today
                    self._send_daily_summary_now()
                    
            except Exception as e:
                print(f"âŒ Error checking daily summary time: {e}")
        
        def _send_daily_summary_now(self):
            """Send daily trading summary based on user settings (Daily/Hourly)"""
            try:
                import os
                from datetime import datetime, timedelta
                from unified_notification_system import get_unified_notification_system
                
                print("ðŸ“Š Preparing trading summary based on schedule settings...")
                
                # Get current language
                lang = AppState.language() if hasattr(AppState, 'language') else 'en'
                
                # ðŸ”§ READ USER SETTINGS
                auto_send_enabled = self.daily_summary_cb.isChecked() if hasattr(self, 'daily_summary_cb') else False
                schedule_type = self.history_schedule_type.currentText() if hasattr(self, 'history_schedule_type') else "Daily"
                hourly_interval = self.history_hourly_interval.value() if hasattr(self, 'history_hourly_interval') else 1
                
                if not auto_send_enabled:
                    print("âš ï¸ Auto-send disabled. Enable 'â° Tá»± Ä‘á»™ng gá»­i' to schedule reports.")
                    return
                
                # ðŸ”§ DETERMINE REPORTING PERIOD BASED ON SETTINGS
                now = datetime.now()
                from_date = None
                to_date = None
                period_label = ""
                
                if "Daily" in schedule_type or "Háº±ng ngÃ y" in schedule_type:
                    # Daily: Report for today only
                    from_date = now.date()
                    to_date = now.date()
                    if lang == 'vi':
                        period_label = f"NGÃ€Y {now.strftime('%d/%m/%Y')}"
                    else:
                        period_label = f"{now.strftime('%d/%m/%Y')} (Today)"
                        
                elif "Hourly" in schedule_type or "Theo giá»" in schedule_type:
                    # Hourly: Report for last N hours
                    start_time = now - timedelta(hours=hourly_interval)
                    from_date = start_time.date()
                    to_date = now.date()
                    if lang == 'vi':
                        period_label = f"{hourly_interval} GIá»œ Vá»ªA QUA ({start_time.strftime('%H:%M')} - {now.strftime('%H:%M')})"
                    else:
                        period_label = f"LAST {hourly_interval}H ({start_time.strftime('%H:%M')} - {now.strftime('%H:%M')})"
                else:
                    # Default: Daily
                    from_date = now.date()
                    to_date = now.date()
                    if lang == 'vi':
                        period_label = f"NGÃ€Y {now.strftime('%d/%m/%Y')}"
                    else:
                        period_label = f"{now.strftime('%d/%m/%Y')} (Today)"
                
                # ðŸ”§ GENERATE REPORT FOR SPECIFIED PERIOD ONLY
                print(f"ðŸ“… Generating report for: {period_label}")
                
                try:
                    import MetaTrader5 as mt5
                    if not mt5.initialize():
                        print("âŒ Cannot connect to MT5")
                        return
                    
                    # Get closed deals for the specified period
                    from_timestamp = int(datetime.combine(from_date, datetime.min.time()).timestamp())
                    to_timestamp = int(datetime.combine(to_date, datetime.max.time()).timestamp())
                    
                    deals = mt5.history_deals_get(from_timestamp, to_timestamp)
                    if not deals:
                        deals = []
                    
                    # Filter exit deals only
                    closed_deals = [d for d in deals if d.entry == 1]
                    
                    if lang == 'vi':
                        title = f"ðŸ“Š Tá»”NG Há»¢P GIAO Dá»ŠCH {period_label}"
                    else:
                        title = f"ðŸ“Š TRADING SUMMARY - {period_label}"
                    
                    # Build report for THIS PERIOD ONLY
                    if closed_deals:
                        from collections import defaultdict
                        
                        # Calculate statistics
                        total_trades = len(closed_deals)
                        wins = [d for d in closed_deals if d.profit >= 0]
                        losses = [d for d in closed_deals if d.profit < 0]
                        win_count = len(wins)
                        loss_count = len(losses)
                        win_rate = (win_count / total_trades * 100) if total_trades > 0 else 0
                        
                        total_profit = sum(d.profit for d in closed_deals)
                        gross_profit = sum(d.profit for d in wins) if wins else 0
                        gross_loss = abs(sum(d.profit for d in losses)) if losses else 1
                        profit_factor = gross_profit / gross_loss if gross_loss > 0 else 0
                        
                        # Group by symbol
                        symbol_stats = defaultdict(lambda: {'count': 0, 'profit': 0})
                        for deal in closed_deals:
                            symbol_stats[deal.symbol]['count'] += 1
                            symbol_stats[deal.symbol]['profit'] += deal.profit
                        
                        sorted_symbols = sorted(symbol_stats.items(), key=lambda x: x[1]['profit'], reverse=True)
                        
                        # Build message
                        profit_sign = "+" if total_profit >= 0 else ""
                        message = f"{title}\n{'â•'*45}\n\n"
                        
                        if lang == 'vi':
                            message += f"  Tá»•ng giao dá»‹ch:       {total_trades:>10}\n"
                            message += f"  Tháº¯ng/Thua:           {win_count:>4} / {loss_count}\n"
                            message += f"  Tá»· lá»‡ tháº¯ng:          {win_rate:>9.1f}%\n"
                            message += f"  Tá»•ng P/L:         {profit_sign}${total_profit:>11,.2f}\n"
                            message += f"  Profit Factor:        {profit_factor:>10.2f}\n"
                            
                            if sorted_symbols:
                                message += f"\n  ðŸ“ˆ Symbols:\n"
                                for symbol, stats in sorted_symbols:
                                    ps = "+" if stats['profit'] >= 0 else ""
                                    message += f"    {symbol:<12} | {stats['count']:>2} lá»‡nh | {ps}${stats['profit']:>9,.2f}\n"
                        else:
                            message += f"  Total Trades:        {total_trades:>10}\n"
                            message += f"  Win/Loss:            {win_count:>4} / {loss_count}\n"
                            message += f"  Win Rate:            {win_rate:>9.1f}%\n"
                            message += f"  Total P/L:       {profit_sign}${total_profit:>11,.2f}\n"
                            message += f"  Profit Factor:        {profit_factor:>10.2f}\n"
                            
                            if sorted_symbols:
                                message += f"\n  ðŸ“ˆ Symbols:\n"
                                for symbol, stats in sorted_symbols:
                                    ps = "+" if stats['profit'] >= 0 else ""
                                    message += f"    {symbol:<12} | {stats['count']:>2} trd | {ps}${stats['profit']:>9,.2f}\n"
                        
                        message += f"\n{'â•'*45}\nâ° {now.strftime('%H:%M:%S %d/%m/%Y')}"
                    else:
                        if lang == 'vi':
                            message = f"{title}\n{'â•'*45}\n\n  ðŸ“­ KhÃ´ng cÃ³ giao dá»‹ch nÃ o trong khoáº£ng thá»i gian nÃ y.\n\n{'â•'*45}\nâ° {now.strftime('%H:%M:%S %d/%m/%Y')}"
                        else:
                            message = f"{title}\n{'â•'*45}\n\n  ðŸ“­ No trades in this period.\n\n{'â•'*45}\nâ° {now.strftime('%H:%M:%S %d/%m/%Y')}"
                    
                    # Send via notification system
                    notification_system = get_unified_notification_system()
                    if notification_system:
                        success = notification_system.send_notification(message)
                        if success:
                            print(f"âœ… Trading summary sent! ({total_trades} trades in {period_label})")
                            # Show success feedback in UI
                            if hasattr(self, 'send_daily_summary_btn'):
                                original_text = self.send_daily_summary_btn.text()
                                self.send_daily_summary_btn.setText("âœ… Sent!")
                                QTimer.singleShot(2000, lambda: self.send_daily_summary_btn.setText(original_text))
                        else:
                            print("âŒ Failed to send trading summary")
                    else:
                        print("âŒ Notification system not available")
                        
                except Exception as e:
                    print(f"âŒ Error generating report: {e}")
                    import traceback
                    traceback.print_exc()
                    
            except Exception as e:
                print(f"âŒ Error sending trading summary: {e}")
                import traceback
                traceback.print_exc()
        
        def _on_history_period_changed(self, index):
            """Handle history period combo box change - show/hide custom date range"""
            try:
                # Index 7 = Custom Range
                is_custom = (index == 7)
                
                if hasattr(self, 'history_from_label'):
                    self.history_from_label.setVisible(is_custom)
                if hasattr(self, 'history_from_date'):
                    self.history_from_date.setVisible(is_custom)
                if hasattr(self, 'history_to_label'):
                    self.history_to_label.setVisible(is_custom)
                if hasattr(self, 'history_to_date'):
                    self.history_to_date.setVisible(is_custom)
                    
            except Exception as e:
                print(f"âŒ Error changing history period: {e}")
        
        def _get_history_date_range(self):
            """Get date range based on selected period"""
            from datetime import datetime, timedelta
            import calendar
            
            today = datetime.now().date()
            period_index = self.history_period_combo.currentIndex() if hasattr(self, 'history_period_combo') else 0
            
            if period_index == 0:  # Today
                return today, today
            elif period_index == 1:  # Yesterday
                yesterday = today - timedelta(days=1)
                return yesterday, yesterday
            elif period_index == 2:  # Last 24 hours
                return today - timedelta(days=1), today
            elif period_index == 3:  # This Week
                start_of_week = today - timedelta(days=today.weekday())
                return start_of_week, today
            elif period_index == 4:  # Last Week
                start_of_last_week = today - timedelta(days=today.weekday() + 7)
                end_of_last_week = start_of_last_week + timedelta(days=6)
                return start_of_last_week, end_of_last_week
            elif period_index == 5:  # This Month
                start_of_month = today.replace(day=1)
                return start_of_month, today
            elif period_index == 6:  # Last Month
                first_of_this_month = today.replace(day=1)
                last_of_last_month = first_of_this_month - timedelta(days=1)
                start_of_last_month = last_of_last_month.replace(day=1)
                return start_of_last_month, last_of_last_month
            elif period_index == 7:  # Custom Range
                from_date = self.history_from_date.date().toPyDate() if hasattr(self, 'history_from_date') else today - timedelta(days=7)
                to_date = self.history_to_date.date().toPyDate() if hasattr(self, 'history_to_date') else today
                return from_date, to_date
            else:
                return today, today
        
        def _generate_history_report(self):
            """Generate trading history report based on current settings - respects user options"""
            import os
            from datetime import datetime
            from collections import defaultdict
            
            try:
                lang = AppState.language() if hasattr(AppState, 'language') else 'en'
                from_date, to_date = self._get_history_date_range()
                
                # ðŸ”§ GET USER OPTIONS (respect checkboxes!)
                include_closed = self.history_include_closed.isChecked() if hasattr(self, 'history_include_closed') else True
                include_stats = self.history_include_stats.isChecked() if hasattr(self, 'history_include_stats') else True
                include_chart = self.history_include_chart.isChecked() if hasattr(self, 'history_include_chart') else False
                selected_symbol = self.history_symbol_combo.currentText() if hasattr(self, 'history_symbol_combo') else "All Symbols"
                
                # Build report header
                if lang == 'vi':
                    title = "ðŸ“Š BÃO CÃO Lá»ŠCH Sá»¬ GIAO Dá»ŠCH"
                    period_text = f"ðŸ“… Khoáº£ng thá»i gian: {from_date.strftime('%d/%m/%Y')} - {to_date.strftime('%d/%m/%Y')}"
                    if selected_symbol not in [I18N.t("All Symbols", "Táº¥t cáº£ kÃ½ hiá»‡u"), "All Symbols", "Táº¥t cáº£ kÃ½ hiá»‡u"]:
                        period_text += f" | ðŸ“Š {selected_symbol}"
                else:
                    title = "ðŸ“Š TRADING HISTORY REPORT"
                    period_text = f"ðŸ“… Period: {from_date.strftime('%d/%m/%Y')} - {to_date.strftime('%d/%m/%Y')}"
                    if selected_symbol not in [I18N.t("All Symbols", "Táº¥t cáº£ kÃ½ hiá»‡u"), "All Symbols", "Táº¥t cáº£ kÃ½ hiá»‡u"]:
                        period_text += f" | ðŸ“Š {selected_symbol}"
                
                # ðŸ”§ SHORTER SEPARATOR LINES (35 chars instead of 50)
                report = f"{title}\n{'â•'*35}\n{period_text}\n{'â”€'*35}\n\n"
                
                # ðŸ”§ SKIP IF "Include Closed Orders" IS UNCHECKED
                if not include_closed:
                    if lang == 'vi':
                        report += "  ðŸ“­ Lá»‡nh Ä‘Ã£ Ä‘Ã³ng bá»‹ áº©n (khÃ´ng Ä‘Æ°á»£c chá»n).\n"
                    else:
                        report += "  ðŸ“­ Closed orders hidden (not selected).\n"
                    report += "\n" + "â•"*35
                    report += f"\nâ° {datetime.now().strftime('%H:%M:%S %d/%m/%Y')}"
                    return report
                
                # Try to get trading data from MT5
                import MetaTrader5 as mt5
                if not mt5.initialize():
                    if lang == 'vi':
                        report += "âŒ KhÃ´ng thá»ƒ káº¿t ná»‘i MT5. HÃ£y Ä‘Äƒng nháº­p tÃ i khoáº£n MT5 trÆ°á»›c.\n"
                    else:
                        report += "âŒ Cannot connect to MT5. Please login MT5 account first.\n"
                    return report
                
                # Get closed deals (history)
                closed_deals = []
                from_timestamp = int(datetime.combine(from_date, datetime.min.time()).timestamp())
                to_timestamp = int(datetime.combine(to_date, datetime.max.time()).timestamp())
                
                try:
                    deals = mt5.history_deals_get(from_timestamp, to_timestamp)
                    if deals:
                        closed_deals = [d for d in deals if d.entry == 1]
                except Exception as e:
                    print(f"âš ï¸ Error fetching deals: {e}")
                    closed_deals = []
                
                # Apply symbol filter
                if selected_symbol not in [I18N.t("All Symbols", "Táº¥t cáº£ kÃ½ hiá»‡u"), "All Symbols", "Táº¥t cáº£ kÃ½ hiá»‡u"]:
                    closed_deals = [d for d in closed_deals if d.symbol.startswith(selected_symbol)]
                
                if closed_deals:
                    # ðŸ”§ ONLY INCLUDE STATISTICS IF CHECKBOX IS ENABLED
                    if include_stats:
                        # Calculate statistics
                        total_trades = len(closed_deals)
                        wins = [d for d in closed_deals if d.profit >= 0]
                        losses = [d for d in closed_deals if d.profit < 0]
                        win_count = len(wins)
                        loss_count = len(losses)
                        win_rate = (win_count / total_trades * 100) if total_trades > 0 else 0
                        
                        total_profit = sum(d.profit for d in closed_deals)
                        gross_profit = sum(d.profit for d in wins) if wins else 0
                        gross_loss = abs(sum(d.profit for d in losses)) if losses else 1
                        profit_factor = gross_profit / gross_loss if gross_loss > 0 else 0
                        
                        avg_win = gross_profit / win_count if win_count > 0 else 0
                        avg_loss = gross_loss / loss_count if loss_count > 0 else 0
                        
                        best_trade = max(closed_deals, key=lambda d: d.profit)
                        worst_trade = min(closed_deals, key=lambda d: d.profit)
                        
                        # Group by symbol
                        symbol_stats = defaultdict(lambda: {'count': 0, 'profit': 0})
                        for deal in closed_deals:
                            symbol_stats[deal.symbol]['count'] += 1
                            symbol_stats[deal.symbol]['profit'] += deal.profit
                        
                        sorted_symbols = sorted(symbol_stats.items(), key=lambda x: x[1]['profit'], reverse=True)
                        
                        profit_sign = "+" if total_profit >= 0 else ""
                        estimated_capital = 100000
                        pct_pnl = (total_profit / estimated_capital * 100)
                        pct_sign = "+" if pct_pnl >= 0 else ""
                        
                        if lang == 'vi':
                            report += f"Tá»•ng giao dá»‹ch:      {total_trades:>8}\n"
                            report += f"Tháº¯ng/Thua:          {win_count:>4} / {loss_count}\n"
                            report += f"Tá»· lá»‡ tháº¯ng:         {win_rate:>7.1f}%\n"
                            report += f"Tá»•ng P/L:        {profit_sign}${total_profit:>10,.2f}\n"
                            report += f"% P/L/Vá»‘n:           {pct_sign}{pct_pnl:>7.2f}%\n"
                            report += f"Profit Factor:       {profit_factor:>8.2f}\n"
                            report += f"TB Tháº¯ng:        ${avg_win:>10,.2f}\n"
                            report += f"TB Thua:         ${avg_loss:>10,.2f}\n"
                            report += f"Trade tá»‘t nháº¥t:  ${best_trade.profit:>10,.2f}\n"
                            report += f"Trade tá»‡ nháº¥t:   ${worst_trade.profit:>10,.2f}\n"
                            
                            if sorted_symbols:
                                report += f"\nðŸ“ˆ Symbols:\n"
                                for symbol, stats in sorted_symbols:
                                    ps = "+" if stats['profit'] >= 0 else ""
                                    report += f"  {symbol:<12} | {stats['count']:>3} lá»‡nh  | {ps}${stats['profit']:>9,.2f}\n"
                        else:
                            report += f"Total Trades:        {total_trades:>8}\n"
                            report += f"Win/Loss:            {win_count:>4} / {loss_count}\n"
                            report += f"Win Rate:            {win_rate:>7.1f}%\n"
                            report += f"Total P/L:       {profit_sign}${total_profit:>10,.2f}\n"
                            report += f"% P/L on Capital:    {pct_sign}{pct_pnl:>7.2f}%\n"
                            report += f"Profit Factor:       {profit_factor:>8.2f}\n"
                            report += f"Avg Win:         ${avg_win:>10,.2f}\n"
                            report += f"Avg Loss:        ${avg_loss:>10,.2f}\n"
                            report += f"Best Trade:      ${best_trade.profit:>10,.2f}\n"
                            report += f"Worst Trade:     ${worst_trade.profit:>10,.2f}\n"
                            
                            if sorted_symbols:
                                report += f"\nðŸ“ˆ Symbols:\n"
                                for symbol, stats in sorted_symbols:
                                    ps = "+" if stats['profit'] >= 0 else ""
                                    report += f"  {symbol:<12} | {stats['count']:>3} trades | {ps}${stats['profit']:>9,.2f}\n"
                    else:
                        # Statistics disabled - just show trade count
                        total_trades = len(closed_deals)
                        total_profit = sum(d.profit for d in closed_deals)
                        profit_sign = "+" if total_profit >= 0 else ""
                        if lang == 'vi':
                            report += f"Tá»•ng giao dá»‹ch:      {total_trades:>8}\n"
                            report += f"Tá»•ng P/L:        {profit_sign}${total_profit:>10,.2f}\n"
                        else:
                            report += f"Total Trades:        {total_trades:>8}\n"
                            report += f"Total P/L:       {profit_sign}${total_profit:>10,.2f}\n"
                    
                    # ðŸ”§ ONLY INCLUDE CHART IF CHECKBOX IS ENABLED
                    if include_chart:
                        report += "\n"
                        if lang == 'vi':
                            report += "ðŸ“Š BIá»‚U Äá»’ LÃƒI/Lá»– THEO SYMBOL:\n"
                            report += "â”€"*35 + "\n"
                        else:
                            report += "ðŸ“Š P/L CHART BY SYMBOL:\n"
                            report += "â”€"*35 + "\n"
                        
                        symbol_profits = defaultdict(list)
                        for deal in closed_deals:
                            symbol_profits[deal.symbol].append(deal.profit)
                        
                        sorted_symbol_charts = sorted(symbol_profits.items(), 
                                                     key=lambda x: sum(x[1]), 
                                                     reverse=True)
                        
                        for symbol, profits in sorted_symbol_charts:
                            symbol_total = sum(profits)
                            symbol_count = len(profits)
                            symbol_wins = len([p for p in profits if p >= 0])
                            symbol_losses = len([p for p in profits if p < 0])
                            symbol_win_rate = (symbol_wins / symbol_count * 100) if symbol_count > 0 else 0
                            
                            avg_account_value = 100000
                            profit_percent = (symbol_total / avg_account_value * 100)
                            
                            ps = "+" if symbol_total >= 0 else ""
                            win_rate_str = f"{symbol_win_rate:.0f}%"
                            pct_s = "+" if profit_percent >= 0 else ""
                            
                            if lang == 'vi':
                                report += f"{symbol:<10} {symbol_count:>2} lá»‡nh | W/L {symbol_wins}/{symbol_losses} ({win_rate_str:<4}) | {pct_s}{profit_percent:>5.2f}% | {ps}${symbol_total:>8,.0f}\n"
                            else:
                                report += f"{symbol:<10} {symbol_count:>2} trd | W/L {symbol_wins}/{symbol_losses} ({win_rate_str:<4}) | {pct_s}{profit_percent:>5.2f}% | {ps}${symbol_total:>8,.0f}\n"
                else:
                    if lang == 'vi':
                        report += "ðŸ“­ KhÃ´ng cÃ³ giao dá»‹ch nÃ o trong khoáº£ng thá»i gian nÃ y.\n"
                    else:
                        report += "ðŸ“­ No trades found in this period.\n"
                
                # Footer
                report += "\n" + "â•"*35
                report += f"\nâ° {datetime.now().strftime('%H:%M:%S %d/%m/%Y')}"
                
                return report
                
            except Exception as e:
                print(f"âŒ Error generating history report: {e}")
                import traceback
                traceback.print_exc()
                return f"âŒ Error generating report: {str(e)}"
        
        def _preview_history_report(self):
            """Preview trading history report in a popup dialog"""
            try:
                from PyQt5.QtWidgets import QDialog, QVBoxLayout, QHBoxLayout, QTextBrowser, QPushButton, QLabel
                from PyQt5.QtGui import QFont
                from PyQt5.QtCore import Qt
                
                lang = AppState.language() if hasattr(AppState, 'language') else 'en'
                
                # Create popup dialog
                preview_dialog = QDialog(self)
                preview_dialog.setWindowTitle(I18N.t("ðŸ‘ï¸ Trading History Report Preview", "ðŸ‘ï¸ Xem trÆ°á»›c BÃ¡o cÃ¡o Lá»‹ch sá»­ Giao dá»‹ch"))
                preview_dialog.setMinimumSize(600, 500)
                preview_dialog.setModal(True)
                
                layout = QVBoxLayout(preview_dialog)
                layout.setSpacing(10)
                
                # Title
                title_label = QLabel(I18N.t("ðŸ“Š Trading History Report", "ðŸ“Š BÃ¡o cÃ¡o Lá»‹ch sá»­ Giao dá»‹ch"))
                title_label.setFont(QFont("Segoe UI", 14, QFont.Bold))
                title_label.setAlignment(Qt.AlignCenter)
                title_label.setStyleSheet("color: #2196F3; margin-bottom: 10px;")
                layout.addWidget(title_label)
                
                # Report content area
                report_browser = QTextBrowser()
                report_browser.setFont(QFont("Consolas", 10))
                report_browser.setStyleSheet("""
                    QTextBrowser {
                        background-color: #1e1e1e;
                        color: #ddd;
                        border: 1px solid #444;
                        border-radius: 5px;
                        padding: 10px;
                    }
                """)
                
                # Show loading text first
                loading_text = "â³ Äang táº¡o bÃ¡o cÃ¡o..." if lang == 'vi' else "â³ Generating report..."
                report_browser.setPlainText(loading_text)
                layout.addWidget(report_browser)
                
                # Button row
                button_layout = QHBoxLayout()
                button_layout.setSpacing(10)
                
                # Copy button
                copy_btn = QPushButton(I18N.t("ðŸ“‹ Copy to Clipboard", "ðŸ“‹ Sao chÃ©p"))
                copy_btn.setFixedWidth(140)
                copy_btn.setStyleSheet("background-color: #607D8B; color: white; font-weight: bold; padding: 8px;")
                button_layout.addWidget(copy_btn)
                
                # Send button
                send_btn = QPushButton(I18N.t("ðŸ“¤ Send Report", "ðŸ“¤ Gá»­i BÃ¡o cÃ¡o"))
                send_btn.setFixedWidth(140)
                send_btn.setStyleSheet("background-color: #4CAF50; color: white; font-weight: bold; padding: 8px;")
                button_layout.addWidget(send_btn)
                
                # Close button
                close_btn = QPushButton(I18N.t("âŒ Close", "âŒ ÄÃ³ng"))
                close_btn.setFixedWidth(100)
                close_btn.setStyleSheet("background-color: #f44336; color: white; font-weight: bold; padding: 8px;")
                button_layout.addWidget(close_btn)
                
                button_layout.addStretch()
                layout.addLayout(button_layout)
                
                # Show dialog first, then generate report
                preview_dialog.show()
                QApplication.processEvents()
                
                # Generate report
                report = self._generate_history_report()
                report_browser.setPlainText(report)
                
                # Store report for copy/send functions
                preview_dialog._report_content = report
                
                # Connect buttons
                def copy_to_clipboard():
                    from PyQt5.QtWidgets import QApplication
                    clipboard = QApplication.clipboard()
                    clipboard.setText(preview_dialog._report_content)
                    copy_btn.setText("âœ… Copied!")
                    copy_btn.setStyleSheet("background-color: #388E3C; color: white; font-weight: bold; padding: 8px;")
                    QTimer.singleShot(2000, lambda: (
                        copy_btn.setText(I18N.t("ðŸ“‹ Copy to Clipboard", "ðŸ“‹ Sao chÃ©p")),
                        copy_btn.setStyleSheet("background-color: #607D8B; color: white; font-weight: bold; padding: 8px;")
                    ))
                
                def send_from_preview():
                    try:
                        from unified_notification_system import get_unified_notification_system
                        notification_system = get_unified_notification_system()
                        if notification_system:
                            success = notification_system.send_notification(preview_dialog._report_content)
                            if success:
                                send_btn.setText("âœ… Sent!")
                                send_btn.setStyleSheet("background-color: #388E3C; color: white; font-weight: bold; padding: 8px;")
                                QTimer.singleShot(2000, lambda: (
                                    send_btn.setText(I18N.t("ðŸ“¤ Send Report", "ðŸ“¤ Gá»­i BÃ¡o cÃ¡o")),
                                    send_btn.setStyleSheet("background-color: #4CAF50; color: white; font-weight: bold; padding: 8px;")
                                ))
                            else:
                                send_btn.setText("âŒ Failed")
                                QTimer.singleShot(2000, lambda: send_btn.setText(I18N.t("ðŸ“¤ Send Report", "ðŸ“¤ Gá»­i BÃ¡o cÃ¡o")))
                    except Exception as e:
                        print(f"âŒ Error sending from preview: {e}")
                
                copy_btn.clicked.connect(copy_to_clipboard)
                send_btn.clicked.connect(send_from_preview)
                close_btn.clicked.connect(preview_dialog.close)
                
                # Execute dialog
                preview_dialog.exec_()
                    
                print("ðŸ‘ï¸ History report preview dialog shown")
                
            except Exception as e:
                print(f"âŒ Error previewing history report: {e}")
                import traceback
                traceback.print_exc()
        
        def _send_history_report_now(self):
            """Send trading history report immediately (replaces old _send_daily_summary_now for manual send)"""
            try:
                from unified_notification_system import get_unified_notification_system
                
                print("ðŸ“¤ Sending trading history report...")
                
                # Generate report
                report = self._generate_history_report()
                
                if not report:
                    print("âŒ Failed to generate report")
                    return
                
                # Send via notification system
                notification_system = get_unified_notification_system()
                if notification_system:
                    success = notification_system.send_notification(report)
                    if success:
                        print("âœ… Trading history report sent successfully!")
                        # Show success feedback in UI
                        if hasattr(self, 'send_daily_summary_btn'):
                            original_text = self.send_daily_summary_btn.text()
                            self.send_daily_summary_btn.setText("âœ… Sent!")
                            self.send_daily_summary_btn.setStyleSheet("background-color: #388E3C; color: white; font-weight: bold;")
                            QTimer.singleShot(2000, lambda: (
                                self.send_daily_summary_btn.setText(original_text),
                                self.send_daily_summary_btn.setStyleSheet("background-color: #4CAF50; color: white; font-weight: bold;")
                            ))
                    else:
                        print("âŒ Failed to send trading history report")
                else:
                    print("âŒ Notification system not available")
                    
            except Exception as e:
                print(f"âŒ Error sending history report: {e}")
                import traceback
                traceback.print_exc()
        
        def _on_track_orders_toggled(self, checked):
            """Handle track orders checkbox - start/stop continuous order tracking monitoring"""
            try:
                if checked:
                    # Start continuous order tracking monitoring
                    try:
                        from unified_notification_system import get_unified_notification_system
                        notification_system = get_unified_notification_system()
                        
                        # Enable track order changes in config
                        notification_system.config["settings"]["track_order_updates"] = True
                        notification_system._save_config()  # Save config
                        
                        # Ensure MT5 is connected before starting monitoring
                        if hasattr(self, 'connection_manager') and self.connection_manager:
                            if not self.connection_manager.is_connected():
                                print("ðŸ“¡ Connecting to MT5 for order tracking...")
                                try:
                                    if not self.connection_manager.connect():
                                        print("âš ï¸ Could not connect to MT5, but monitoring will start when MT5 becomes available")
                                except Exception as e:
                                    print(f"âš ï¸ MT5 connection warning: {e}")
                        
                        # Start continuous monitoring thread if not running
                        if not notification_system.monitoring_enabled:
                            notification_system.start_monitoring()
                            self._show_notification(I18N.t("ðŸ“Š Order Tracking", "ï¿½ Theo dÃµi Lá»‡nh"), 
                                                  I18N.t("Continuous order tracking activated", "Theo dÃµi lá»‡nh liÃªn tá»¥c Ä‘Ã£ kÃ­ch hoáº¡t") + "\n" +
                                                  I18N.t("â€¢ Real-time order change detection", "â€¢ PhÃ¡t hiá»‡n thay Ä‘á»•i lá»‡nh thá»i gian thá»±c") + "\n" +
                                                  I18N.t("â€¢ Volume and status monitoring", "â€¢ Theo dÃµi khá»‘i lÆ°á»£ng vÃ  tráº¡ng thÃ¡i") + "\n" +
                                                  I18N.t("â€¢ Smart pip milestone tracking", "â€¢ Theo dÃµi má»‘c pip thÃ´ng minh"))
                            # Send platform notification instead of GUI popup
                            message = I18N.t("ðŸ“Š Theo dÃµi thay Ä‘á»•i lá»‡nh Ä‘Ã£ Ä‘Æ°á»£c kÃ­ch hoáº¡t", "ðŸ“Š Order tracking has been activated") + "\n" + \
                                    I18N.t("â€¢ PhÃ¡t hiá»‡n thay Ä‘á»•i lá»‡nh thá»i gian thá»±c", "â€¢ Real-time order change detection") + "\n" + \
                                    I18N.t("â€¢ Theo dÃµi khá»‘i lÆ°á»£ng vÃ  tráº¡ng thÃ¡i", "â€¢ Volume and status monitoring") + "\n" + \
                                    I18N.t("â€¢ Theo dÃµi má»‘c pip thÃ´ng minh", "â€¢ Smart pip milestone tracking")
                            
                            self._send_platform_notification(message, "track_orders_enabled")
                            print("âœ… Continuous order tracking monitoring started")
                        else:
                            # Already running, just enable the setting
                            self._show_notification(I18N.t("ðŸ“Š Order Tracking", "ðŸ“Š Theo dÃµi Lá»‡nh"), 
                                                  I18N.t("Order tracking enabled", "Theo dÃµi lá»‡nh Ä‘Ã£ báº­t") + "\n" +
                                                  I18N.t("â€¢ Monitoring thread already active", "â€¢ Luá»“ng theo dÃµi Ä‘Ã£ hoáº¡t Ä‘á»™ng") + "\n" +
                                                  I18N.t("â€¢ Order changes will be tracked", "â€¢ Thay Ä‘á»•i lá»‡nh sáº½ Ä‘Æ°á»£c theo dÃµi"))
                            print("âœ… Order tracking enabled (monitoring already active)")
                            
                    except Exception as e:
                        print(f"âš ï¸ Error starting order tracking: {e}")
                        self._show_notification(I18N.t("ðŸ“Š Order Tracking", "ðŸ“Š Theo dÃµi Lá»‡nh"), 
                                              I18N.t("Order tracking enabled (basic mode)", "Theo dÃµi lá»‡nh Ä‘Ã£ báº­t (cháº¿ Ä‘á»™ cÆ¡ báº£n)"))
                        print("âœ… Order tracking enabled (basic mode)")
                        
                else:
                    # Disable track order changes
                    try:
                        from unified_notification_system import get_unified_notification_system
                        notification_system = get_unified_notification_system()
                        notification_system.config["settings"]["track_order_updates"] = False
                        notification_system._save_config()  # Save config
                    except:
                        pass
                    
                    self._show_notification(I18N.t("ðŸ“Š Order Tracking", "ðŸ“Š Theo dÃµi Lá»‡nh"), 
                                          I18N.t("Order tracking monitoring deactivated", "Theo dÃµi lá»‡nh Ä‘Ã£ táº¯t"))
                    print("ðŸ›‘ Order tracking disabled")
                
                # Send platform notification for tracking change
                self._send_tracking_notification("track_orders", checked)
                
                self._save_auto_notification_settings()  # Save config
            except Exception as e:
                print(f"âŒ Error toggling order tracking: {e}")
                
        def _on_sl_tp_toggled(self, checked):
            """Handle SL/TP changes checkbox - start/stop continuous SL/TP monitoring"""
            try:
                if checked:
                    # Start continuous SL/TP monitoring
                    try:
                        from unified_notification_system import get_unified_notification_system
                        notification_system = get_unified_notification_system()
                        
                        # Enable SL/TP notifications in config
                        notification_system.config["settings"]["notify_sl_tp_changes"] = True
                        notification_system._save_config()  # Save config
                        
                        # Ensure MT5 is connected before starting monitoring
                        if hasattr(self, 'connection_manager') and self.connection_manager:
                            if not self.connection_manager.is_connected():
                                print("ðŸ“¡ Connecting to MT5 for SL/TP tracking...")
                                try:
                                    if not self.connection_manager.connect():
                                        print("âš ï¸ Could not connect to MT5, but monitoring will start when MT5 becomes available")
                                except Exception as e:
                                    print(f"âš ï¸ MT5 connection warning: {e}")
                        
                        # Start continuous monitoring thread if not running
                        if not notification_system.monitoring_enabled:
                            notification_system.start_monitoring()
                            self._show_notification(I18N.t("ðŸ›¡ï¸ SL/TP Monitoring", "ðŸ›¡ï¸ Theo dÃµi SL/TP"), 
                                                  I18N.t("Continuous SL/TP monitoring activated", "Theo dÃµi SL/TP liÃªn tá»¥c Ä‘Ã£ kÃ­ch hoáº¡t") + "\n" +
                                                  I18N.t("â€¢ Real-time SL/TP change detection", "â€¢ PhÃ¡t hiá»‡n thay Ä‘á»•i SL/TP thá»i gian thá»±c") + "\n" +
                                                  I18N.t("â€¢ Smart thresholds per symbol type", "â€¢ NgÆ°á»¡ng thÃ´ng minh theo loáº¡i mÃ£") + "\n" +
                                                  I18N.t("â€¢ Group notifications by symbol", "â€¢ NhÃ³m thÃ´ng bÃ¡o theo mÃ£"))
                            print("âœ… Continuous SL/TP monitoring started")
                        else:
                            # Already running, just enable the setting
                            self._show_notification(I18N.t("ðŸ›¡ï¸ SL/TP Monitoring", "ðŸ›¡ï¸ Theo dÃµi SL/TP"), 
                                                  I18N.t("SL/TP monitoring enabled", "Theo dÃµi SL/TP Ä‘Ã£ báº­t") + "\n" +
                                                  I18N.t("â€¢ Monitoring thread already active", "â€¢ Luá»“ng theo dÃµi Ä‘Ã£ hoáº¡t Ä‘á»™ng") + "\n" +
                                                  I18N.t("â€¢ SL/TP changes will be tracked", "â€¢ Thay Ä‘á»•i SL/TP sáº½ Ä‘Æ°á»£c theo dÃµi"))
                            print("âœ… SL/TP monitoring enabled (monitoring already active)")
                            
                    except Exception as e:
                        print(f"âš ï¸ Error starting SL/TP monitoring: {e}")
                        self._show_notification(I18N.t("ðŸ›¡ï¸ SL/TP Monitoring", "ðŸ›¡ï¸ Theo dÃµi SL/TP"), 
                                              I18N.t("SL/TP monitoring enabled (basic mode)", "Theo dÃµi SL/TP Ä‘Ã£ báº­t (cháº¿ Ä‘á»™ cÆ¡ báº£n)"))
                        
                else:
                    # Disable SL/TP notifications
                    try:
                        from unified_notification_system import get_unified_notification_system
                        notification_system = get_unified_notification_system()
                        notification_system.config["settings"]["notify_sl_tp_changes"] = False
                        notification_system._save_config()  # Save config
                    except:
                        pass
                    
                    self._show_notification(I18N.t("ðŸ›¡ï¸ SL/TP Monitoring", "ðŸ›¡ï¸ Theo dÃµi SL/TP"), 
                                          I18N.t("SL/TP changes monitoring deactivated", "Theo dÃµi thay Ä‘á»•i SL/TP Ä‘Ã£ táº¯t")) 
                    print("ðŸ›‘ SL/TP monitoring disabled")
                
                # Send platform notification for SL/TP tracking change
                self._send_tracking_notification("sl_tp", checked)
                
                self._save_auto_notification_settings()  # Save config
            except Exception as e:
                print(f"âŒ Error toggling SL/TP monitoring: {e}")
                
        def _on_close_toggled(self, checked):
            """Handle order close checkbox - start/stop continuous position close monitoring"""
            try:
                if checked:
                    # Start continuous close monitoring
                    try:
                        from unified_notification_system import get_unified_notification_system
                        notification_system = get_unified_notification_system()
                        
                        # Enable close notifications in config
                        notification_system.config["settings"]["notify_order_close"] = True
                        notification_system._save_config()  # Save config
                        
                        # Ensure MT5 is connected before starting monitoring
                        if hasattr(self, 'connection_manager') and self.connection_manager:
                            if not self.connection_manager.is_connected():
                                print("ðŸ“¡ Connecting to MT5 for close tracking...")
                                try:
                                    if not self.connection_manager.connect():
                                        print("âš ï¸ Could not connect to MT5, but monitoring will start when MT5 becomes available")
                                except Exception as e:
                                    print(f"âš ï¸ MT5 connection warning: {e}")
                        
                        # Start continuous monitoring thread if not running
                        if not notification_system.monitoring_enabled:
                            notification_system.start_monitoring()
                            self._show_notification(I18N.t("ðŸ Close Monitoring", "ðŸ Theo dÃµi ÄÃ³ng lá»‡nh"), 
                                                  I18N.t("Continuous position close monitoring activated", "Theo dÃµi Ä‘Ã³ng vá»‹ tháº¿ liÃªn tá»¥c Ä‘Ã£ kÃ­ch hoáº¡t") + "\n" +
                                                  I18N.t("â€¢ Real-time position close detection", "â€¢ PhÃ¡t hiá»‡n Ä‘Ã³ng vá»‹ tháº¿ thá»i gian thá»±c") + "\n" +
                                                  I18N.t("â€¢ Validation with MT5 history", "â€¢ XÃ¡c thá»±c vá»›i lá»‹ch sá»­ MT5") + "\n" +
                                                  I18N.t("â€¢ Group notifications by symbol", "â€¢ NhÃ³m thÃ´ng bÃ¡o theo mÃ£"))
                            print("âœ… Continuous close monitoring started")
                        else:
                            # Already running, just enable the setting
                            self._show_notification(I18N.t("ðŸ Close Monitoring", "ðŸ Theo dÃµi ÄÃ³ng lá»‡nh"), 
                                                  I18N.t("Position close monitoring enabled", "Theo dÃµi Ä‘Ã³ng vá»‹ tháº¿ Ä‘Ã£ báº­t") + "\n" +
                                                  I18N.t("â€¢ Monitoring thread already active", "â€¢ Luá»“ng theo dÃµi Ä‘Ã£ hoáº¡t Ä‘á»™ng") + "\n" +
                                                  I18N.t("â€¢ Position closes will be tracked", "â€¢ ÄÃ³ng vá»‹ tháº¿ sáº½ Ä‘Æ°á»£c theo dÃµi"))
                            print("âœ… Close monitoring enabled (monitoring already active)")
                            
                    except Exception as e:
                        print(f"âš ï¸ Error starting close monitoring: {e}")
                        self._show_notification(I18N.t("ðŸ Close Monitoring", "ðŸ Theo dÃµi ÄÃ³ng lá»‡nh"), 
                                              I18N.t("Close monitoring enabled (basic mode)", "Theo dÃµi Ä‘Ã³ng lá»‡nh Ä‘Ã£ báº­t (cháº¿ Ä‘á»™ cÆ¡ báº£n)"))
                        
                else:
                    # Disable close notifications
                    try:
                        from unified_notification_system import get_unified_notification_system
                        notification_system = get_unified_notification_system()
                        notification_system.config["settings"]["notify_order_close"] = False
                        notification_system._save_config()  # Save config
                    except:
                        pass
                    
                    self._show_notification(I18N.t("ðŸ Close Monitoring", "ðŸ Theo dÃµi ÄÃ³ng lá»‡nh"), 
                                          I18N.t("Position close monitoring deactivated", "Theo dÃµi Ä‘Ã³ng vá»‹ tháº¿ Ä‘Ã£ táº¯t"))
                    print("ðŸ›‘ Close monitoring disabled")
                
                # Send platform notification for order close tracking change
                self._send_tracking_notification("order_close", checked)
                
                self._save_auto_notification_settings()  # Save config  
            except Exception as e:
                print(f"âŒ Error toggling close monitoring: {e}")
        
        def _auto_start_track_orders_monitoring(self):
            """Auto-start track orders monitoring during app startup"""
            try:
                from unified_notification_system import get_unified_notification_system
                notification_system = get_unified_notification_system()
                
                # Enable track order changes in config
                notification_system.config["settings"]["track_order_updates"] = True
                notification_system._save_config()
                
                # Start continuous monitoring thread if not running
                if not notification_system.monitoring_enabled:
                    notification_system.start_monitoring()
                    print("âœ… Auto-started track orders monitoring on app startup")
                else:
                    print("âœ… Track orders monitoring enabled (monitoring already active)")
                    
            except Exception as e:
                print(f"âš ï¸ Error auto-starting track orders monitoring: {e}")
        
        def _auto_start_sl_tp_monitoring(self):
            """Auto-start SL/TP monitoring during app startup"""
            try:
                from unified_notification_system import get_unified_notification_system
                notification_system = get_unified_notification_system()
                
                # Enable SL/TP notifications in config
                notification_system.config["settings"]["notify_sl_tp_changes"] = True
                notification_system._save_config()
                
                # Start continuous monitoring thread if not running
                if not notification_system.monitoring_enabled:
                    notification_system.start_monitoring()
                    print("âœ… Auto-started SL/TP monitoring on app startup")
                else:
                    print("âœ… SL/TP monitoring enabled (monitoring already active)")
                    
            except Exception as e:
                print(f"âš ï¸ Error auto-starting SL/TP monitoring: {e}")
                
        def _auto_start_close_monitoring(self):
            """Auto-start close monitoring during app startup"""
            try:
                from unified_notification_system import get_unified_notification_system
                notification_system = get_unified_notification_system()
                
                # Enable close notifications in config
                notification_system.config["settings"]["notify_order_close"] = True
                notification_system._save_config()
                
                # Start continuous monitoring thread if not running
                if not notification_system.monitoring_enabled:
                    notification_system.start_monitoring()
                    print("âœ… Auto-started close monitoring on app startup")
                else:
                    print("âœ… Close monitoring enabled (monitoring already active)")
                    
            except Exception as e:
                print(f"âš ï¸ Error auto-starting close monitoring: {e}")
        
        def _check_service_status(self):
            """Check order tracking service status"""
            try:
                daemon = OrderTrackingDaemon()
                
                if ORDER_DAEMON_AVAILABLE and daemon.status():
                    self._show_notification("âœ… Service Running", "Order tracking service is active")
                else:
                    if ORDER_DAEMON_AVAILABLE:
                        self._show_notification("âŒ Service Stopped", "Order tracking service is not running")
                    else:
                        self._show_notification("âŒ Module Not Available", "Order tracking daemon module not available")
                    
            except Exception as e:
                print(f"âŒ Error checking service status: {e}")
                self._show_notification("âŒ Error", f"Error checking status: {str(e)}")
        
        def _show_notification(self, title, message):
            """Show notification dialog"""
            try:
                from PyQt5.QtWidgets import QMessageBox
                QMessageBox.information(self, title, message)
            except:
                print(f"{title}: {message}")
        
        def _send_platform_notification(self, message, notification_type="general"):
            """Send notification through configured platforms (Telegram/Zalo/Discord)"""
            try:
                from unified_notification_system import get_unified_notification_system
                notification_system = get_unified_notification_system()
                # UnifiedNotificationSystem.send_notification only takes message parameter
                notification_system.send_notification(message)
                print(f"âœ… Platform notification sent: {notification_type}")
                return True
            except Exception as e:
                print(f"âš ï¸ Failed to send platform notification: {e}")
                return False
        
        def _send_tracking_notification(self, tracking_type, enabled):
            """Send notification for tracking button changes"""
            try:
                if tracking_type == "track_orders":
                    if enabled:
                        # Get interval from config
                        interval = 30  # default
                        try:
                            import json
                            with open(os.path.join(os.path.dirname(__file__), "notification_config.json"), 'r') as f:
                                cfg = json.load(f)
                                interval = cfg.get('settings', {}).get('update_interval_seconds', 30)
                        except:
                            pass
                        
                        message = I18N.t("ðŸ“Š Theo dÃµi tráº¡ng thÃ¡i lá»‡nh Ä‘Ã£ Ä‘Æ°á»£c kÃ­ch hoáº¡t", "ðŸ“Š Order status tracking has been activated") + "\n" + \
                                I18N.t("â€¢ ThÃ´ng bÃ¡o P/L hiá»‡n táº¡i Ä‘á»‹nh ká»³", "â€¢ Periodic current P/L notification") + "\n" + \
                                I18N.t(f"â€¢ Cáº­p nháº­t má»—i {interval} giÃ¢y", f"â€¢ Update every {interval} seconds") + "\n" + \
                                I18N.t("â€¢ NhÃ³m theo symbol vá»›i Entry/DCA tags", "â€¢ Grouped by symbol with Entry/DCA tags")
                        self._send_platform_notification(message, "track_orders_enabled")
                    else:
                        message = I18N.t("ðŸ›‘ Theo dÃµi tráº¡ng thÃ¡i lá»‡nh Ä‘Ã£ Ä‘Æ°á»£c táº¯t", "ðŸ›‘ Order status tracking has been deactivated")
                        self._send_platform_notification(message, "track_orders_disabled")
                
                elif tracking_type == "sl_tp":
                    if enabled:
                        message = I18N.t("ðŸ›¡ï¸ Theo dÃµi thay Ä‘á»•i SL/TP Ä‘Ã£ Ä‘Æ°á»£c kÃ­ch hoáº¡t", "ðŸ›¡ï¸ SL/TP change tracking has been activated") + "\n" + \
                                I18N.t("â€¢ ThÃ´ng bÃ¡o khi SL/TP thay Ä‘á»•i", "â€¢ Notify when SL/TP changes") + "\n" + \
                                I18N.t("â€¢ ÄÃ¡nh dáº¥u Entry/DCA cho má»—i lá»‡nh", "â€¢ Entry/DCA tag for each order") + "\n" + \
                                I18N.t("â€¢ NhÃ³m thÃ´ng bÃ¡o theo symbol", "â€¢ Group notifications by symbol")
                        self._send_platform_notification(message, "sl_tp_enabled")
                    else:
                        message = I18N.t("ðŸ›‘ Theo dÃµi thay Ä‘á»•i SL/TP Ä‘Ã£ Ä‘Æ°á»£c táº¯t", "ðŸ›‘ SL/TP change tracking has been deactivated")
                        self._send_platform_notification(message, "sl_tp_disabled")
                
                elif tracking_type == "order_close":
                    if enabled:
                        message = I18N.t("ðŸ Theo dÃµi Ä‘Ã³ng lá»‡nh Ä‘Ã£ Ä‘Æ°á»£c kÃ­ch hoáº¡t", "ðŸ Order close tracking has been activated") + "\n" + \
                                I18N.t("â€¢ ThÃ´ng bÃ¡o khi lá»‡nh Ä‘Ã³ng", "â€¢ Notify when orders close") + "\n" + \
                                I18N.t("â€¢ Hiá»ƒn thá»‹ lÃ£i/lá»— vÃ  pips", "â€¢ Show profit/loss and pips") + "\n" + \
                                I18N.t("â€¢ NhÃ³m thÃ´ng bÃ¡o theo symbol", "â€¢ Group notifications by symbol")
                        self._send_platform_notification(message, "order_close_enabled")
                    else:
                        message = I18N.t("ðŸ›‘ Theo dÃµi Ä‘Ã³ng lá»‡nh Ä‘Ã£ Ä‘Æ°á»£c táº¯t", "ðŸ›‘ Order close tracking has been deactivated")
                        self._send_platform_notification(message, "order_close_disabled")
                        
            except Exception as e:
                print(f"âŒ Error sending tracking notification: {e}")
        
        def _generate_custom_notification(self, notification_type):
            """Generate and send custom notification based on type"""
            import os
            import json
            
            try:
                # ÄÆ°á»ng dáº«n thÆ° má»¥c analysis_results
                analysis_path = os.path.join(os.path.dirname(__file__), "analysis_results")
                
                if not os.path.exists(analysis_path):
                    self._show_notification(I18N.t("âŒ Error", "âŒ Lá»—i"), I18N.t("analysis_results folder does not exist", "ThÆ° má»¥c analysis_results khÃ´ng tá»“n táº¡i"))
                    return
                
                # TÃ¬m file signal má»›i nháº¥t
                signal_files = [f for f in os.listdir(analysis_path) if f.endswith('_signal.json')]
                if not signal_files:
                    self._show_notification(I18N.t("âŒ Error", "âŒ Lá»—i"), I18N.t("Signal file not found", "KhÃ´ng tÃ¬m tháº¥y file tÃ­n hiá»‡u"))
                    return
                
                # Sáº¯p xáº¿p theo thá»i gian táº¡o vÃ  láº¥y file má»›i nháº¥t
                signal_files.sort(key=lambda x: os.path.getctime(os.path.join(analysis_path, x)), reverse=True)
                latest_signal = signal_files[0]
                
                # Äá»c dá»¯ liá»‡u signal
                with open(os.path.join(analysis_path, latest_signal), 'r', encoding='utf-8') as f:
                    signal_data = json.load(f)
                
                # Táº¡o ná»™i dung theo tá»«ng loáº¡i
                content = ""
                symbol = signal_data.get('symbol', 'Unknown')
                
                if notification_type == "PhÃ¢n TÃ­ch Ká»¹ Thuáº­t":
                    content = f"ðŸ” **PHÃ‚N TÃCH Ká»¸ THUáº¬T - {symbol}**\n\n"
                    technical = signal_data.get('technical_analysis', {})
                    content += f"ðŸ“ˆ Xu hÆ°á»›ng: {technical.get('trend', 'N/A')}\n"
                    content += f"ðŸ’ª Äá»™ máº¡nh: {technical.get('strength', 'N/A')}\n"
                    content += f"ðŸŽ¯ TÃ­n hiá»‡u: {technical.get('signal', 'N/A')}\n"
                    content += f"âš–ï¸ Rá»§i ro: {technical.get('risk_level', 'N/A')}\n"
                
                elif notification_type == "Chá»‰ BÃ¡o":
                    content = f"ðŸ“Š **CHá»ˆ BÃO - {symbol}**\n\n"
                    indicators = signal_data.get('indicators', {})
                    for name, value in indicators.items():
                        if isinstance(value, dict):
                            content += f"â€¢ {name}: {value.get('value', 'N/A')} - {value.get('signal', 'N/A')}\n"
                        else:
                            content += f"â€¢ {name}: {value}\n"
                
                elif notification_type == "TÃ³m Táº¯t":
                    content = f"ðŸ“‹ **TÃ“M Táº®T Tá»”NG QUAN - {symbol}**\n\n"
                    summary = signal_data.get('summary', {})
                    content += f"ðŸŽ¯ Khuyáº¿n nghá»‹: {summary.get('recommendation', 'N/A')}\n"
                    content += f"ðŸ“Š Äiá»ƒm sá»‘: {summary.get('score', 'N/A')}\n"
                    content += f"â° Thá»i gian: {summary.get('timestamp', 'N/A')}\n"
                    content += f"ðŸ’¡ Ghi chÃº: {summary.get('notes', 'N/A')}\n"
                
                elif notification_type == "MÃ´ HÃ¬nh Náº¿n":
                    content = f"ðŸ•¯ï¸ **MÃ” HÃŒNH Náº¾N - {symbol}**\n\n"
                    patterns = signal_data.get('candlestick_patterns', [])
                    if patterns:
                        for pattern in patterns[:5]:  # Hiá»ƒn thá»‹ tá»‘i Ä‘a 5 mÃ´ hÃ¬nh
                            content += f"â€¢ {pattern.get('name', 'N/A')}: {pattern.get('strength', 'N/A')}\n"
                    else:
                        content += "KhÃ´ng phÃ¡t hiá»‡n mÃ´ hÃ¬nh náº¿n Ä‘áº·c biá»‡t\n"
                
                elif notification_type == "MÃ´ HÃ¬nh GiÃ¡":
                    content = f"ðŸ’¹ **MÃ” HÃŒNH GIÃ - {symbol}**\n\n"
                    price_patterns = signal_data.get('price_patterns', {})
                    content += f"ðŸ“ˆ Support: {price_patterns.get('support', 'N/A')}\n"
                    content += f"ðŸ“‰ Resistance: {price_patterns.get('resistance', 'N/A')}\n"
                    content += f"ðŸ“Š Trend Lines: {price_patterns.get('trendlines', 'N/A')}\n"
                    content += f"ðŸ”„ Breakout: {price_patterns.get('breakout', 'N/A')}\n"
                
                if content:
                    # Gá»­i thÃ´ng bÃ¡o qua cÃ¡c ná»n táº£ng Ä‘Ã£ báº­t
                    self._send_custom_notification(content)
                    self._show_notification(I18N.t("âœ… Success", "âœ… ThÃ nh CÃ´ng"), I18N.t("Sent notification {type}", "ÄÃ£ gá»­i thÃ´ng bÃ¡o {type}", type=notification_type))
                else:
                    self._show_notification(I18N.t("âŒ Error", "âŒ Lá»—i"), I18N.t("Cannot create notification content", "KhÃ´ng thá»ƒ táº¡o ná»™i dung thÃ´ng bÃ¡o"))
                    
            except Exception as e:
                print(f"Error generating custom notification: {e}")
                self._show_notification(I18N.t("âŒ Error", "âŒ Lá»—i"), I18N.t("Notification error: {error}", "Lá»—i táº¡o thÃ´ng bÃ¡o: {error}", error=str(e)))
        
        def _send_custom_notification(self, message_content):
            """Send custom notification message to enabled platforms"""
            try:
                # Load current notification config
                config_path = os.path.join(os.path.dirname(__file__), "notification_config.json")
                if not os.path.exists(config_path):
                    self._show_notification(I18N.t("âŒ Error", "âŒ Lá»—i"), I18N.t("Notification not configured. Please open notification settings first.", "ChÆ°a cáº¥u hÃ¬nh thÃ´ng bÃ¡o. Vui lÃ²ng má»Ÿ cÃ i Ä‘áº·t thÃ´ng bÃ¡o trÆ°á»›c."))
                    return
                
                with open(config_path, 'r', encoding='utf-8') as f:
                    config = json.load(f)
                
                success_platforms = []
                failed_platforms = []
                
                # Import unified notification system
                try:
                    from unified_notification_system import get_unified_notification_system
                    notification_system = get_unified_notification_system()
                    
                    # Send to enabled platforms
                    success = notification_system.send_notification(message_content)
                    if success:
                        success_platforms.append("Telegram")
                
                    # Show results
                    if success_platforms:
                        result_msg = I18N.t("Sent successfully: {platforms}", "Gá»­i thÃ nh cÃ´ng: {platforms}", platforms=', '.join(success_platforms))
                        if failed_platforms:
                            result_msg += I18N.t("\nFailed: {platforms}", "\nTháº¥t báº¡i: {platforms}", platforms=', '.join(failed_platforms))
                        print(f"âœ… {result_msg}")
                    elif failed_platforms:
                        print(I18N.t("âŒ Send failed: {platforms}", "âŒ Gá»­i tháº¥t báº¡i: {platforms}", platforms=', '.join(failed_platforms)))
                    else:
                        print(I18N.t("âš ï¸ No platforms activated", "âš ï¸ KhÃ´ng cÃ³ ná»n táº£ng nÃ o Ä‘Æ°á»£c kÃ­ch hoáº¡t"))
                        
                except ImportError:
                    print("âŒ Unified notification system not available")
                    
            except Exception as e:
                print(f"Error sending custom notification: {e}")
                import traceback
                traceback.print_exc()
        
        def _view_service_logs(self):
            """View order tracking service logs"""
            try:
                if not ORDER_DAEMON_AVAILABLE:
                    self._show_notification("âŒ Module Not Available", "Order tracking daemon module not available")
                    return
                
                daemon = OrderTrackingDaemon()
                
                # Create log viewer dialog
                from PyQt5.QtWidgets import QDialog, QVBoxLayout, QTextBrowser, QPushButton, QHBoxLayout
                
                dialog = QDialog(self)
                dialog.setWindowTitle("ðŸ“ Order Tracking Service Logs")
                dialog.resize(800, 600)
                
                layout = QVBoxLayout(dialog)
                
                logs_browser = QTextBrowser()
                
                if daemon.logfile and hasattr(daemon.logfile, 'exists') and daemon.logfile.exists():
                    with open(daemon.logfile, 'r', encoding='utf-8') as f:
                        logs_content = f.read()
                    logs_browser.setPlainText(logs_content)
                else:
                    logs_browser.setPlainText("ðŸ“ No logs found")
                
                layout.addWidget(logs_browser)
                
                # Buttons
                button_layout = QHBoxLayout()
                refresh_btn = QPushButton("ðŸ”„ Refresh")
                close_btn = QPushButton("âŒ Close")
                
                def refresh_logs():
                    if daemon.logfile and hasattr(daemon.logfile, 'exists') and daemon.logfile.exists():
                        with open(daemon.logfile, 'r', encoding='utf-8') as f:
                            logs_content = f.read()
                        logs_browser.setPlainText(logs_content)
                        # Scroll to bottom
                        scrollbar = logs_browser.verticalScrollBar()
                        scrollbar.setValue(scrollbar.maximum())
                
                refresh_btn.clicked.connect(refresh_logs)
                close_btn.clicked.connect(dialog.close)
                
                button_layout.addWidget(refresh_btn)
                button_layout.addStretch()
                button_layout.addWidget(close_btn)
                
                layout.addLayout(button_layout)
                
                dialog.exec_()
                    
            except Exception as e:
                print(f"âŒ Error viewing service logs: {e}")
                self._show_notification("âŒ Error", f"Error viewing logs: {str(e)}")
        
        # Smart Trading Monitor tab has been removed per user request
        # All real order monitoring now handled directly by unified_notification_system
        
        # _start_smart_monitoring method removed - tab functionality disabled
        
        # _stop_smart_monitoring method removed - tab functionality disabled
        
        # _update_monitor_status method removed - tab functionality disabled
        
        # _schedule_auto_start_monitoring method removed - Smart Trading Monitor tab disabled per user request
        
        # _add_notification_log method removed - Smart Trading Monitor tab disabled
        
        def closeEvent(self, event):
            """Handle dialog close event - auto save all config"""
            try:
                print("ðŸ” [DEBUG] NotificationDialog closeEvent triggered")
                
                # Save platform configuration
                print("ðŸ’¾ [DEBUG] Auto-saving platform config on close...")
                self._save_config(show_message=False)
                
                # Save notification/reporting settings
                print("ðŸ’¾ [DEBUG] Auto-saving notification settings on close...")
                self._save_auto_notification_settings()
                
                print("âœ… [DEBUG] All configs saved successfully on close")
                event.accept()
            except Exception as e:
                print(f"âŒ [ERROR] Error in closeEvent: {e}")
                event.accept()
        
        
        def _create_action_buttons(self, layout):
            """Create bottom action buttons"""
            button_layout = QHBoxLayout()
            
            # Left side buttons
            self.save_btn = QPushButton(I18N.t("ðŸ’¾ Save Configuration", "ðŸ’¾ LÆ°u cáº¥u hÃ¬nh"))
            self.save_btn.clicked.connect(lambda: self._save_config(show_message=True))
            self.save_btn.setStyleSheet("QPushButton { background-color: #28a745; color: white; font-weight: bold; padding: 8px 16px; }")
            
            # Right side buttons - only shown on specific tabs
            self.preview_btn = QPushButton(I18N.t("ðŸ‘€ Update Preview", "ðŸ‘€ Cáº­p nháº­t xem trÆ°á»›c"))
            self.preview_btn.clicked.connect(self._manual_update_preview)
            # Initially hidden - will be shown only on Message & Send tab
            self.preview_btn.setVisible(False)
            
            self.send_btn = QPushButton(I18N.t("ðŸ“¤ Send Now", "ðŸ“¤ Gá»­i ngay"))
            self.send_btn.clicked.connect(self._send_notification)
            self.send_btn.setStyleSheet("QPushButton { background-color: #28a745; color: white; font-weight: bold; }")
            # Initially hidden - will be shown only on Message & Send tab
            self.send_btn.setVisible(False)
            
            self.cancel_btn = QPushButton(I18N.t("âŒ Cancel", "âŒ Há»§y"))
            self.cancel_btn.clicked.connect(self.close)
            
            button_layout.addWidget(self.save_btn)
            button_layout.addStretch()
            button_layout.addWidget(self.cancel_btn)
            
            # Auto notification checkbox - compact version
            try:
                from unified_notification_system import get_unified_notification_system
                
                # Auto notification toggle (small version)
                auto_notify_frame = QWidget()
                auto_notify_frame.setStyleSheet("QWidget { background-color: rgba(40, 167, 69, 0.05); border: 1px solid #28a745; border-radius: 4px; padding: 2px; }")
                auto_notify_layout = QHBoxLayout(auto_notify_frame)
                auto_notify_layout.setContentsMargins(4, 2, 4, 2)
                auto_notify_layout.setSpacing(4)
                
                # Status icon (small)
                self.notification_status_icon = QLabel("ðŸ”•")
                self.notification_status_icon.setStyleSheet("font-size: 12px;")
                
                # Auto notification checkbox (compact)
                self.auto_notification_cb = QCheckBox(I18N.t("Auto", "Tá»± Ä‘á»™ng"))
                self.auto_notification_cb.setStyleSheet("""
                    QCheckBox {
                        font-weight: bold;
                        color: #28a745;
                        font-size: 10px;
                    }
                    QCheckBox::indicator {
                        width: 12px;
                        height: 12px;
                    }
                    QCheckBox::indicator:unchecked {
                        border: 1px solid #ccc;
                        background-color: white;
                        border-radius: 2px;
                    }
                    QCheckBox::indicator:checked {
                        border: 1px solid #28a745;
                        background-color: #28a745;
                        border-radius: 2px;
                    }
                """)
                
                # Load current state
                notification_system = get_unified_notification_system()
                is_enabled = notification_system.config.get("telegram", {}).get("enabled", False)
                self.auto_notification_cb.setChecked(is_enabled)
                self.notification_status_icon.setText("ðŸ””" if is_enabled else "ðŸ”•")
                
                # Set tooltip
                self.auto_notification_cb.setToolTip(I18N.t(
                    "Auto notification - when checked, automatically sends real-time trading notifications",
                    "ThÃ´ng bÃ¡o tá»± Ä‘á»™ng - khi báº­t, tá»± Ä‘á»™ng gá»­i thÃ´ng bÃ¡o giao dá»‹ch real-time"
                ))
                
                # Connect toggle function
                def toggle_auto_notification(checked):
                    try:
                        notification_system = get_unified_notification_system()
                        
                        # Update config
                        if "telegram" not in notification_system.config:
                            notification_system.config["telegram"] = {}
                        notification_system.config["telegram"]["enabled"] = checked
                        
                        # Save config
                        import json
                        with open(notification_system.config_file, 'w', encoding='utf-8') as f:
                            json.dump(notification_system.config, f, indent=2, ensure_ascii=False)
                        
                        # Update status icon
                        self.notification_status_icon.setText("ðŸ””" if checked else "ðŸ”•")
                        
                        # Start/stop monitoring
                        if checked:
                            # Check if any notification method is properly configured
                            def check_platform_config(config, required_fields):
                                """Check if a platform has required fields configured"""
                                if not config.get("enabled", False):
                                    return False
                                return any(config.get(field, "").strip() for field in required_fields)
                            
                            # Check all supported platforms
                            platforms_configured = []
                            
                            # Telegram
                            telegram_config = notification_system.config.get("telegram", {})
                            if check_platform_config(telegram_config, ["bot_token", "chat_id"]):
                                platforms_configured.append("Telegram")
                            
                            # Zalo  
                            zalo_config = notification_system.config.get("zalo", {})
                            if check_platform_config(zalo_config, ["webhook_url", "access_token"]):
                                platforms_configured.append("Zalo")
                            
                            # Discord
                            discord_config = notification_system.config.get("discord", {})
                            if check_platform_config(discord_config, ["webhook_url", "bot_token"]):
                                platforms_configured.append("Discord")
                            
                            # Slack
                            slack_config = notification_system.config.get("slack", {})
                            if check_platform_config(slack_config, ["webhook_url", "bot_token"]):
                                platforms_configured.append("Slack")
                            
                            # Email
                            email_config = notification_system.config.get("email", {})
                            if check_platform_config(email_config, ["username", "password"]):
                                platforms_configured.append("Email")
                            
                            # Generic Webhook
                            webhook_config = notification_system.config.get("webhook", {})
                            if check_platform_config(webhook_config, ["urls"]):
                                platforms_configured.append("Webhook")
                            
                            # Microsoft Teams
                            teams_config = notification_system.config.get("teams", {})
                            if check_platform_config(teams_config, ["webhook_url"]):
                                platforms_configured.append("Teams")
                            
                            # Always allow auto notification (basic monitoring + any configured external platforms)
                            if True:  # Always enable for maximum flexibility
                                if not notification_system.monitoring_enabled:
                                    try:
                                        notification_system.start_monitoring()
                                        print("âœ… Auto notification monitoring started")
                                        # Show success feedback
                                        self.auto_notification_cb.setStyleSheet(self.auto_notification_cb.styleSheet().replace("#28a745", "#20c997"))
                                        from PyQt5.QtCore import QTimer
                                        QTimer.singleShot(1000, lambda: self.auto_notification_cb.setStyleSheet(self.auto_notification_cb.styleSheet().replace("#20c997", "#28a745")))
                                    except Exception as e:
                                        print(f"âš ï¸ Could not start monitoring: {e}")
                            else:
                                # Show status of configured platforms
                                if platforms_configured:
                                    platforms_str = ", ".join(platforms_configured)
                                    print(f"âœ… Auto notification enabled with external services: {platforms_str}")
                                    
                                    try:
                                        from PyQt5.QtWidgets import QMessageBox
                                        QMessageBox.information(self, 
                                            I18N.t("Auto Notification Enabled", "ThÃ´ng bÃ¡o Tá»± Ä‘á»™ng ÄÃ£ Báº­t"), 
                                            I18N.t(
                                                f"Auto notification enabled successfully!\n\nConfigured platforms: {platforms_str}\n\nAll notifications will be sent to configured services and internal monitoring is active.",
                                                f"ThÃ´ng bÃ¡o tá»± Ä‘á»™ng Ä‘Ã£ Ä‘Æ°á»£c báº­t thÃ nh cÃ´ng!\n\nCÃ¡c ná»n táº£ng Ä‘Ã£ cáº¥u hÃ¬nh: {platforms_str}\n\nTáº¥t cáº£ thÃ´ng bÃ¡o sáº½ Ä‘Æ°á»£c gá»­i Ä‘áº¿n cÃ¡c dá»‹ch vá»¥ Ä‘Ã£ cáº¥u hÃ¬nh vÃ  giÃ¡m sÃ¡t ná»™i bá»™ Ä‘ang hoáº¡t Ä‘á»™ng."
                                            ))
                                    except:
                                        pass
                                else:
                                    print("âš ï¸ Auto notification enabled for internal monitoring only")
                                    print("ðŸ’¡ Configure external platforms: Telegram, Discord, Slack, Email, Webhook, Teams, Zalo")
                                    
                                    try:
                                        from PyQt5.QtWidgets import QMessageBox
                                        QMessageBox.information(self, 
                                            I18N.t("Auto Notification Enabled", "ThÃ´ng bÃ¡o Tá»± Ä‘á»™ng ÄÃ£ Báº­t"), 
                                            I18N.t(
                                                "Auto notification enabled for internal monitoring.\n\nSupported external platforms:\nâ€¢ Telegram (bot + chat)\nâ€¢ Discord (webhook/bot)\nâ€¢ Slack (webhook/bot)\nâ€¢ Email (SMTP)\nâ€¢ Generic Webhook\nâ€¢ Microsoft Teams\nâ€¢ Zalo\n\nConfigure any platform in notification settings for external alerts.",
                                                "ThÃ´ng bÃ¡o tá»± Ä‘á»™ng Ä‘Ã£ Ä‘Æ°á»£c báº­t cho giÃ¡m sÃ¡t ná»™i bá»™.\n\nCÃ¡c ná»n táº£ng bÃªn ngoÃ i Ä‘Æ°á»£c há»— trá»£:\nâ€¢ Telegram (bot + chat)\nâ€¢ Discord (webhook/bot)\nâ€¢ Slack (webhook/bot)\nâ€¢ Email (SMTP)\nâ€¢ Generic Webhook\nâ€¢ Microsoft Teams\nâ€¢ Zalo\n\nCáº¥u hÃ¬nh báº¥t ká»³ ná»n táº£ng nÃ o trong cÃ i Ä‘áº·t thÃ´ng bÃ¡o Ä‘á»ƒ nháº­n cáº£nh bÃ¡o bÃªn ngoÃ i."
                                            ))
                                    except:
                                        pass
                                
                                # Start basic monitoring anyway
                                try:
                                    if not notification_system.monitoring_enabled:
                                        notification_system.start_monitoring()
                                        print("âœ… Basic auto notification monitoring started")
                                except Exception as e:
                                    print(f"âš ï¸ Could not start basic monitoring: {e}")
                        else:
                            # Stop monitoring
                            if notification_system.monitoring_enabled:
                                try:
                                    notification_system.stop_monitoring()
                                    print("ðŸ›‘ Auto notification monitoring stopped")
                                except Exception as e:
                                    print(f"âš ï¸ Could not stop monitoring: {e}")
                        
                        print(f"ðŸ”” Auto notification {'enabled' if checked else 'disabled'}")
                        
                    except Exception as e:
                        print(f"âŒ Error toggling auto notification: {e}")
                
                self.auto_notification_cb.toggled.connect(toggle_auto_notification)
                
                # Add to layout
                auto_notify_layout.addWidget(self.notification_status_icon)
                auto_notify_layout.addWidget(self.auto_notification_cb)
                
                button_layout.addWidget(auto_notify_frame)
                button_layout.addSpacing(8)
                
                print("âœ… Compact auto notification toggle added to notification dialog")
                
            except Exception as e:
                print(f"âš ï¸ Could not add auto notification toggle to dialog: {e}")
            
            # Store message/send specific buttons separately  
            button_layout.addWidget(self.preview_btn)
            button_layout.addWidget(self.send_btn)
            button_layout.addWidget(self.cancel_btn)
            
            layout.addLayout(button_layout)
            
            # Store button layout reference for dynamic management
            self.button_layout = button_layout
            
            # Update button visibility based on current tab
            self._update_button_visibility()
            
            # Connect tab change to update button visibility
            if hasattr(self.main_tabs, 'currentChanged'):
                try:
                    self.main_tabs.currentChanged.disconnect(self._update_button_visibility)
                except:
                    pass
                self.main_tabs.currentChanged.connect(self._update_button_visibility)
        
        def _update_button_visibility(self):
            """Update button visibility based on current tab"""
            try:
                current_index = self.main_tabs.currentIndex()
                current_tab_text = self.main_tabs.tabText(current_index)
                
                # Show preview and send buttons only on Message & Send tab
                is_message_tab = ("Message & Send" in current_tab_text or 
                                "Tin nháº¯n & Gá»­i" in current_tab_text or 
                                "ðŸ“¤" in current_tab_text)
                
                if not hasattr(self, 'button_layout') or not hasattr(self, 'preview_btn') or not hasattr(self, 'send_btn'):
                    return
                    
                # Try removing and re-adding buttons to layout
                if is_message_tab:
                    # Remove buttons from layout first (in case they were already added)
                    self.button_layout.removeWidget(self.preview_btn)
                    self.button_layout.removeWidget(self.send_btn)
                    
                    # Insert preview and send buttons before cancel button
                    cancel_index = self.button_layout.indexOf(self.cancel_btn)
                    if cancel_index >= 0:
                        self.button_layout.insertWidget(cancel_index, self.preview_btn)
                        self.button_layout.insertWidget(cancel_index + 1, self.send_btn)
                    
                    # Make sure they're visible
                    self.preview_btn.setVisible(True)
                    self.send_btn.setVisible(True)
                    self.preview_btn.show()
                    self.send_btn.show()
                    
                    
                else:
                    # Remove buttons from layout
                    self.button_layout.removeWidget(self.preview_btn)
                    self.button_layout.removeWidget(self.send_btn)
                    
                    # Hide them
                    self.preview_btn.setVisible(False)
                    self.send_btn.setVisible(False)
                
                print(f"ðŸ” [DEBUG] Tab: '{current_tab_text}' - Preview/Send buttons {'visible' if is_message_tab else 'hidden'}")
                
            except Exception as e:
                print(f"âŒ [ERROR] _update_button_visibility failed: {e}")
                import traceback
                print(f"âŒ [TRACEBACK] {traceback.format_exc()}")
        
        def _on_platform_selection_changed(self):
            """Handle platform selection changes - dynamically create/remove tabs"""
            # Clear all config tabs first
            while self.config_tabs.count() > 0:
                self.config_tabs.removeTab(0)
            
            # Get selected platforms
            selected_platforms = []
            platform_mapping = {
                'Telegram': ('ðŸ“Ÿ Telegram', self._create_telegram_config_tab),
                'Zalo': ('ðŸ‡»ðŸ‡³ Zalo', self._create_zalo_config_tab),
                'WhatsApp': ('ðŸ’¬ WhatsApp', self._create_whatsapp_config_tab),
                'Discord': ('ðŸŽ® Discord', self._create_discord_config_tab),
                'Signal': ('ðŸ” Signal', self._create_signal_config_tab),
                'WeChat': ('ðŸ‡¨ðŸ‡³ WeChat', self._create_wechat_config_tab),
                'LINE': ('ðŸ‡¯ðŸ‡µ LINE', self._create_line_config_tab),
                'KakaoTalk': ('ðŸ‡°ðŸ‡· KakaoTalk', self._create_kakaotalk_config_tab),
                'Facebook Messenger': ('ðŸ“˜ Facebook', self._create_facebook_config_tab),
                'Instagram DM': ('ðŸ“· Instagram', self._create_instagram_config_tab),
                'Twitter/X DM': ('ðŸ¦ Twitter/X', self._create_twitter_config_tab),
                'LinkedIn': ('ðŸ’¼ LinkedIn', self._create_linkedin_config_tab),
                'Slack': ('ðŸ’¬ Slack', self._create_slack_config_tab),
                'Microsoft Teams': ('ðŸ‘¥ Teams', self._create_teams_config_tab),
                'Skype': ('ðŸ“ž Skype', self._create_skype_config_tab),
                'Viber': ('ðŸ’œ Viber', self._create_viber_config_tab),
                'Email': ('ðŸ“§ Email', self._create_email_config_tab),
                'SMS': ('ðŸ“± SMS', self._create_sms_config_tab),
                'Custom Webhook': ('ðŸ”— Webhook', self._create_webhook_config_tab),
                'Pushbullet': ('ðŸ“‹ Pushbullet', self._create_pushbullet_config_tab)
            }
            
            # Add tabs for selected platforms
            for cb in self.all_platform_checkboxes:
                if cb.isChecked():
                    platform_name = cb.text().split(' ', 1)[1]  # Remove emoji
                    if platform_name in platform_mapping:
                        tab_title, create_func = platform_mapping[platform_name]
                        try:
                            create_func()
                        except AttributeError:
                            # If method doesn't exist, create a generic config tab
                            self._create_generic_config_tab(platform_name, tab_title)
        
        def _telegram_auto_setup(self):
            """Launch Telegram auto setup"""
            try:
                import subprocess
                result = subprocess.run(['python', 'super_simple_setup.py'], 
                                     capture_output=True, text=True, cwd=os.getcwd())
                if result.returncode == 0:
                    QMessageBox.information(self, I18N.t("Success", "ThÃ nh cÃ´ng"), 
                                          I18N.t("Auto setup completed successfully!", "Setup tá»± Ä‘á»™ng hoÃ n thÃ nh thÃ nh cÃ´ng!"))
                    self._load_current_config()
                else:
                    QMessageBox.warning(self, I18N.t("Error", "Lá»—i"), 
                                      I18N.t("Setup failed", "Setup tháº¥t báº¡i") + f":\n{result.stderr}")
            except Exception as e:
                QMessageBox.critical(self, I18N.t("Error", "Lá»—i"), I18N.t("Failed to launch setup: {error}", "KhÃ´ng thá»ƒ khá»Ÿi cháº¡y cÃ i Ä‘áº·t: {error}", error=str(e)))
        
        def _telegram_get_chat_id(self):
            """Show instructions for getting Chat ID"""
            instructions = I18N.t(
                "To get Chat ID:\n1. Add your bot to the group\n2. Send a message to the group\n3. Visit: https://api.telegram.org/botYOUR_TOKEN/getUpdates\n4. Look for 'chat':{'id': -1234567890}\n5. Copy that number (including minus sign)",
                "Äá»ƒ láº¥y Chat ID:\n1. ThÃªm bot vÃ o nhÃ³m\n2. Gá»­i tin nháº¯n trong nhÃ³m\n3. Truy cáº­p: https://api.telegram.org/botTOKEN_Cá»¦A_Báº N/getUpdates\n4. TÃ¬m 'chat':{'id': -1234567890}\n5. Sao chÃ©p sá»‘ Ä‘Ã³ (bao gá»“m dáº¥u trá»«)"
            )
            QMessageBox.information(self, I18N.t("Get Chat ID", "Láº¥y Chat ID"), instructions)
        
        def _test_telegram(self):
            """Test Telegram connection"""
            token = self.telegram_token.text().strip()
            chat_id = self.telegram_chat_id.text().strip()
            
            if not token or not chat_id:
                QMessageBox.warning(self, I18N.t("Missing Info", "Thiáº¿u thÃ´ng tin"), 
                                  I18N.t("Please enter both Bot Token and Chat ID", "Vui lÃ²ng nháº­p cáº£ Bot Token vÃ  Chat ID"))
                return
            
            # Test the connection
            try:
                import requests
                url = f"https://api.telegram.org/bot{token}/sendMessage"
                data = {
                    "chat_id": chat_id,
                    "text": I18N.t("ðŸ§ª Test message from VU HIEN CFDs Trading Bot", "ðŸ§ª Tin nháº¯n test tá»« VU HIEN CFDs Trading Bot")
                }
                
                response = requests.post(url, json=data, timeout=10)
                
                if response.status_code == 200:
                    QMessageBox.information(self, I18N.t("Success", "ThÃ nh cÃ´ng"), 
                                          I18N.t("Test message sent successfully!", "Tin nháº¯n test gá»­i thÃ nh cÃ´ng!"))
                else:
                    QMessageBox.warning(self, I18N.t("Failed", "Tháº¥t báº¡i"), 
                                      I18N.t("Test failed", "Test tháº¥t báº¡i") + f": {response.status_code}")
                    
            except Exception as e:
                QMessageBox.critical(self, I18N.t("Error", "Lá»—i"), f"Test error: {e}")
        
        def _update_preview(self):
            """Update message preview - maps 100% accurately to real data"""
            try:
                preview_text = ""
                
                # Check which message type is selected
                if self.signal_radio.isChecked():
                    # Get actual trading signal from latest analysis
                    preview_text = self._get_real_signal_preview()
                    
                elif self.custom_radio.isChecked():
                    # Get custom message from text area
                    if hasattr(self, 'custom_message'):
                        custom_text = self.custom_message.toPlainText().strip()
                        if custom_text:
                            preview_text = custom_text + "\n\n" + self._get_branded_footer()
                        else:
                            preview_text = I18N.t("Enter your custom message above...", "Nháº­p tin nháº¯n tÃ¹y chá»‰nh á»Ÿ trÃªn...")
                    else:
                        preview_text = I18N.t("Custom message area not available", "Khu vá»±c tin nháº¯n tÃ¹y chá»‰nh khÃ´ng kháº£ dá»¥ng")
                
                elif self.report_radio.isChecked():
                    # Get actual account positions report
                    preview_text = self._get_real_account_report_preview()
                else:
                    preview_text = I18N.t("Select message type above...", "Chá»n loáº¡i tin nháº¯n á»Ÿ trÃªn...")
                
                # Update preview area
                if hasattr(self, 'preview_area'):
                    self.preview_area.setPlainText(preview_text)
                else:
                    print(f"Preview updated: {preview_text[:100]}...")
                
            except Exception as e:
                error_msg = f"Preview error: {e}"
                if hasattr(self, 'preview_area'):
                    self.preview_area.setPlainText(error_msg)
                else:
                    print(error_msg)
        
        def _get_real_signal_preview(self):
            """Get preview of real trading signal from latest analysis data"""
            try:
                import json
                import os
                import glob
                from datetime import datetime
                
                # Look for latest signal files in analysis_results
                analysis_dir = os.path.join(os.getcwd(), 'analysis_results')
                if os.path.exists(analysis_dir):
                    # Find latest signal files
                    signal_files = glob.glob(os.path.join(analysis_dir, '*_signal*.json'))
                    
                    if signal_files:
                        # Sort by modification time and get latest
                        latest_signal = max(signal_files, key=os.path.getmtime)
                        
                        # Read signal data
                        with open(latest_signal, 'r', encoding='utf-8') as f:
                            signal_data = json.load(f)
                        
                        # Extract symbol from data or filename
                        symbol = signal_data.get('symbol', 'N/A')
                        final_signal = signal_data.get('final_signal', {})
                        
                        # Format signal preview with real data
                        if AppState.language() == 'vi':
                            preview_text = f"""ðŸš€ TÃN HIá»†U GIAO Dá»ŠCH Má»šI
==============================
â° Thá»i gian: {signal_data.get('timestamp', datetime.now().strftime('%Y-%m-%d %H:%M:%S'))}
ðŸ’± KÃ½ hiá»‡u: {symbol}
ðŸ“Š HÆ°á»›ng: {final_signal.get('signal', 'N/A')}
ðŸŽ¯ Äá»™ tin cáº­y: {final_signal.get('confidence', 'N/A'):.1f}%
ðŸ’° Entry: {final_signal.get('entry', 'N/A')}
ðŸ›‘ StopLoss: {final_signal.get('stoploss', 'N/A')}
ðŸŽ¯ TakeProfit: {final_signal.get('takeprofit', 'N/A')}
ï¿½ Loáº¡i lá»‡nh: {final_signal.get('order_type', 'N/A')}
ðŸ’¡ LÃ½ do: {final_signal.get('entry_reason', 'TÃ­n hiá»‡u dá»±a trÃªn phÃ¢n tÃ­ch ká»¹ thuáº­t')}

"""
                        else:
                            preview_text = f"""ðŸš€ NEW TRADING SIGNAL
==============================
â° Time: {signal_data.get('timestamp', datetime.now().strftime('%Y-%m-%d %H:%M:%S'))}
ðŸ’± Symbol: {symbol}
ðŸ“Š Direction: {final_signal.get('signal', 'N/A')}
ðŸŽ¯ Confidence: {final_signal.get('confidence', 'N/A'):.1f}%
ðŸ’° Entry: {final_signal.get('entry', 'N/A')}
ðŸ›‘ StopLoss: {final_signal.get('stoploss', 'N/A')}
ðŸŽ¯ TakeProfit: {final_signal.get('takeprofit', 'N/A')}
ï¿½ Order Type: {final_signal.get('order_type', 'N/A')}
ðŸ’¡ Reason: {final_signal.get('entry_reason', 'Signal based on technical analysis')}

"""
                        
                        preview_text += self._get_branded_footer()
                        return preview_text
                
                # Fallback: Read actual report file for signal data
                if AppState.language() == 'vi':
                    report_files = glob.glob(os.path.join(analysis_dir, '*_report_vi_*.txt'))
                else:
                    report_files = glob.glob(os.path.join(analysis_dir, '*_report_en_*.txt'))
                
                if report_files:
                    latest_report = max(report_files, key=os.path.getmtime)
                    
                    # Extract data from report file
                    with open(latest_report, 'r', encoding='utf-8') as f:
                        content = f.read()
                    
                    # Parse key information
                    lines = content.split('\n')
                    data = {}
                    for line in lines[:15]:  # First 15 lines contain key info
                        if ':' in line:
                            key, value = line.split(':', 1)
                            data[key.strip()] = value.strip()
                    
                    # Format with actual data
                    if AppState.language() == 'vi':
                        preview_text = f"""ðŸš€ TÃN HIá»†U GIAO Dá»ŠCH Má»šI
==============================
â° Thá»i gian: {data.get('Thá»i gian', 'N/A')}
ðŸ’± KÃ½ hiá»‡u: {data.get('KÃ½ hiá»‡u', 'N/A')}
ðŸ“Š TÃ­n hiá»‡u: {data.get('TÃ­n hiá»‡u', 'N/A')}
ðŸŽ¯ Äá»™ tin cáº­y: {data.get('Äá»™ tin cáº­y', 'N/A')}
ðŸ’° Entry: {data.get('Entry', 'N/A')}
ðŸ›‘ StopLoss: {data.get('Stoploss', 'N/A')}
ðŸŽ¯ TakeProfit: {data.get('Takeprofit', 'N/A')}

"""
                    else:
                        preview_text = f"""ðŸš€ NEW TRADING SIGNAL
==============================
â° Time: {data.get('Time', data.get('Thá»i gian', 'N/A'))}
ðŸ’± Symbol: {data.get('Symbol', data.get('KÃ½ hiá»‡u', 'N/A'))}
ðŸ“Š Signal: {data.get('Signal', data.get('TÃ­n hiá»‡u', 'N/A'))}
ðŸŽ¯ Confidence: {data.get('Confidence', data.get('Äá»™ tin cáº­y', 'N/A'))}
ðŸ’° Entry: {data.get('Entry', 'N/A')}
ðŸ›‘ StopLoss: {data.get('StopLoss', data.get('Stoploss', 'N/A'))}
ðŸŽ¯ TakeProfit: {data.get('TakeProfit', data.get('Takeprofit', 'N/A'))}

"""
                    
                    preview_text += self._get_branded_footer()
                    return preview_text
                
                # Final fallback - no real data available
                if AppState.language() == 'vi':
                    return "ðŸš€ TÃN HIá»†U GIAO Dá»ŠCH\n==============================\n\nâš ï¸ ChÆ°a cÃ³ dá»¯ liá»‡u tÃ­n hiá»‡u thá»±c táº¿\nVui lÃ²ng cháº¡y phÃ¢n tÃ­ch Ä‘á»ƒ táº¡o tÃ­n hiá»‡u má»›i\n\n" + self._get_branded_footer()
                else:
                    return "ðŸš€ TRADING SIGNAL\n==============================\n\nâš ï¸ No real signal data available\nPlease run analysis to generate new signals\n\n" + self._get_branded_footer()
                
            except Exception as e:
                return f"Error getting real signal preview: {e}"
        
        def _get_executed_order_preview(self):
            """Get preview of executed order message"""
            try:
                # Try to get latest executed order from reports
                import json
                import os
                from datetime import datetime
                
                # Check for execution reports
                reports_path = os.path.join(os.getcwd(), 'reports', 'execution_reports.json')
                if os.path.exists(reports_path):
                    with open(reports_path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    
                    # Handle both old and new format
                    execution_reports = data.get('execution_reports', data) if isinstance(data, dict) else data
                    
                    if execution_reports and len(execution_reports) > 0:
                        # Get latest executed report
                        latest_report = execution_reports[-1]
                        
                        # Extract info from report
                        symbol = latest_report.get('symbol', 'XAUUSD')
                        timestamp = latest_report.get('timestamp', datetime.now().isoformat())
                        
                        # Try to format timestamp
                        try:
                            if 'T' in timestamp:
                                dt = datetime.fromisoformat(timestamp.replace('T', ' ').split('.')[0])
                                formatted_time = dt.strftime('%Y-%m-%d %H:%M:%S')
                            else:
                                formatted_time = timestamp
                        except:
                            formatted_time = timestamp
                        
                        # Look for actions in the report
                        actions = latest_report.get('actions', [])
                        if actions and len(actions) > 0:
                            latest_action = actions[-1]
                            action_type = latest_action.get('action', 'BUY')
                            signal_trigger = latest_action.get('signal_trigger', action_type)
                            reason = latest_action.get('reason', '')
                            confidence = latest_action.get('confidence', 0)
                            
                            # Format action type
                            if 'SELL' in signal_trigger.upper():
                                direction = 'SELL'
                            else:
                                direction = 'BUY'
                        else:
                            direction = 'BUY'
                            reason = 'Order executed'
                            confidence = 0
                        
                        # Format like enhanced signal style
                        if AppState.language() == 'vi':
                            preview_text = f"ðŸš€ SIGNAL EXECUTED\n"
                            preview_text += f"==============================\n"
                            preview_text += f"â° Thá»i gian: {formatted_time}\n"
                            preview_text += f"ðŸ’± Cáº·p tiá»n: {symbol}\n"
                            preview_text += f"ðŸ“Š HÆ°á»›ng: {direction}\n"
                            if confidence > 0:
                                preview_text += f"ðŸŽ¯ Äá»™ tin cáº­y: {confidence}%\n"
                            if reason:
                                preview_text += f"ï¿½ LÃ½ do: {reason}\n"
                            preview_text += f"ðŸŽ« Ticket: #AUTO\n\n"
                        else:
                            preview_text = f"ðŸš€ SIGNAL EXECUTED\n"
                            preview_text += f"==============================\n"
                            preview_text += f"â° Time: {formatted_time}\n"
                            preview_text += f"ðŸ’± Symbol: {symbol}\n"
                            preview_text += f"ðŸ“Š Direction: {direction}\n"
                            if confidence > 0:
                                preview_text += f"ðŸŽ¯ Confidence: {confidence}%\n"
                            if reason:
                                preview_text += f"ï¿½ Reason: {reason}\n"
                            preview_text += f"ðŸŽ« Ticket: #AUTO\n\n"
                        
                        preview_text += self._get_branded_footer()
                        return preview_text
                
                # Fallback to example data
                if AppState.language() == 'vi':
                    preview_text = "ðŸš€ SIGNAL EXECUTED\n==============================\nâ° Thá»i gian: 2025-10-14 02:30:45\nðŸ’± Cáº·p tiá»n: XAUUSD\nðŸ“Š HÆ°á»›ng: BUY\nðŸŽ¯ Äá»™ tin cáº­y: 75%\nï¿½ LÃ½ do: Entry signal confirmed\nðŸŽ« Ticket: #12345678\n\n" + self._get_branded_footer()
                else:
                    preview_text = "ðŸš€ SIGNAL EXECUTED\n==============================\nâ° Time: 2025-10-14 02:30:45\nðŸ’± Symbol: XAUUSD\nðŸ“Š Direction: BUY\nðŸŽ¯ Confidence: 75%\nï¿½ Reason: Entry signal confirmed\nðŸŽ« Ticket: #12345678\n\n" + self._get_branded_footer()
                    
                return preview_text
                
            except Exception as e:
                return f"Error getting executed order preview: {e}"
        
        def _get_analysis_report_preview(self):
            """Get preview of analysis report message"""
            try:
                # Try to get latest analysis report
                import os
                import glob
                
                # Look for latest analysis report files
                analysis_dir = os.path.join(os.getcwd(), 'analysis_results')
                if os.path.exists(analysis_dir):
                    # Find latest report files
                    if AppState.language() == 'vi':
                        report_files = glob.glob(os.path.join(analysis_dir, '*_report_vi_*.txt'))
                    else:
                        report_files = glob.glob(os.path.join(analysis_dir, '*_report_en_*.txt'))
                    
                    if report_files:
                        # Sort by modification time and get latest
                        latest_report = max(report_files, key=os.path.getmtime)
                        
                        # Read first few lines of the report
                        with open(latest_report, 'r', encoding='utf-8') as f:
                            lines = f.readlines()
                        
                        # Extract key information
                        preview_lines = []
                        for line in lines[:10]:  # First 10 lines
                            line = line.strip()
                            if line and not line.startswith('Time:'):
                                preview_lines.append(line)
                        
                        preview_text = '\n'.join(preview_lines[:5])  # Top 5 meaningful lines
                        if len(preview_text) > 300:
                            preview_text = preview_text[:300] + "..."
                            
                        preview_text += "\n\n" + self._get_branded_footer()
                        return preview_text
                
                # Fallback to example data
                if AppState.language() == 'vi':
                    preview_text = "ðŸ“ˆ BÃO CÃO PHÃ‚N TÃCH\n\nTá»•ng quan thá»‹ trÆ°á»ng: Xu hÆ°á»›ng tÄƒng\nMá»©c quan trá»ng: Há»— trá»£ 2640, KhÃ¡ng cá»± 2680\nKhuyáº¿n nghá»‹: TÃ¬m cÆ¡ há»™i mua vÃ o\nÄá»™ tin cáº­y: 75%\n\n" + self._get_branded_footer()
                else:
                    preview_text = "ðŸ“ˆ ANALYSIS REPORT\n\nMarket Overview: Bullish trend detected\nKey Levels: Support 2640, Resistance 2680\nRecommendation: Look for buying opportunities\nConfidence: 75%\n\n" + self._get_branded_footer()
                    
                return preview_text
                
            except Exception as e:
                return f"Error getting analysis report preview: {e}"
        
        def _get_real_account_report_preview(self):
            """Get preview of real account positions report"""
            try:
                import os
                
                # Look for latest account positions report
                analysis_dir = os.path.join(os.getcwd(), 'analysis_results')
                
                if AppState.language() == 'vi':
                    report_file = os.path.join(analysis_dir, 'account_positions_actions_vi.txt')
                else:
                    report_file = os.path.join(analysis_dir, 'account_positions_actions_en.txt')
                
                if os.path.exists(report_file):
                    # Read the actual report
                    with open(report_file, 'r', encoding='utf-8') as f:
                        content = f.read()
                    
                    # Extract key sections
                    lines = content.split('\n')
                    
                    # Find key sections
                    summary_lines = []
                    positions_lines = []
                    capturing_summary = False
                    capturing_positions = False
                    
                    for line in lines:
                        if '--- Tá»”NG QUAN Rá»¦I RO ---' in line or '--- RISK OVERVIEW ---' in line:
                            capturing_summary = True
                            capturing_positions = False
                            continue
                        elif '--- HÃ€NH Äá»˜NG Æ¯U TIÃŠN ---' in line or '--- PRIORITY ACTIONS ---' in line:
                            capturing_summary = False
                            capturing_positions = True
                            continue
                        elif capturing_summary and line.strip():
                            summary_lines.append(line)
                        elif capturing_positions and line.strip() and len(positions_lines) < 5:  # Top 5 positions
                            if line.startswith('â€¢'):
                                positions_lines.append(line)
                    
                    # Format preview
                    if AppState.language() == 'vi':
                        preview_text = "ðŸ“Š BÃO CÃO QUáº¢N LÃ Vá»Š THáº¾\n"
                        preview_text += "==============================\n\n"
                        
                        # Risk overview
                        if summary_lines:
                            preview_text += "ðŸŽ¯ Tá»”NG QUAN Rá»¦I RO:\n"
                            for line in summary_lines[:6]:  # Top 6 summary items
                                preview_text += f"â€¢ {line.strip()}\n"
                            preview_text += "\n"
                        
                        # Top positions
                        if positions_lines:
                            preview_text += "ðŸ“ˆ Vá»Š THáº¾ Æ¯U TIÃŠN:\n"
                            for line in positions_lines[:3]:  # Top 3 positions
                                # Simplify position line for preview
                                if '|' in line:
                                    parts = line.split('|')
                                    symbol_vol = parts[0].replace('â€¢', '').strip()
                                    pnl = parts[2].strip() if len(parts) > 2 else 'N/A'
                                    preview_text += f"â€¢ {symbol_vol} | {pnl}\n"
                                else:
                                    preview_text += f"â€¢ {line.strip()[:100]}...\n"
                    else:
                        preview_text = "ðŸ“Š POSITIONS MANAGEMENT REPORT\n"
                        preview_text += "==============================\n\n"
                        
                        # Risk overview
                        if summary_lines:
                            preview_text += "ðŸŽ¯ RISK OVERVIEW:\n"
                            for line in summary_lines[:6]:  # Top 6 summary items
                                preview_text += f"â€¢ {line.strip()}\n"
                            preview_text += "\n"
                        
                        # Top positions
                        if positions_lines:
                            preview_text += "ðŸ“ˆ PRIORITY POSITIONS:\n"
                            for line in positions_lines[:3]:  # Top 3 positions
                                # Simplify position line for preview
                                if '|' in line:
                                    parts = line.split('|')
                                    symbol_vol = parts[0].replace('â€¢', '').strip()
                                    pnl = parts[2].strip() if len(parts) > 2 else 'N/A'
                                    preview_text += f"â€¢ {symbol_vol} | {pnl}\n"
                                else:
                                    preview_text += f"â€¢ {line.strip()[:100]}...\n"
                    
                    preview_text += "\n" + self._get_branded_footer()
                    return preview_text
                
                # Fallback if no real data
                if AppState.language() == 'vi':
                    return "ðŸ“Š BÃO CÃO QUáº¢N LÃ Vá»Š THáº¾\n==============================\n\nâš ï¸ ChÆ°a cÃ³ dá»¯ liá»‡u vá»‹ tháº¿ thá»±c táº¿\nVui lÃ²ng káº¿t ná»‘i tÃ i khoáº£n trading Ä‘á»ƒ xem bÃ¡o cÃ¡o\n\n" + self._get_branded_footer()
                else:
                    return "ðŸ“Š POSITIONS MANAGEMENT REPORT\n==============================\n\nâš ï¸ No real positions data available\nPlease connect trading account to view report\n\n" + self._get_branded_footer()
                
            except Exception as e:
                return f"Error getting real account report preview: {e}"
        
        def _manual_update_preview(self):
            """Manual update preview when button is clicked"""
            try:
                print("ðŸ”„ Manual update preview button clicked")
                
                # Debug: Check current state of radio buttons
                signal_checked = self.signal_radio.isChecked() if hasattr(self, 'signal_radio') else False
                custom_checked = self.custom_radio.isChecked() if hasattr(self, 'custom_radio') else False
                report_checked = self.report_radio.isChecked() if hasattr(self, 'report_radio') else False
                
                print(f"ðŸ“Š Radio states - Signal: {signal_checked}, Custom: {custom_checked}, Report: {report_checked}")
                
                # Force update preview
                self._update_preview()
                
                # Show confirmation message
                self._show_notification(I18N.t("âœ… Preview Updated", "âœ… Xem trÆ°á»›c Ä‘Ã£ cáº­p nháº­t"), 
                                      I18N.t("Message preview has been refreshed", "Xem trÆ°á»›c tin nháº¯n Ä‘Ã£ Ä‘Æ°á»£c lÃ m má»›i"))
                
            except Exception as e:
                print(f"âŒ Error in manual update preview: {e}")
                self._show_notification(I18N.t("âŒ Preview Error", "âŒ Lá»—i xem trÆ°á»›c"), 
                                      I18N.t("Error updating preview:", "Lá»—i cáº­p nháº­t xem trÆ°á»›c:") + f" {str(e)}")
        
        def _load_current_config(self):
            """Load current notification configuration"""
            try:
                # Temporarily disconnect auto-save signals to avoid conflicts
                self._disconnect_auto_save_signals()
                
                import json
                config_file = os.path.join(os.getcwd(), 'notification_config.json')
                if os.path.exists(config_file):
                    with open(config_file, 'r', encoding='utf-8') as f:
                        config = json.load(f)
                    
                    # Load Telegram settings
                    telegram = config.get('telegram', {})
                    if telegram.get('enabled', False):
                        self.telegram_cb.setChecked(True)
                    
                    bot_token = telegram.get('bot_token', '')
                    print(f"ðŸ” [DEBUG] Loading bot_token: '{bot_token}'")
                    if bot_token and bot_token != 'THAY_BOT_TOKEN_Tá»ª_BOTFATHER':
                        self.telegram_token.setText(bot_token)
                        print(f"âœ… [DEBUG] Bot token set to field. Current field value: '{self.telegram_token.text()}'")
                    else:
                        print(f"âŒ [DEBUG] Bot token not set - empty or placeholder")
                    
                    chat_id = telegram.get('chat_id', '')
                    print(f"ðŸ” [DEBUG] Loading chat_id: '{chat_id}'")
                    if chat_id and chat_id != 'THAY_CHAT_ID_Tá»ª_NHÃ“M':
                        self.telegram_chat_id.setText(chat_id)
                        print(f"âœ… [DEBUG] Chat ID set to field. Current field value: '{self.telegram_chat_id.text()}'")
                    else:
                        print(f"âŒ [DEBUG] Chat ID not set - empty or placeholder")
                    
                    # Load Zalo settings
                    zalo = config.get('zalo', {})
                    if zalo.get('enabled', False):
                        self.zalo_cb.setChecked(True)
                    
                    webhook = zalo.get('webhook_url', '')
                    if webhook and webhook != 'YOUR_WEBHOOK_URL_HERE':
                        self.zalo_webhook.setText(webhook)
                    
                    zalo_token = zalo.get('access_token', '')
                    if hasattr(self, 'zalo_token') and zalo_token:
                        self.zalo_token.setText(zalo_token)
                    
                    # Load WhatsApp settings
                    whatsapp = config.get('whatsapp', {})
                    if whatsapp.get('enabled', False):
                        self.whatsapp_cb.setChecked(True)
                    
                    if hasattr(self, 'whatsapp_api_key'):
                        whatsapp_api = whatsapp.get('api_key', '')
                        if whatsapp_api:
                            self.whatsapp_api_key.setText(whatsapp_api)
                    
                    if hasattr(self, 'whatsapp_phone'):
                        whatsapp_phone = whatsapp.get('phone_number', '')
                        if whatsapp_phone:
                            self.whatsapp_phone.setText(whatsapp_phone)
                    
                    # Load Discord settings
                    discord = config.get('discord', {})
                    if discord.get('enabled', False):
                        self.discord_cb.setChecked(True)
                    
                    if hasattr(self, 'discord_webhook'):
                        discord_webhook = discord.get('webhook_url', '')
                        if discord_webhook:
                            self.discord_webhook.setText(discord_webhook)
                    
                    # Load Email settings
                    email = config.get('email', {})
                    if email.get('enabled', False):
                        self.email_cb.setChecked(True)
                    
                    if hasattr(self, 'email_smtp'):
                        email_smtp = email.get('smtp_server', '')
                        if email_smtp:
                            self.email_smtp.setText(email_smtp)
                    
                    if hasattr(self, 'email_port'):
                        email_port = email.get('port', '')
                        if email_port:
                            self.email_port.setText(email_port)
                    
                    if hasattr(self, 'email_address'):
                        email_addr = email.get('email', '')
                        if email_addr:
                            self.email_address.setText(email_addr)
                    
                    if hasattr(self, 'email_password'):
                        email_pass = email.get('password', '')
                        if email_pass:
                            self.email_password.setText(email_pass)
                    
                    if hasattr(self, 'email_to'):
                        email_to = email.get('to_email', '')
                        if email_to:
                            self.email_to.setText(email_to)
                    
                    # Load Custom Webhook settings
                    webhook_config = config.get('webhook', {})
                    if webhook_config.get('enabled', False):
                        self.webhook_cb.setChecked(True)
                    
                    if hasattr(self, 'webhook_url'):
                        webhook_url = webhook_config.get('url', '')
                        if webhook_url:
                            self.webhook_url.setText(webhook_url)
                    
                    if hasattr(self, 'webhook_method'):
                        webhook_method = webhook_config.get('method', 'POST')
                        if webhook_method:
                            index = self.webhook_method.findText(webhook_method)
                            if index >= 0:
                                self.webhook_method.setCurrentIndex(index)
                    
                    if hasattr(self, 'webhook_headers'):
                        webhook_headers = webhook_config.get('headers', '')
                        if webhook_headers:
                            self.webhook_headers.setPlainText(webhook_headers)
                
                # Load Branding settings
                branding = config.get('branding', {})
                if hasattr(self, 'enable_custom_footer'):
                    self.enable_custom_footer.setChecked(branding.get('enable_custom_footer', True))
                if hasattr(self, 'system_name_en'):
                    self.system_name_en.setText(branding.get('system_name_en', 'VU HIEN CFDs AI System'))
                if hasattr(self, 'system_name_vi'):
                    self.system_name_vi.setText(branding.get('system_name_vi', 'Há»‡ thá»‘ng AI VU HIEN CFDs'))
                if hasattr(self, 'contact_phone'):
                    self.contact_phone.setText(branding.get('phone', '+84 39 65 60 888'))
                if hasattr(self, 'contact_email'):
                    self.contact_email.setText(branding.get('email', ''))
                if hasattr(self, 'contact_website'):
                    self.contact_website.setText(branding.get('website', ''))
                if hasattr(self, 'contact_social'):
                    self.contact_social.setText(branding.get('social', ''))
                if hasattr(self, 'footer_template'):
                    self.footer_template.setPlainText(branding.get('footer_template', 'ðŸ¤– {system_name}\nðŸ“± {phone}\nðŸ“§ {email}\nðŸŒ {website}\nï¿½ {social}'))
                
                # Default selections
                self.signal_radio.setChecked(True)
                self._update_preview()
                self._on_platform_selection_changed()
                
                # Reconnect auto-save signals after loading
                self._connect_auto_save_signals()
                
            except Exception as e:
                print(f"Error loading config: {e}")
                # Reconnect signals even on error
                self._connect_auto_save_signals()
        
        def _load_config_and_connect_signals(self):
            """Load config first, then connect auto-save signals"""
            try:
                # Load configuration
                self._load_config_only()
                
                # Clear loading flag to allow saves
                self._is_loading_settings = False
                
                # NOW connect auto-save signals
                self._connect_auto_save_signals()
                
                print("âœ… Config loaded and auto-save signals connected")
                
            except Exception as e:
                print(f"âŒ Error loading config and connecting signals: {e}")
                self._is_loading_settings = False
        
        def _load_config_only(self):
            """Load existing notification configuration - SIMPLE VERSION"""
            try:
                import json
                config_file = os.path.join(os.getcwd(), 'notification_config.json')
                if not os.path.exists(config_file):
                    return
                    
                with open(config_file, 'r', encoding='utf-8') as f:
                    config = json.load(f)
                
                # Load Telegram settings
                telegram = config.get('telegram', {})
                if telegram.get('enabled', False):
                    self.telegram_cb.setChecked(True)
                
                bot_token = telegram.get('bot_token', '')
                if bot_token and hasattr(self, 'telegram_token'):
                    print(f"ðŸ” [DEBUG] Setting bot_token to field: {bot_token[:10]}...")
                    self.telegram_token.setText(bot_token)
                    self.telegram_token.clearFocus()  # Force update
                    self.telegram_token.repaint()     # Force repaint
                    print(f"ðŸ” [DEBUG] After setText: {self.telegram_token.text()}")
                else:
                    print(f"âŒ [DEBUG] Cannot set bot_token - field missing or empty token")
                
                chat_id = telegram.get('chat_id', '')
                if chat_id and hasattr(self, 'telegram_chat_id'):
                    print(f"ðŸ” [DEBUG] Setting chat_id to field: {chat_id}")
                    self.telegram_chat_id.setText(chat_id)
                    self.telegram_chat_id.clearFocus()  # Force update
                    self.telegram_chat_id.repaint()     # Force repaint
                    print(f"ðŸ” [DEBUG] After setText: {self.telegram_chat_id.text()}")
                else:
                    print(f"âŒ [DEBUG] Cannot set chat_id - field missing or empty chat_id")
                
                # Load Facebook Messenger settings
                facebook = config.get('facebook_messenger', {})
                if facebook.get('enabled', False):
                    self.facebook_cb.setChecked(True)
                
                facebook_token = facebook.get('page_access_token', '')
                if facebook_token and hasattr(self, 'facebook_token'):
                    self.facebook_token.setText(facebook_token)
                
                facebook_recipient = facebook.get('recipient_id', '')
                if facebook_recipient and hasattr(self, 'facebook_recipient'):
                    self.facebook_recipient.setText(facebook_recipient)
                
                # ðŸ†• Load notification/reporting settings from 'settings' section
                settings = config.get('settings', {})
                
                # Track orders
                if hasattr(self, 'track_orders_cb'):
                    self.track_orders_cb.setChecked(settings.get('track_order_updates', False))
                if hasattr(self, 'track_orders_pips_spin'):
                    self.track_orders_pips_spin.setValue(settings.get('track_orders_pip_threshold', 50))
                
                # SL/TP notifications
                if hasattr(self, 'notify_sl_tp_cb'):
                    self.notify_sl_tp_cb.setChecked(settings.get('notify_sl_tp_changes', False))
                if hasattr(self, 'sltp_pips_spin'):
                    self.sltp_pips_spin.setValue(settings.get('sltp_pip_threshold', 10))
                
                # Close notifications
                if hasattr(self, 'notify_close_cb'):
                    self.notify_close_cb.setChecked(settings.get('notify_order_close', False))
                
                # Daily summary
                if hasattr(self, 'daily_summary_cb'):
                    self.daily_summary_cb.setChecked(settings.get('daily_summary_enabled', False))
                if hasattr(self, 'daily_summary_time'):
                    time_str = settings.get('daily_summary_time', '20:00')
                    self.daily_summary_time.setTime(QTime.fromString(time_str, "HH:mm"))
                
                # Notification format
                format_type = settings.get('notification_format', 'full')
                if hasattr(self, 'format_summary_rb') and hasattr(self, 'format_full_rb'):
                    if format_type == 'summary':
                        self.format_summary_rb.setChecked(True)
                    else:
                        self.format_full_rb.setChecked(True)
                
                # Advanced checkboxes
                if hasattr(self, 'include_technical_cb'):
                    self.include_technical_cb.setChecked(settings.get('include_technical', True))
                if hasattr(self, 'include_indicators_cb'):
                    self.include_indicators_cb.setChecked(settings.get('include_indicators', False))
                if hasattr(self, 'include_summary_cb'):
                    self.include_summary_cb.setChecked(settings.get('include_summary', True))
                if hasattr(self, 'include_candlestick_cb'):
                    self.include_candlestick_cb.setChecked(settings.get('include_candlestick', True))
                if hasattr(self, 'include_price_patterns_cb'):
                    self.include_price_patterns_cb.setChecked(settings.get('include_price_patterns', False))
                
                # Custom message
                if hasattr(self, 'send_custom_message'):
                    self.send_custom_message.setChecked(settings.get('send_custom_message', False))
                if hasattr(self, 'custom_message'):
                    self.custom_message.setPlainText(settings.get('custom_message', ''))
                
                # ðŸ†• Trading History Report options
                if hasattr(self, 'history_include_closed'):
                    self.history_include_closed.setChecked(settings.get('history_include_closed', True))
                if hasattr(self, 'history_include_stats'):
                    self.history_include_stats.setChecked(settings.get('history_include_stats', True))
                if hasattr(self, 'history_include_chart'):
                    self.history_include_chart.setChecked(settings.get('history_include_chart', False))
                if hasattr(self, 'history_period_combo'):
                    period_idx = settings.get('history_period', 0)
                    if 0 <= period_idx < self.history_period_combo.count():
                        self.history_period_combo.setCurrentIndex(period_idx)
                if hasattr(self, 'history_schedule_type'):
                    schedule_idx = settings.get('history_schedule_type', 0)
                    if 0 <= schedule_idx < self.history_schedule_type.count():
                        self.history_schedule_type.setCurrentIndex(schedule_idx)
                        # Enable/disable time widget based on schedule type
                        if hasattr(self, 'daily_summary_time'):
                            self.daily_summary_time.setEnabled(schedule_idx == 1)  # Daily
                            self.daily_summary_time.setVisible(schedule_idx == 1)  # Hide if hourly
                        if hasattr(self, 'history_hourly_interval'):
                            self.history_hourly_interval.setVisible(schedule_idx == 0)  # Hourly
                        if hasattr(self, 'history_hourly_label'):
                            self.history_hourly_label.setVisible(schedule_idx == 0)  # Hourly
                if hasattr(self, 'daily_summary_time'):
                    time_str = settings.get('history_schedule_time', '20:00')
                    self.daily_summary_time.setTime(QTime.fromString(time_str, "HH:mm"))
                if hasattr(self, 'history_hourly_interval'):
                    hourly_interval = settings.get('history_hourly_interval', 1)
                    if 1 <= hourly_interval <= 24:
                        self.history_hourly_interval.setValue(hourly_interval)
                
                # Default selections
                self.signal_radio.setChecked(True)
                self._update_preview()
                self._on_platform_selection_changed()
                
                print(f"âœ… Config loaded: token={bot_token[:10]}..., chat_id={chat_id}")
                print(f"ðŸ” [DEBUG] Field values after setText: token='{self.telegram_token.text()}', chat_id='{self.telegram_chat_id.text()}'")
                print(f"ðŸ“‹ [DEBUG] Notification settings loaded from config")
                print(f"ðŸ“Š [DEBUG] Trading history settings loaded from config")
                
                # DO NOT save config after loading - it overwrites with empty values
                print("âš ï¸ [DEBUG] Skipping force save - preserving JSON file")
                
            except Exception as e:
                print(f"âŒ Error loading config: {e}")

        def _get_widget_text(self, widget_name, default=""):
            """Safely get text from widget"""
            try:
                widget = getattr(self, widget_name, None)
                if widget and hasattr(widget, 'text'):
                    return widget.text().strip()
                elif widget and hasattr(widget, 'toPlainText'):
                    return widget.toPlainText().strip()
                return default
            except:
                return default
        
        def _get_widget_checked(self, widget_name, default=False):
            """Safely get checked state from widget"""
            try:
                widget = getattr(self, widget_name, None)
                if widget and hasattr(widget, 'isChecked'):
                    return widget.isChecked()
                return default
            except:
                return default

        def _save_config(self, show_message=True):
            """Save notification configuration"""
            try:
                import json
                
                # Protection: Don't save if Telegram fields are empty
                bot_token = self.telegram_token.text().strip()
                chat_id = self.telegram_chat_id.text().strip()
                
                if not bot_token or not chat_id:
                    print("âš ï¸ [DEBUG] Skipping save - Telegram fields are empty")
                    if show_message:
                        QMessageBox.warning(self, I18N.t("Save Config", "LÆ°u cáº¥u hÃ¬nh"), I18N.t("Telegram Bot Token and Chat ID cannot be empty!", "Telegram Bot Token vÃ  Chat ID khÃ´ng Ä‘Æ°á»£c Ä‘á»ƒ trá»‘ng!"))
                    return False
                
                # Build config for all platforms using safe methods
                config = {
                    "telegram": {
                        "enabled": self.telegram_cb.isChecked(),
                        "bot_token": bot_token,
                        "chat_id": chat_id
                    },
                    "whatsapp": self._get_safe_whatsapp_config(),
                    "discord": self._get_safe_discord_config(),
                    "zalo": self._get_safe_zalo_config(),
                    "facebook_messenger": self._get_safe_facebook_config(),
                    "email": self._get_safe_email_config(),
                    "webhook": self._get_safe_webhook_config(),
                    "settings": self._get_safe_settings_config(),
                    "branding": self._get_safe_branding_config()
                }
                
                config_file = os.path.join(os.getcwd(), 'notification_config.json')
                with open(config_file, 'w', encoding='utf-8') as f:
                    json.dump(config, f, indent=2, ensure_ascii=False)
                
                if show_message:
                    QMessageBox.information(self, I18N.t("Saved", "ÄÃ£ lÆ°u"), 
                                          I18N.t("Configuration saved successfully!", "Cáº¥u hÃ¬nh Ä‘Ã£ Ä‘Æ°á»£c lÆ°u thÃ nh cÃ´ng!"))
                return True
                
            except Exception as e:
                if show_message:
                    QMessageBox.critical(self, I18N.t("Error", "Lá»—i"), 
                                       I18N.t("Failed to save config", "LÆ°u cáº¥u hÃ¬nh tháº¥t báº¡i") + f": {e}")
                return False
        
        def _get_safe_branding_config(self):
            """Safely get branding configuration with error protection"""
            branding_config = {}
            
            # Enable custom footer checkbox
            try:
                if hasattr(self, 'enable_custom_footer') and self.enable_custom_footer:
                    branding_config['enable_custom_footer'] = self.enable_custom_footer.isChecked()
                else:
                    branding_config['enable_custom_footer'] = True
            except RuntimeError:
                branding_config['enable_custom_footer'] = True
            
            # System name fields
            try:
                if hasattr(self, 'system_name_en') and self.system_name_en:
                    branding_config['system_name_en'] = self.system_name_en.text().strip()
                else:
                    branding_config['system_name_en'] = "VU HIEN CFDs AI System"
            except RuntimeError:
                branding_config['system_name_en'] = "VU HIEN CFDs AI System"
                
            try:
                if hasattr(self, 'system_name_vi') and self.system_name_vi:
                    branding_config['system_name_vi'] = self.system_name_vi.text().strip()
                else:
                    branding_config['system_name_vi'] = "Há»‡ thá»‘ng AI VU HIEN CFDs"
            except RuntimeError:
                branding_config['system_name_vi'] = "Há»‡ thá»‘ng AI VU HIEN CFDs"
            
            # Contact fields
            try:
                if hasattr(self, 'contact_phone') and self.contact_phone:
                    branding_config['phone'] = self.contact_phone.text().strip()
                else:
                    branding_config['phone'] = "+84 39 65 60 888"
            except RuntimeError:
                branding_config['phone'] = "+84 39 65 60 888"
                
            try:
                if hasattr(self, 'contact_email') and self.contact_email:
                    branding_config['email'] = self.contact_email.text().strip()
                else:
                    branding_config['email'] = "vuhien2444cfds@gmail.com"
            except RuntimeError:
                branding_config['email'] = "vuhien2444cfds@gmail.com"
                
            try:
                if hasattr(self, 'contact_website') and self.contact_website:
                    branding_config['website'] = self.contact_website.text().strip()
                else:
                    branding_config['website'] = ""
            except RuntimeError:
                branding_config['website'] = ""
                
            try:
                if hasattr(self, 'contact_social') and self.contact_social:
                    branding_config['social'] = self.contact_social.text().strip()
                else:
                    branding_config['social'] = ""
            except RuntimeError:
                branding_config['social'] = ""
            
            # Footer template
            try:
                if hasattr(self, 'footer_template') and self.footer_template:
                    branding_config['footer_template'] = self.footer_template.toPlainText().strip()
                else:
                    branding_config['footer_template'] = "ðŸ¤– {system_name}\nðŸ“± {phone}\nðŸ“§ {email}\nðŸŒ {website}\nï¿½ {social}"
            except RuntimeError:
                branding_config['footer_template'] = "ðŸ¤– {system_name}\nðŸ“± {phone}\nðŸ“§ {email}\nðŸŒ {website}\nï¿½ {social}"
            
            return branding_config
        
        def _get_safe_whatsapp_config(self):
            """Safely get WhatsApp configuration"""
            try:
                return {
                    "enabled": self.whatsapp_cb.isChecked() if hasattr(self, 'whatsapp_cb') and self.whatsapp_cb else False,
                    "api_key": self.whatsapp_api_key.text().strip() if hasattr(self, 'whatsapp_api_key') and self.whatsapp_api_key else "",
                    "phone_number": self.whatsapp_phone.text().strip() if hasattr(self, 'whatsapp_phone') and self.whatsapp_phone else ""
                }
            except RuntimeError:
                return {"enabled": False, "api_key": "", "phone_number": ""}
        
        def _get_safe_discord_config(self):
            """Safely get Discord configuration"""
            try:
                return {
                    "enabled": self.discord_cb.isChecked() if hasattr(self, 'discord_cb') and self.discord_cb else False,
                    "webhook_url": self.discord_webhook.text().strip() if hasattr(self, 'discord_webhook') and self.discord_webhook else ""
                }
            except RuntimeError:
                return {"enabled": False, "webhook_url": ""}
        
        def _get_safe_zalo_config(self):
            """Safely get Zalo configuration"""
            try:
                return {
                    "enabled": self.zalo_cb.isChecked() if hasattr(self, 'zalo_cb') and self.zalo_cb else False,
                    "webhook_url": self.zalo_webhook.text().strip() if hasattr(self, 'zalo_webhook') and self.zalo_webhook else "",
                    "access_token": self.zalo_token.text().strip() if hasattr(self, 'zalo_token') and self.zalo_token else ""
                }
            except RuntimeError:
                return {"enabled": False, "webhook_url": "", "access_token": ""}
        
        def _get_safe_facebook_config(self):
            """Safely get Facebook configuration"""
            try:
                return {
                    "enabled": self.facebook_cb.isChecked() if hasattr(self, 'facebook_cb') and self.facebook_cb else False,
                    "page_access_token": self.facebook_token.text().strip() if hasattr(self, 'facebook_token') and self.facebook_token else "",
                    "page_id": "",
                    "recipient_id": self.facebook_recipient.text().strip() if hasattr(self, 'facebook_recipient') and self.facebook_recipient else "",
                    "note": "Facebook Messenger API - Get from Meta for Developers"
                }
            except RuntimeError:
                return {"enabled": False, "page_access_token": "", "page_id": "", "recipient_id": "", "note": "Facebook Messenger API - Get from Meta for Developers"}
        
        def _get_safe_email_config(self):
            """Safely get Email configuration"""
            try:
                return {
                    "enabled": self.email_cb.isChecked() if hasattr(self, 'email_cb') and self.email_cb else False,
                    "smtp_server": self.email_smtp.text().strip() if hasattr(self, 'email_smtp') and self.email_smtp else "",
                    "port": self.email_port.text().strip() if hasattr(self, 'email_port') and self.email_port else "",
                    "email": self.email_address.text().strip() if hasattr(self, 'email_address') and self.email_address else "",
                    "password": self.email_password.text().strip() if hasattr(self, 'email_password') and self.email_password else "",
                    "to_email": self.email_to.text().strip() if hasattr(self, 'email_to') and self.email_to else ""
                }
            except RuntimeError:
                return {"enabled": False, "smtp_server": "", "port": "", "email": "", "password": "", "to_email": ""}
        
        def _get_safe_webhook_config(self):
            """Safely get Webhook configuration"""
            try:
                return {
                    "enabled": self.webhook_cb.isChecked() if hasattr(self, 'webhook_cb') and self.webhook_cb else False,
                    "url": self.webhook_url.text().strip() if hasattr(self, 'webhook_url') and self.webhook_url else "",
                    "method": self.webhook_method.currentText() if hasattr(self, 'webhook_method') and self.webhook_method else "POST",
                    "headers": self.webhook_headers.toPlainText().strip() if hasattr(self, 'webhook_headers') and self.webhook_headers else ""
                }
            except RuntimeError:
                return {"enabled": False, "url": "", "method": "POST", "headers": ""}
        
        def _get_safe_settings_config(self):
            """Safely get Settings configuration"""
            try:
                return {
                    "send_signals": False,
                    "send_reports": False,
                    "send_execution_results": True,
                    "daily_summary": True,
                    "format_vietnamese": True,
                    "max_message_length": 4000,
                    "track_order_updates": True,
                    "notify_sl_tp_changes": True,
                    "notify_order_close": True,
                    "update_interval_seconds": 30,
                    "custom_message": self.custom_message.toPlainText().strip() if hasattr(self, 'custom_message') and self.custom_message else "LiÃªn Há»‡:",
                    "notification_format": "full" if (hasattr(self, 'format_full_rb') and self.format_full_rb.isChecked()) else "summary",
                    "include_technical": self.include_technical_cb.isChecked() if hasattr(self, 'include_technical_cb') and self.include_technical_cb else True,
                    "include_indicators": self.include_indicators_cb.isChecked() if hasattr(self, 'include_indicators_cb') and self.include_indicators_cb else False,
                    "include_summary": self.include_summary_cb.isChecked() if hasattr(self, 'include_summary_cb') and self.include_summary_cb else True,
                    "include_candlestick": self.include_candlestick_cb.isChecked() if hasattr(self, 'include_candlestick_cb') and self.include_candlestick_cb else True,
                    "include_price_patterns": self.include_price_patterns_cb.isChecked() if hasattr(self, 'include_price_patterns_cb') and self.include_price_patterns_cb else True,
                    "send_custom_message": self.send_custom_message.isChecked() if hasattr(self, 'send_custom_message') and self.send_custom_message else False,
                    "include_technical_analysis": True,
                    # ðŸ†• Trading History Report options
                    "history_include_closed": self.history_include_closed.isChecked() if hasattr(self, 'history_include_closed') and self.history_include_closed else True,
                    "history_include_stats": self.history_include_stats.isChecked() if hasattr(self, 'history_include_stats') and self.history_include_stats else True,
                    "history_include_chart": self.history_include_chart.isChecked() if hasattr(self, 'history_include_chart') and self.history_include_chart else False,
                    "history_period": self.history_period_combo.currentIndex() if hasattr(self, 'history_period_combo') and self.history_period_combo else 0,
                    "history_schedule_type": self.history_schedule_type.currentIndex() if hasattr(self, 'history_schedule_type') and self.history_schedule_type else 0,
                    "history_schedule_time": self.daily_summary_time.time().toString("HH:mm") if hasattr(self, 'daily_summary_time') and self.daily_summary_time else "20:00",
                    "history_hourly_interval": self.history_hourly_interval.value() if hasattr(self, 'history_hourly_interval') and self.history_hourly_interval else 1,
                }
            except RuntimeError:
                return {
                    "send_signals": False,
                    "send_reports": False,
                    "send_execution_results": True,
                    "daily_summary": True,
                    "format_vietnamese": True,
                    "max_message_length": 4000,
                    "track_order_updates": True,
                    "notify_sl_tp_changes": True,
                    "notify_order_close": True,
                    "update_interval_seconds": 30,
                    "custom_message": "LiÃªn Há»‡:",
                    "notification_format": "summary",
                    "include_technical": True,
                    "include_indicators": False,
                    "include_summary": True,
                    "include_candlestick": True,
                    "include_price_patterns": True,
                    "send_custom_message": False,
                    "include_technical_analysis": True,
                    # ðŸ†• Trading History Report default options
                    "history_include_closed": True,
                    "history_include_stats": True,
                    "history_include_chart": False,
                    "history_period": 0,
                    "history_schedule_type": 0,
                    "history_schedule_time": "20:00",
                    "history_hourly_interval": 1,
                }
        
        def _disconnect_auto_save_signals(self):
            """Temporarily disconnect auto-save signals"""
            try:
                print("ðŸ” [DEBUG] Disconnecting auto-save signals...")
                
                # Disconnect Telegram fields
                if hasattr(self, 'telegram_token'):
                    self.telegram_token.textChanged.disconnect()
                
                if hasattr(self, 'telegram_chat_id'):
                    self.telegram_chat_id.textChanged.disconnect()
                
                # Disconnect Zalo fields
                if hasattr(self, 'zalo_webhook'):
                    self.zalo_webhook.textChanged.disconnect()
                
                if hasattr(self, 'zalo_token'):
                    self.zalo_token.textChanged.disconnect()
                
                # Disconnect other fields...
                if hasattr(self, 'whatsapp_api_key'):
                    self.whatsapp_api_key.textChanged.disconnect()
                
                if hasattr(self, 'whatsapp_phone'):
                    self.whatsapp_phone.textChanged.disconnect()
                
                if hasattr(self, 'discord_webhook'):
                    self.discord_webhook.textChanged.disconnect()
                
                if hasattr(self, 'custom_message'):
                    self.custom_message.textChanged.disconnect()
                
                # Disconnect checkboxes
                if hasattr(self, 'telegram_cb'):
                    self.telegram_cb.stateChanged.disconnect()
                
                if hasattr(self, 'zalo_cb'):
                    self.zalo_cb.stateChanged.disconnect()
                
                if hasattr(self, 'whatsapp_cb'):
                    self.whatsapp_cb.stateChanged.disconnect()
                
                if hasattr(self, 'discord_cb'):
                    self.discord_cb.stateChanged.disconnect()
                
                if hasattr(self, 'email_cb'):
                    self.email_cb.stateChanged.disconnect()
                
                if hasattr(self, 'webhook_cb'):
                    self.webhook_cb.stateChanged.disconnect()
                
                print("âœ… [DEBUG] Auto-save signals disconnected successfully")
                
            except Exception as e:
                print(f"âš ï¸ [WARNING] Error disconnecting signals (this is normal): {e}")
        
        def _connect_auto_save_signals(self):
            """Connect all widget signals to auto-save function"""
            try:
                print("ðŸ”Œ [DEBUG] Connecting auto-save signals...")
                
                # Notification/Reporting tab
                if hasattr(self, 'track_orders_cb'):
                    self.track_orders_cb.toggled.connect(self._save_auto_notification_settings)
                if hasattr(self, 'notify_sl_tp_cb'):
                    self.notify_sl_tp_cb.toggled.connect(self._save_auto_notification_settings)
                if hasattr(self, 'notify_close_cb'):
                    self.notify_close_cb.toggled.connect(self._save_auto_notification_settings)
                if hasattr(self, 'track_orders_pips_spin'):
                    self.track_orders_pips_spin.valueChanged.connect(self._save_auto_notification_settings)
                if hasattr(self, 'sltp_pips_spin'):
                    self.sltp_pips_spin.valueChanged.connect(self._save_auto_notification_settings)
                if hasattr(self, 'daily_summary_cb'):
                    self.daily_summary_cb.toggled.connect(self._save_auto_notification_settings)
                if hasattr(self, 'daily_summary_time'):
                    self.daily_summary_time.timeChanged.connect(self._save_auto_notification_settings)
                
                # Format radio buttons
                if hasattr(self, 'format_summary_rb'):
                    self.format_summary_rb.toggled.connect(self._save_auto_notification_settings)
                if hasattr(self, 'format_full_rb'):
                    self.format_full_rb.toggled.connect(self._save_auto_notification_settings)
                
                # Advanced checkboxes
                if hasattr(self, 'include_technical_cb'):
                    self.include_technical_cb.toggled.connect(self._save_auto_notification_settings)
                if hasattr(self, 'include_indicators_cb'):
                    self.include_indicators_cb.toggled.connect(self._save_auto_notification_settings)
                if hasattr(self, 'include_summary_cb'):
                    self.include_summary_cb.toggled.connect(self._save_auto_notification_settings)
                if hasattr(self, 'include_candlestick_cb'):
                    self.include_candlestick_cb.toggled.connect(self._save_auto_notification_settings)
                if hasattr(self, 'include_price_patterns_cb'):
                    self.include_price_patterns_cb.toggled.connect(self._save_auto_notification_settings)
                
                # Custom message
                if hasattr(self, 'send_custom_message'):
                    self.send_custom_message.toggled.connect(self._save_auto_notification_settings)
                if hasattr(self, 'custom_message'):
                    self.custom_message.textChanged.connect(self._save_auto_notification_settings)
                
                # Trading History Report options
                if hasattr(self, 'history_include_closed'):
                    self.history_include_closed.toggled.connect(self._save_auto_notification_settings)
                if hasattr(self, 'history_include_stats'):
                    self.history_include_stats.toggled.connect(self._save_auto_notification_settings)
                if hasattr(self, 'history_include_chart'):
                    self.history_include_chart.toggled.connect(self._save_auto_notification_settings)
                if hasattr(self, 'history_period_combo'):
                    self.history_period_combo.currentIndexChanged.connect(self._save_auto_notification_settings)
                if hasattr(self, 'history_schedule_type'):
                    self.history_schedule_type.currentIndexChanged.connect(self._save_auto_notification_settings)
                if hasattr(self, 'history_hourly_interval'):
                    self.history_hourly_interval.valueChanged.connect(self._save_auto_notification_settings)
                
                print("âœ… [DEBUG] All auto-save signals connected")
                
            except Exception as e:
                print(f"âŒ Error connecting auto-save signals: {e}")
        
        def _send_notification(self):
            """Send notification to selected platforms"""
            try:
                # Save config first
                if not self._save_config(show_message=True):
                    return
                
                # Prepare message content
                message_content = ""
                
                if self.signal_radio.isChecked():
                    # Get latest signals
                    signal_data = self._get_latest_signals()
                    if signal_data:
                        message_content = self._format_signal_message(signal_data)
                    else:
                        message_content = I18N.t("No recent signals available", "KhÃ´ng cÃ³ tÃ­n hiá»‡u gáº§n Ä‘Ã¢y")
                        
                elif self.custom_radio.isChecked():
                    message_content = self.custom_message.toPlainText().strip()
                    if not message_content:
                        QMessageBox.warning(self, I18N.t("Empty Message", "Tin nháº¯n trá»‘ng"), 
                                          I18N.t("Please enter a message", "Vui lÃ²ng nháº­p tin nháº¯n"))
                        return
                        
                elif self.report_radio.isChecked():
                    message_content = self._get_latest_report()
                
                if not message_content:
                    QMessageBox.warning(self, I18N.t("No Content", "KhÃ´ng cÃ³ ná»™i dung"), 
                                      I18N.t("No message content to send", "KhÃ´ng cÃ³ ná»™i dung tin nháº¯n Ä‘á»ƒ gá»­i"))
                    return
                
                # Send to selected platforms
                success_platforms = []
                failed_platforms = []
                
                # Telegram
                if self.telegram_cb.isChecked():
                    if self._send_to_telegram(message_content):
                        success_platforms.append("Telegram")
                    else:
                        failed_platforms.append("Telegram")
                
                # Discord 
                if self.discord_cb.isChecked():
                    if self._send_to_discord(message_content):
                        success_platforms.append("Discord")
                    else:
                        failed_platforms.append("Discord")
                
                # Show results
                if success_platforms:
                    success_msg = I18N.t("Successfully sent to: ", "Gá»­i thÃ nh cÃ´ng tá»›i: ") + ", ".join(success_platforms)
                    if failed_platforms:
                        success_msg += "\n" + I18N.t("Failed to send to: ", "Gá»­i tháº¥t báº¡i tá»›i: ") + ", ".join(failed_platforms)
                    QMessageBox.information(self, I18N.t("Send Results", "Káº¿t quáº£ gá»­i"), success_msg)
                else:
                    QMessageBox.warning(self, I18N.t("Send Failed", "Gá»­i tháº¥t báº¡i"), 
                                      I18N.t("Failed to send to any platform", "Gá»­i tháº¥t báº¡i tá»›i táº¥t cáº£ ná»n táº£ng"))
                
            except Exception as e:
                QMessageBox.critical(self, I18N.t("Error", "Lá»—i"), f"Send error: {e}")
        
        def _send_to_telegram(self, message):
            """Send message to Telegram"""
            try:
                token = self.telegram_token.text().strip()
                chat_id = self.telegram_chat_id.text().strip()
                
                if not token or not chat_id:
                    return False
                
                import requests
                url = f"https://api.telegram.org/bot{token}/sendMessage"
                data = {"chat_id": chat_id, "text": message, "parse_mode": "HTML"}
                
                response = requests.post(url, json=data, timeout=10)
                return response.status_code == 200
                
            except Exception as e:
                print(f"Telegram send error: {e}")
                return False
        
        def _send_to_discord(self, message):
            """Send message to Discord"""
            try:
                webhook_url = getattr(self, 'discord_webhook', QLineEdit()).text().strip()
                if not webhook_url:
                    return False
                
                import requests
                data = {"content": message}
                response = requests.post(webhook_url, json=data, timeout=10)
                return response.status_code == 204
                
            except Exception as e:
                print(f"Discord send error: {e}")
                return False
        
        def _get_latest_signals(self):
            """Get latest signal data from analysis results"""
            try:
                import json
                import glob
                
                # Look for latest signal files
                signal_files = glob.glob(os.path.join(os.getcwd(), 'analysis_results', '*_signal_*.json'))
                if not signal_files:
                    return None
                
                # Get most recent file
                latest_file = max(signal_files, key=os.path.getmtime)
                
                with open(latest_file, 'r', encoding='utf-8') as f:
                    signal_data = json.load(f)
                
                return signal_data
                
            except Exception as e:
                print(f"Error loading signal data: {e}")
                return None
        
        def _format_signal_message(self, signal_data):
            """Format signal data into readable message - handles both signals and executed orders"""
            try:
                if isinstance(signal_data, dict):
                    symbol = signal_data.get('symbol', 'Unknown')
                    signal_type = signal_data.get('signal', 'Unknown')
                    confidence = signal_data.get('confidence', 0)
                    entry = signal_data.get('entry_price', 0)
                    sl = signal_data.get('stop_loss', 0)
                    tp = signal_data.get('take_profit', 0)
                    
                    # Check if this is an executed order
                    is_executed = signal_data.get('is_executed', False)
                    ticket = signal_data.get('ticket', 0)
                    volume = signal_data.get('volume', 0)
                    executed_at = signal_data.get('executed_at', '')
                    
                    if AppState.language() == 'vi':
                        if is_executed:
                            message = f"âœ… Lá»†NH ÄÃƒ THá»°C HIá»†N\n\n"
                            message += f"ðŸ“Š {symbol}\n"
                            message += f"ðŸ“ˆ {signal_type}\n"
                            message += f"ðŸ’° GiÃ¡ vÃ o: {entry:.5f}\n"
                            message += f"ðŸ“¦ Khá»‘i lÆ°á»£ng: {volume:.2f} lots\n"
                            message += f"ðŸŽ« Ticket: #{ticket}\n"
                            message += f"â° Thá»i gian: {executed_at}\n\n"
                        else:
                            message = f"ðŸ”” TÃN HIá»†U GIAO Dá»ŠCH\n\n"
                            message += f"ðŸ“Š {symbol}\n"
                            message += f"ðŸ“ˆ {signal_type} ({confidence:.1f}%)\n"
                            message += f"ðŸ’° VÃ o lá»‡nh: {entry:.5f}\n"
                            message += f"ðŸ›¡ï¸ Cáº¯t lá»—: {sl:.5f}\n"
                            message += f"ðŸŽ¯ Chá»‘t lÃ£i: {tp:.5f}\n\n"
                        message += self._get_branded_footer('vi')
                    else:
                        if is_executed:
                            message = f"âœ… ORDER EXECUTED\n\n"
                            message += f"ðŸ“Š {symbol}\n"
                            message += f"ðŸ“ˆ {signal_type}\n"
                            message += f"ðŸ’° Entry Price: {entry:.5f}\n"
                            message += f"ðŸ“¦ Volume: {volume:.2f} lots\n"
                            message += f"ðŸŽ« Ticket: #{ticket}\n"
                            message += f"â° Time: {executed_at}\n\n"
                        else:
                            message = f"ðŸ”” TRADING SIGNAL\n\n"
                            message += f"ðŸ“Š {symbol}\n"
                            message += f"ðŸ“ˆ {signal_type} ({confidence:.1f}%)\n"
                            message += f"ðŸ’° Entry: {entry:.5f}\n"
                            message += f"ðŸ›¡ï¸ SL: {sl:.5f}\n"
                            message += f"ðŸŽ¯ TP: {tp:.5f}\n\n"
                        message += self._get_branded_footer('en')
                    
                    return message
                
            except Exception as e:
                print(f"Error formatting signal: {e}")
            
            return I18N.t("Error formatting signal data", "Lá»—i Ä‘á»‹nh dáº¡ng dá»¯ liá»‡u tÃ­n hiá»‡u")
        
        def _get_latest_report(self):
            """Get comprehensive report including executed orders and analysis"""
            try:
                import glob
                import json
                from datetime import datetime
                
                report_content = ""
                
                # 1. Add executed orders section
                executed_orders = self._get_latest_signals()  # This now returns executed orders
                if executed_orders:
                    if AppState.language() == 'vi':
                        report_content += "ðŸ”¥ CÃC Lá»†NH ÄÃƒ THá»°C HIá»†N Gáº¦N ÄÃ‚Y\n"
                        report_content += "=" * 40 + "\n\n"
                    else:
                        report_content += "ðŸ”¥ RECENTLY EXECUTED ORDERS\n"
                        report_content += "=" * 40 + "\n\n"
                    
                    for order in executed_orders[:3]:  # Show last 3 executed orders
                        if isinstance(order, dict):
                            symbol = order.get('symbol', 'Unknown')
                            action = order.get('signal', 'Unknown')
                            price = order.get('entry_price', 0)
                            volume = order.get('volume', 0)
                            ticket = order.get('ticket', 0)
                            time = order.get('executed_at', 'Unknown')
                            
                            if AppState.language() == 'vi':
                                report_content += f"âœ… {symbol} - {action}\n"
                                report_content += f"   ðŸ’° GiÃ¡: {price:.5f} | ðŸ“¦ LÆ°á»£ng: {volume:.2f} lots\n"
                                report_content += f"   ðŸŽ« Ticket: #{ticket} | â° {time}\n\n"
                            else:
                                report_content += f"âœ… {symbol} - {action}\n"
                                report_content += f"   ðŸ’° Price: {price:.5f} | ðŸ“¦ Volume: {volume:.2f} lots\n"
                                report_content += f"   ðŸŽ« Ticket: #{ticket} | â° {time}\n\n"
                
                # 2. Add account positions summary
                actions_file = os.path.join(os.getcwd(), 'analysis_results', 'account_positions_actions.json')
                if os.path.exists(actions_file):
                    with open(actions_file, 'r', encoding='utf-8') as f:
                        actions_data = json.load(f)
                    
                    if isinstance(actions_data, dict) and 'summary' in actions_data:
                        summary = actions_data['summary']
                        if AppState.language() == 'vi':
                            report_content += "ðŸ“Š TÃ“M Táº®T PHÃ‚N TÃCH TÃ€I KHOáº¢N\n"
                            report_content += "=" * 40 + "\n"
                            report_content += f"ðŸ” Symbols phÃ¢n tÃ­ch: {summary.get('total_symbols_analyzed', 0)}\n"
                            report_content += f"âš¡ TÃ­n hiá»‡u táº¡o: {summary.get('signals_generated', 0)}\n"
                            report_content += f"ðŸŽ¯ HÃ nh Ä‘á»™ng Æ°u tiÃªn cao: {summary.get('high_priority_actions', 0)}\n"
                            report_content += f"ðŸ“ˆ Tá»•ng hÃ nh Ä‘á»™ng: {summary.get('total_actions', 0)}\n\n"
                        else:
                            report_content += "ðŸ“Š ACCOUNT ANALYSIS SUMMARY\n"
                            report_content += "=" * 40 + "\n"
                            report_content += f"ðŸ” Symbols analyzed: {summary.get('total_symbols_analyzed', 0)}\n"
                            report_content += f"âš¡ Signals generated: {summary.get('signals_generated', 0)}\n"
                            report_content += f"ðŸŽ¯ High priority actions: {summary.get('high_priority_actions', 0)}\n"
                            report_content += f"ðŸ“ˆ Total actions: {summary.get('total_actions', 0)}\n\n"
                        
                        # Add detailed actions display
                        if 'actions' in actions_data and actions_data['actions']:
                            actions_list = actions_data['actions']
                            
                            if AppState.language() == 'vi':
                                report_content += "ðŸŽ¯ CHI TIáº¾T HÃ€NH Äá»˜NG\n"
                                report_content += "=" * 40 + "\n"
                            else:
                                report_content += "ðŸŽ¯ DETAILED ACTIONS\n"
                                report_content += "=" * 40 + "\n"
                            
                            # Show up to 10 most recent actions
                            for i, action in enumerate(actions_list[-10:], 1):
                                action_type = action.get('action_type', 'unknown')
                                symbol = action.get('symbol', 'N/A')
                                direction = action.get('direction', 'N/A')
                                reason = action.get('reason', 'No reason provided')
                                confidence = action.get('confidence', 0)
                                priority = action.get('priority', 0)
                                
                                # Action type emoji mapping
                                type_emoji = {
                                    'dca_entry': 'ðŸ”„',
                                    'hold': 'â¸ï¸',
                                    'move_sl_to_be': 'ðŸ›¡ï¸',
                                    'set_trailing_sl': 'ðŸ“ˆ',
                                    'close_position': 'âŒ',
                                    'entry_signal': 'ðŸš€'
                                }.get(action_type, 'âš¡')
                                
                                # Priority indicator
                                priority_text = "ðŸ”¥ " if priority >= 3 else ""
                                
                                if AppState.language() == 'vi':
                                    report_content += f"{i}. {type_emoji} {priority_text}{symbol} ({direction})\n"
                                    report_content += f"   ðŸ“ {reason}\n"
                                    report_content += f"   ðŸŽ¯ Tin cáº­y: {confidence:.1f}% | Æ¯u tiÃªn: {priority}\n\n"
                                else:
                                    report_content += f"{i}. {type_emoji} {priority_text}{symbol} ({direction})\n"
                                    report_content += f"   ðŸ“ {reason}\n"
                                    report_content += f"   ðŸŽ¯ Confidence: {confidence:.1f}% | Priority: {priority}\n\n"
                
                # 3. Add latest analysis report
                report_files = glob.glob(os.path.join(os.getcwd(), 'analysis_results', '*_report_*.txt'))
                if report_files:
                    # Choose language-appropriate file
                    lang_suffix = '_vi_' if AppState.language() == 'vi' else '_en_'
                    lang_files = [f for f in report_files if lang_suffix in f]
                    
                    if not lang_files:
                        lang_files = report_files  # Fallback to any report
                    
                    # Get most recent file
                    latest_file = max(lang_files, key=os.path.getmtime)
                    
                    with open(latest_file, 'r', encoding='utf-8') as f:
                        analysis_content = f.read()
                    
                    if AppState.language() == 'vi':
                        report_content += "ðŸ“ˆ PHÃ‚N TÃCH Ká»¸ THUáº¬T Má»šI NHáº¤T\n"
                    else:
                        report_content += "ðŸ“ˆ LATEST TECHNICAL ANALYSIS\n"
                    
                    report_content += "=" * 40 + "\n"
                    
                    # Truncate analysis if too long
                    if len(analysis_content) > 1500:
                        analysis_content = analysis_content[:1500] + "..."
                    
                    report_content += analysis_content + "\n\n"
                
                # Add footer
                report_content += self._get_branded_footer(AppState.language())
                
                # Final truncate if still too long
                if len(report_content) > 4000:
                    report_content = report_content[:4000] + "..."
                
                return report_content if report_content.strip() else I18N.t("No analysis data available", "KhÃ´ng cÃ³ dá»¯ liá»‡u phÃ¢n tÃ­ch")
                
            except Exception as e:
                print(f"Error loading comprehensive report: {e}")
                import traceback
                traceback.print_exc()
                return I18N.t("Error loading report", "Lá»—i táº£i bÃ¡o cÃ¡o")
        
        def _auto_setup(self):
            """Launch auto setup wizard"""
            try:
                import subprocess
                result = subprocess.run(['python', 'super_simple_setup.py'], 
                                     capture_output=True, text=True, cwd=os.getcwd())
                if result.returncode == 0:
                    QMessageBox.information(self, I18N.t("Setup Complete", "CÃ i Ä‘áº·t HoÃ n táº¥t"), 
                                          I18N.t("Auto setup completed successfully!\nPlease restart this dialog to see the changes.", 
                                                "CÃ i Ä‘áº·t tá»± Ä‘á»™ng hoÃ n táº¥t thÃ nh cÃ´ng!\nVui lÃ²ng khá»Ÿi Ä‘á»™ng láº¡i há»™p thoáº¡i nÃ y Ä‘á»ƒ tháº¥y thay Ä‘á»•i."))
                    self._load_current_config()
                else:
                    QMessageBox.warning(self, I18N.t("Setup Error", "Lá»—i CÃ i Ä‘áº·t"), 
                                      I18N.t("Setup failed:", "CÃ i Ä‘áº·t tháº¥t báº¡i:") + f"\n{result.stderr}")
            except Exception as e:
                QMessageBox.critical(self, I18N.t("Error", "Lá»—i"), 
                                   I18N.t("Failed to launch setup:", "KhÃ´ng thá»ƒ khá»Ÿi cháº¡y cÃ i Ä‘áº·t:") + f" {e}")
        
        def _test_connection(self):
            """Test notification connections"""
            self._save_config()  # Save first
            
            try:
                import subprocess
                result = subprocess.run(['python', 'test_notifications.py'], 
                                     capture_output=True, text=True, cwd=os.getcwd())
                if result.returncode == 0:
                    QMessageBox.information(self, I18N.t("Test Result", "Káº¿t quáº£ Test"), 
                                          I18N.t("Test completed!\nCheck console output for details.", 
                                                "Test hoÃ n thÃ nh!\nKiá»ƒm tra káº¿t quáº£ Ä‘áº§u ra console Ä‘á»ƒ biáº¿t chi tiáº¿t."))
                else:
                    QMessageBox.warning(self, I18N.t("Test Failed", "Test Tháº¥t báº¡i"), 
                                      I18N.t("Test failed:", "Test tháº¥t báº¡i:") + f"\n{result.stderr}")
            except Exception as e:
                QMessageBox.critical(self, I18N.t("Error", "Lá»—i"), 
                                   I18N.t("Failed to test:", "KhÃ´ng thá»ƒ test:") + f" {e}")
        
        def _update_preview(self):
            """Update message preview"""
            try:
                if self.signal_radio.isChecked():
                    # Show latest signal preview with format based on APP language setting (not config)
                    config = self._get_current_config_for_preview()
                    # ðŸ”§ FIX: Use AppState.language() instead of config for UI language sync
                    is_vietnamese = AppState.language() == 'vi'
                    
                    if is_vietnamese:
                        preview_text = "ðŸš¨ Lá»†NH ÄÃƒ THá»°C HIá»†N\n"
                        preview_text += "â° Thá»i gian: 18:30:45\n"
                        preview_text += "ðŸ“Š Cáº·p tiá»n: XAUUSD\n"
                        preview_text += "ðŸ“ˆ HÆ°á»›ng: MUA\n"
                        preview_text += "ðŸŽ¯ Äá»™ tin cáº­y: 75%\n"
                        preview_text += "ðŸ’° GiÃ¡ vÃ o: 2650.00000\n"
                        preview_text += "ðŸ”¢ Khá»‘i lÆ°á»£ng: 0.10 lots\n"
                        preview_text += "ðŸ·ï¸ Loáº¡i lá»‡nh: TÃ­n hiá»‡u vÃ o lá»‡nh\n"
                        preview_text += "ðŸ›¡ï¸ Cáº¯t lá»—: 2640.00000\n"
                        preview_text += "ðŸŽ¯ Chá»‘t lá»i: 2665.00000\n"
                        preview_text += "ðŸŽ« MÃ£ lá»‡nh: #12345678\n\n"
                    else:
                        preview_text = "ðŸš¨ ORDER EXECUTED\n"
                        preview_text += "â° Time: 18:30:45\n"
                        preview_text += "ðŸ“Š Symbol: XAUUSD\n"
                        preview_text += "ðŸ“ˆ Direction: BUY\n"
                        preview_text += "ðŸŽ¯ Confidence: 75%\n"
                        preview_text += "ðŸ’° Entry Price: 2650.00000\n"
                        preview_text += "ðŸ”¢ Volume: 0.10 lots\n"
                        preview_text += "ðŸ·ï¸ Order Type: Entry Signal\n"
                        preview_text += "ðŸ›¡ï¸ Stop Loss: 2640.00000\n"
                        preview_text += "ðŸŽ¯ Take Profit: 2665.00000\n"
                        preview_text += "ðŸŽ« Ticket: #12345678\n\n"
                    
                    # Add analysis sections based on current settings and language
                    if config.get('settings', {}).get('include_technical', False):
                        if is_vietnamese:
                            preview_text += "ðŸ” PHÃ‚N TÃCH Ká»¸ THUáº¬T:\n"
                            preview_text += "  - Xu hÆ°á»›ng: tÄƒng (H4)\n"
                            preview_text += "  - VÃ¹ng há»— trá»£: 2640.50 (H4)\n"
                            preview_text += "  - VÃ¹ng khÃ¡ng cá»±: 2670.20 (H4)\n\n"
                        else:
                            preview_text += "ðŸ” TECHNICAL ANALYSIS:\n"
                            preview_text += "  - Trend: upward (H4)\n"
                            preview_text += "  - Support zone: 2640.50 (H4)\n"
                            preview_text += "  - Resistance zone: 2670.20 (H4)\n\n"
                    
                    if config.get('settings', {}).get('include_indicators', False):
                        if is_vietnamese:
                            preview_text += "ðŸ“ˆ CHá»ˆ BÃO Ká»¸ THUáº¬T:\n"
                            preview_text += "        â€¢ EMA20: giÃ¡ cao hÆ¡n EMA20 (tÃ­ch cá»±c)\n"
                            preview_text += "        â€¢ RSI: 65.4 - gáº§n vÃ¹ng quÃ¡ mua\n\n"
                        else:
                            preview_text += "ðŸ“ˆ TECHNICAL INDICATORS:\n"
                            preview_text += "        â€¢ EMA20: price above EMA20 (positive)\n"
                            preview_text += "        â€¢ RSI: 65.4 - near overbought zone\n\n"
                    
                    if config.get('settings', {}).get('include_summary', False):
                        if is_vietnamese:
                            preview_text += "ðŸ“‹ TÃ“M Táº®T:\n"
                            preview_text += "  - Äá»™ há»™i tá»¥ chá»‰ bÃ¡o: á»¦ng há»™ BUY 3 | SELL 0\n"
                            preview_text += "  - Biáº¿n Ä‘á»™ng: 15.2 pips\n\n"
                        else:
                            preview_text += "ðŸ“‹ SUMMARY:\n"
                            preview_text += "  - Indicator consensus: Support BUY 3 | SELL 0\n"
                            preview_text += "  - Volatility: 15.2 pips\n\n"
                    
                    if config.get('settings', {}).get('include_price_patterns', False):
                        if is_vietnamese:
                            preview_text += "ðŸ’¹ MÃ” HÃŒNH GIÃ:\n"
                            preview_text += "        â€¢ bullish flag â†‘ (H1) â€“ Tiáº¿p diá»…n tÄƒng â€“ 75% (cao)\n"
                            preview_text += "        â€¢ ascending triangle â†‘ (H4) â€“ Breakout â€“ 70% (cao)\n\n"
                        else:
                            preview_text += "ðŸ’¹ PRICE PATTERNS:\n"
                            preview_text += "        â€¢ bullish flag â†‘ (H1) â€“ Continuation upward â€“ 75% (high)\n"
                            preview_text += "        â€¢ ascending triangle â†‘ (H4) â€“ Breakout â€“ 70% (high)\n\n"
                    
                    if config.get('settings', {}).get('include_candlestick', False):
                        if is_vietnamese:
                            preview_text += "ðŸ•¯ï¸ MÃ” HÃŒNH Náº¾N:\n"
                            preview_text += "        â€¢ hammer â†‘ (M15) â€“ Äáº£o chiá»u tÄƒng â€“ 80% (cao)\n"
                            preview_text += "        â€¢ bullish engulfing â†‘ (M30) â€“ XÃ¡c nháº­n tÄƒng â€“ 75% (cao)\n\n"
                        else:
                            preview_text += "ðŸ•¯ï¸ CANDLESTICK PATTERNS:\n"
                            preview_text += "        â€¢ hammer â†‘ (M15) â€“ Reversal upward â€“ 80% (high)\n"
                            preview_text += "        â€¢ bullish engulfing â†‘ (M30) â€“ Bullish confirmation â€“ 75% (high)\n\n"
                    
                    # Add custom message if enabled
                    if (config.get('settings', {}).get('send_custom_message', False) and 
                        hasattr(self, 'custom_message')):
                        custom_text = self.custom_message.toPlainText().strip()
                        if custom_text:
                            # Add custom message content directly without header
                            preview_text += f"{custom_text}\n\n"
                    
                    # Add footer at the end
                    preview_text += self._get_branded_footer()
                
                elif self.custom_radio.isChecked():
                    custom_text = self.custom_message.toPlainText()
                    if custom_text.strip():
                        preview_text = custom_text
                    else:
                        preview_text = I18N.t("Enter your custom message above...", "Nháº­p tin nháº¯n tÃ¹y chá»‰nh á»Ÿ trÃªn...")
                else:
                    preview_text = I18N.t("Select message type above...", "Chá»n loáº¡i tin nháº¯n á»Ÿ trÃªn...")
                
                self.preview_area.setPlainText(preview_text)
                
            except Exception as e:
                self.preview_area.setPlainText(f"Preview error: {e}")
        
        def _get_current_config_for_preview(self):
            """Get current GUI settings for preview"""
            try:
                # Try to read from config file first
                import json
                import os
                config_path = 'notification_config.json'
                if os.path.exists(config_path):
                    with open(config_path, 'r', encoding='utf-8') as f:
                        config = json.load(f)
                        return config
                
                # Fallback to GUI state
                return {
                    'settings': {
                        'format_vietnamese': getattr(self, 'vietnamese_rb', QCheckBox()).isChecked() if hasattr(self, 'vietnamese_rb') else True,
                        'include_technical': getattr(self, 'include_technical_cb', QCheckBox()).isChecked() if hasattr(self, 'include_technical_cb') else True,
                        'include_indicators': getattr(self, 'include_indicators_cb', QCheckBox()).isChecked() if hasattr(self, 'include_indicators_cb') else False,
                        'include_summary': getattr(self, 'include_summary_cb', QCheckBox()).isChecked() if hasattr(self, 'include_summary_cb') else True,
                        'include_candlestick': getattr(self, 'include_candlestick_cb', QCheckBox()).isChecked() if hasattr(self, 'include_candlestick_cb') else False,
                        'include_price_patterns': getattr(self, 'include_price_patterns_cb', QCheckBox()).isChecked() if hasattr(self, 'include_price_patterns_cb') else False,
                        'send_custom_message': getattr(self, 'send_custom_message', QCheckBox()).isChecked() if hasattr(self, 'send_custom_message') else False,
                    }
                }
            except:
                return {'settings': {}}
        
        def _send_notification(self):
            """Send notification now"""
            try:
                # Save config first
                if not self._save_config():
                    return
                
                # Import notification service
                try:
                    from unified_notification_system import UnifiedNotificationSystem
                except ImportError:
                    QMessageBox.critical(self, I18N.t("Error", "Lá»—i"), 
                                       I18N.t("Notification service not found!\nPlease ensure notification_service.py exists.", 
                                             "KhÃ´ng tÃ¬m tháº¥y dá»‹ch vá»¥ thÃ´ng bÃ¡o!\nVui lÃ²ng Ä‘áº£m báº£o notification_service.py tá»“n táº¡i."))
                    return
                
                notification_service = UnifiedNotificationSystem()
                
                # Prepare message
                if self.signal_radio.isChecked():
                    # REMOVED: Duplicate notification system
                    QMessageBox.information(self, I18N.t("Auto Notifications", "ThÃ´ng bÃ¡o Tá»± Ä‘á»™ng"), 
                                          I18N.t("ðŸ”” AUTO NOTIFICATION ENABLED!\n\n"
                                                "âœ… System will automatically send notifications when orders are executed\n"
                                                "ðŸ“± You don't need to send manually anymore\n\n"
                                                "ðŸ’¡ Notification format can be adjusted in settings below",
                                                "ðŸ”” THÃ”NG BÃO Tá»° Äá»˜NG ÄÃƒ Báº¬T!\n\n"
                                                "âœ… Há»‡ thá»‘ng sáº½ tá»± Ä‘á»™ng gá»­i thÃ´ng bÃ¡o khi cÃ³ lá»‡nh thá»±c thi\n"
                                                "ðŸ“± Báº¡n khÃ´ng cáº§n gá»­i thá»§ cÃ´ng ná»¯a\n\n"
                                                "ðŸ’¡ Format thÃ´ng bÃ¡o Ä‘Æ°á»£c Ä‘iá»u chá»‰nh qua cÃ i Ä‘áº·t bÃªn dÆ°á»›i"))
                
                elif self.custom_radio.isChecked():
                    # Send custom message
                    custom_text = self.custom_message.toPlainText().strip()
                    if custom_text:
                        success_telegram = False
                        success_zalo = False
                        
                        if self.telegram_cb.isChecked():
                            success_telegram = notification_service.send_telegram_message(custom_text)
                        
                        if self.zalo_cb.isChecked():
                            success_zalo = notification_service.send_zalo_message(custom_text)
                        
                        if success_telegram or success_zalo:
                            platforms = []
                            if success_telegram: platforms.append("Telegram")
                            if success_zalo: platforms.append("Zalo")
                            QMessageBox.information(self, I18N.t("Success", "ThÃ nh cÃ´ng"), 
                                                  I18N.t("Custom message sent successfully to: {platforms}", 
                                                        "Tin nháº¯n tÃ¹y chá»‰nh Ä‘Ã£ gá»­i thÃ nh cÃ´ng tá»›i: {platforms}", platforms=', '.join(platforms)))
                        else:
                            QMessageBox.warning(self, I18N.t("Failed", "Tháº¥t báº¡i"), 
                                              I18N.t("Failed to send custom message.", "Gá»­i tin nháº¯n tÃ¹y chá»‰nh tháº¥t báº¡i."))
                    else:
                        QMessageBox.warning(self, I18N.t("Empty Message", "Tin nháº¯n trá»‘ng"), 
                                          I18N.t("Please enter a custom message.", "Vui lÃ²ng nháº­p tin nháº¯n tÃ¹y chá»‰nh."))
                else:
                    QMessageBox.warning(self, I18N.t("No Selection", "ChÆ°a chá»n"), 
                                      I18N.t("Please select a message type.", "Vui lÃ²ng chá»n loáº¡i tin nháº¯n."))
                
            except Exception as e:
                QMessageBox.critical(self, I18N.t("Error", "Lá»—i"), 
                                   I18N.t("Failed to send notification:", "KhÃ´ng thá»ƒ gá»­i thÃ´ng bÃ¡o:") + f" {e}")
        
        def _get_latest_signals(self):
            """Get executed orders instead of all scanned signals to prevent spam"""
            try:
                # Try to get executed orders from order executor
                from order_executor import get_global_executor_instance
                
                executor = get_global_executor_instance()
                if not executor or not hasattr(executor, 'executed_orders'):
                    print("âš ï¸ No order executor or executed orders found")
                    return None
                
                # Get recent executed orders (last hour to avoid spam)
                from datetime import datetime, timedelta
                current_time = datetime.now()
                recent_threshold = current_time - timedelta(hours=1)
                
                recent_executed = []
                for order_data in executor.executed_orders:
                    if order_data.get('timestamp', datetime.min) > recent_threshold:
                        # Convert executed order to signal-like format
                        signal_info = order_data.get('signal', {})
                        result_info = order_data.get('result')
                        
                        if result_info and hasattr(result_info, 'order'):
                            executed_signal = {
                                'symbol': signal_info.get('symbol', 'Unknown'),
                                'signal': signal_info.get('action', 'Unknown'),
                                'confidence': signal_info.get('confidence', 0),
                                'entry_price': result_info.price if hasattr(result_info, 'price') else 0,
                                'volume': result_info.volume if hasattr(result_info, 'volume') else 0,
                                'ticket': result_info.order if hasattr(result_info, 'order') else 0,
                                'executed_at': order_data.get('timestamp', current_time).strftime('%Y-%m-%d %H:%M:%S'),
                                'is_executed': True  # Mark as executed order
                            }
                            recent_executed.append(executed_signal)
                
                if recent_executed:
                    print(f"âœ… Found {len(recent_executed)} recently executed orders")
                    return recent_executed
                else:
                    print("ðŸ“Š No recently executed orders to send")
                    return None
                    
            except Exception as e:
                print(f"âŒ Error getting executed orders: {e}")
                # Fallback to analysis reports if order executor fails
                try:
                    import json
                    import glob
                    
                    # Look for account position actions (executed trades)
                    actions_file = os.path.join(os.getcwd(), 'analysis_results', 'account_positions_actions.json')
                    if os.path.exists(actions_file):
                        print("ðŸ“‚ Reading executed actions from account_positions_actions.json")
                        with open(actions_file, 'r', encoding='utf-8') as f:
                            actions_data = json.load(f)
                        
                        # Filter recent actions
                        if isinstance(actions_data, list) and actions_data:
                            print(f"âœ… Found {len(actions_data)} account actions")
                            return actions_data[:5]  # Return last 5 actions
                    
                    print("âš ï¸ No executed orders or actions found")
                    return None
                    
                except Exception as fallback_e:
                    print(f"âŒ Fallback error: {fallback_e}")
                    import traceback
                    traceback.print_exc()
                    return None

    class SignalTab(QWidget):
        def __init__(self, parent: Optional[QWidget] = None, indicator_tab: Optional[QWidget] = None, market_tab: Optional[QWidget] = None):
            super().__init__(parent)
            # Reference to IndicatorTab so we can persist the latest whitelist before running aggregator
            self.indicator_tab = indicator_tab
            # Reference to MarketTab so we can get selected timeframes
            self.market_tab = market_tab
            self.thread: Optional[RunAggregatorWorker] = None
            self._build_ui()
            # Apply initial language to visible texts
            try:
                self.retranslate_ui()
            except Exception:
                pass
            # ðŸ†• Load saved confidence threshold from risk_settings
            self._load_signal_confidence_threshold()
            self.load_latest_signals()

        def cleanup_thread(self):
            """Enhanced thread cleanup to prevent QThread crash on app close"""
            try:
                if self.thread and self.thread.isRunning():
                    print("[CLEANUP] ðŸ§¹ Gracefully stopping RunAggregatorWorker thread...")
                    
                    # First, try graceful stop
                    self.thread.stop()
                    if self.thread.wait(2000):  # Wait 2 seconds
                        print("[CLEANUP] âœ… Thread stopped gracefully")
                    else:
                        print("[CLEANUP] â° Graceful stop timeout - trying terminate...")
                        
                        # If graceful stop fails, try terminate
                        self.thread.terminate()
                        if self.thread.wait(3000):  # Wait 3 more seconds
                            print("[CLEANUP] âœ… Thread terminated successfully")
                        else:
                            print("[CLEANUP] âŒ Terminate timeout - forcing kill...")
                            # Last resort - force kill (dangerous but prevents hang)
                            try:
                                self.thread.kill()
                                self.thread.wait(1000)  # Give it 1 second to die
                                print("[CLEANUP] âš ï¸ Thread force killed")
                            except Exception as kill_error:
                                print(f"[CLEANUP] âŒ Force kill failed: {kill_error}")
                    
                    self.thread = None
                    print("[CLEANUP] âœ… RunAggregatorWorker cleanup completed")
                else:
                    print("[CLEANUP] ðŸ‘ No running thread to clean up")
                    
            except Exception as e:
                print(f"[CLEANUP] âŒ Error during thread cleanup: {e}")
                # Even if cleanup fails, clear the reference
                self.thread = None
                
            # Stop signal refresh timer
            try:
                if hasattr(self, 'signal_refresh_timer'):
                    self.signal_refresh_timer.stop()
                    print("[CLEANUP] âœ… Signal refresh timer stopped")
            except Exception as e:
                print(f"[CLEANUP] âŒ Error stopping signal timer: {e}")

        def _build_indicator_list_for_export(self) -> List[Dict[str, Any]]:
            """Build exporter-compatible indicator_list using IndicatorTab rows.
            Expands MA family (EMA/SMA/WMA/TEMA) if MA-family mode is 'expand'.
            Safe if indicator_tab is missing or rows incomplete.
            """
            indicator_list: List[Dict[str, Any]] = []
            try:
                if not getattr(self, 'indicator_tab', None):
                    print(f"ðŸ” [DEBUG] No indicator_tab found")
                    return indicator_list
                rows = getattr(self.indicator_tab, 'indicator_rows', []) or []
                print(f"ðŸ” [DEBUG] Found {len(rows)} indicator rows")
                # Determine MA-family mode - hardcoded to 'expand'
                mode = 'expand'

                for row in rows:
                    try:
                        combo = row.get("indi_combo")
                        if combo is None:
                            continue
                        indi_label = combo.currentText()
                        # Map label to canonical name using IndicatorTab's helper if available
                        try:
                            indi_name = self.indicator_tab._label_to_name(indi_label)
                        except Exception:
                            indi_name = None
                        if not indi_name:
                            continue

                        params: Dict[str, Any] = {}
                        # Collect parameters similarly to IndicatorTab.export_indicators
                        if indi_name in [
                            "RSI", "ATR", "ADX", "CCI", "WilliamsR", "ROC",
                            "MFI", "Chaikin", "EOM", "ForceIndex", "TRIX", "DPO"
                        ]:
                            if "period_spin" in row and row["period_spin"] is not None:
                                params["period"] = row["period_spin"].value()
                        elif indi_name == "Bollinger Bands":
                            if "window_spin" in row and row["window_spin"] is not None:
                                params["window"] = row["window_spin"].value()
                            if "dev_spin" in row and row["dev_spin"] is not None:
                                params["dev"] = row["dev_spin"].value()
                        elif indi_name == "MA":
                            # For MA, capture period and type; then expand family if needed
                            period = None
                            ma_type = None
                            if "period_spin" in row and row["period_spin"] is not None:
                                period = int(row["period_spin"].value())
                            if "ma_type_combo" in row and row["ma_type_combo"] is not None:
                                ma_type = str(row["ma_type_combo"].currentText()).upper()
                            if not period:
                                continue
                            # exact: only selected type; expand: include all four types
                            ma_types = [ma_type] if (ma_type and mode == 'exact') else ["SMA", "EMA", "WMA", "TEMA"]
                            # Build entries for each required type
                            for mt in ma_types:
                                if mt in ("SMA", "EMA"):
                                    indicator_list.append({
                                        "name": "MA",
                                        "params": {"period": period, "ma_type": mt}
                                    })
                                elif mt == "WMA":
                                    indicator_list.append({
                                        "name": "WMA",
                                        "params": {"period": period}
                                    })
                                elif mt == "TEMA":
                                    indicator_list.append({
                                        "name": "TEMA",
                                        "params": {"period": period}
                                    })
                            continue  # MA handled; skip generic append below
                        elif indi_name == "MACD":
                            for key in ("fast", "slow", "signal"):
                                spin_key = f"{key}_spin"
                                if spin_key in row and row[spin_key] is not None:
                                    params[key] = row[spin_key].value()
                        elif indi_name == "Stochastic":
                            for key in ("period", "smooth"):
                                spin_key = f"{key}_spin"
                                if spin_key in row and row[spin_key] is not None:
                                    params[key] = row[spin_key].value()
                        elif indi_name == "PSAR":
                            if "step_spin" in row and row["step_spin"] is not None:
                                params["step"] = row["step_spin"].value()
                            if "max_step_spin" in row and row["max_step_spin"] is not None:
                                params["max_step"] = row["max_step_spin"].value()
                        elif indi_name == "Donchian":
                            if "window_spin" in row and row["window_spin"] is not None:
                                params["window"] = row["window_spin"].value()
                        elif indi_name == "MassIndex":
                            for key in ("fast", "slow"):
                                spin_key = f"{key}_spin"
                                if spin_key in row and row[spin_key] is not None:
                                    params[key] = row[spin_key].value()
                        elif indi_name == "Vortex":
                            if "period_spin" in row and row["period_spin"] is not None:
                                params["period"] = row["period_spin"].value()
                        elif indi_name == "KST":
                            for key in ("window1", "window2", "window3", "window4", "window_sig"):
                                spin_key = f"{key}_spin"
                                if spin_key in row and row[spin_key] is not None:
                                    params[key] = row[spin_key].value()
                        elif indi_name == "StochRSI":
                            for key in ("period", "smooth1", "smooth2"):
                                spin_key = f"{key}_spin"
                                if spin_key in row and row[spin_key] is not None:
                                    params[key] = row[spin_key].value()
                        elif indi_name == "UltimateOscillator":
                            for key in ("short", "medium", "long"):
                                spin_key = f"{key}_spin"
                                if spin_key in row and row[spin_key] is not None:
                                    params[key] = row[spin_key].value()
                        elif indi_name == "Keltner":
                            if "window_spin" in row and row["window_spin"] is not None:
                                params["window"] = row["window_spin"].value()
                        elif indi_name == "Fibonacci":
                            if "lookback_spin" in row and row["lookback_spin"] is not None:
                                params["lookback"] = row["lookback_spin"].value()
                        elif indi_name == "Ichimoku":
                            for key in ("tenkan", "kijun", "senkou"):
                                spin_key = f"{key}_spin"
                                if spin_key in row and row[spin_key] is not None:
                                    params[key] = row[spin_key].value()
                        elif indi_name == "Envelope":
                            if "period_spin" in row and row["period_spin"] is not None:
                                params["period"] = row["period_spin"].value()
                            if "percent_spin" in row and row["percent_spin"] is not None:
                                params["percent"] = row["percent_spin"].value()

                        # For non-MA indicators, append as-is
                        if indi_name != "MA":
                            indicator_list.append({
                                "name": indi_name,
                                "params": params
                            })
                    except Exception:
                        continue
            except Exception:
                pass
            print(f"ðŸ” [DEBUG] Built indicator_list: {len(indicator_list)} items - {[i['name'] for i in indicator_list]}")
            return indicator_list

        def _run_preexport_for_selection(self) -> None:
            """Run exporter to ensure indicator JSONs include current UI-selected indicators
            for selected symbols/timeframes before aggregator (helps strict mode show TEMA/WMA).
            """
            try:
                if not getattr(self, 'indicator_tab', None):
                    return
                market_tab = getattr(self.indicator_tab, 'market_tab', None)
                if market_tab is None:
                    return
                # Gather selected symbols and timeframes
                symbols = list(getattr(market_tab, 'checked_symbols', []) or [])
                if not symbols:
                    return
                tf_checkboxes = getattr(market_tab, 'tf_checkboxes', {}) or {}
                tf_spinboxes = getattr(market_tab, 'tf_spinboxes', {}) or {}
                selected_tfs: List[tuple[str,int]] = []
                for tf, cb in tf_checkboxes.items():
                    try:
                        if cb.isChecked():
                            cnt = tf_spinboxes[tf].value() if tf in tf_spinboxes else 200
                            selected_tfs.append((tf, cnt))
                    except Exception:
                        continue
                if not selected_tfs:
                    return

                # Build indicator list from UI; expands MA family if needed
                indicator_list = self._build_indicator_list_for_export()
                if not indicator_list:
                    # Fallback: compute a comprehensive set to avoid empty exports
                    indicator_list = [
                        {"name": "MA", "params": {"period": 20, "ma_type": "EMA"}},
                        {"name": "MA", "params": {"period": 50, "ma_type": "EMA"}},
                        {"name": "TEMA", "params": {"period": 20}},
                        {"name": "TEMA", "params": {"period": 50}},
                        {"name": "WMA", "params": {"period": 20}},
                        {"name": "WMA", "params": {"period": 50}},
                        {"name": "RSI", "params": {"period": 14}},
                        {"name": "MACD", "params": {"fast": 12, "slow": 26, "signal": 9}},
                        {"name": "ATR", "params": {"period": 14}},
                        {"name": "Bollinger Bands", "params": {"window": 20, "dev": 2}},
                    ]

                # Import exporter lazily and run synchronously
                try:
                    from mt5_indicator_exporter import export_indicators
                except Exception:
                    return

                # Check if indicator files exist and are recent before exporting
                import time
                current_time = time.time()
                
                for sym in symbols:
                    for tf, cnt in selected_tfs:
                        try:
                            # Check if indicator file exists and is recent (less than 1 hour old)
                            indicator_file = f"indicator_output/{sym}_{tf}_indicators.json"
                            if os.path.exists(indicator_file):
                                file_age = current_time - os.path.getmtime(indicator_file)
                                if file_age < 3600:  # Less than 1 hour old
                                    print(f"â­ï¸ Skipping export for {sym}_{tf} - recent file exists ({file_age/60:.1f}m old)")
                                    continue
                            
                            print(f"ðŸ“Š Pre-exporting indicators for {sym}_{tf}")
                            export_indicators(sym, tf, cnt, indicator_list, skip_cleanup=True)
                        except Exception:
                            continue
            except Exception:
                pass

        def _run_smart_preexport_for_whitelist(self) -> None:
            """Smart pre-export: Only export if whitelist indicators are missing from existing files.
            This ensures comprehensive_aggregator.py has the indicators selected in UI without 
            unnecessarily re-exporting files that already contain the required indicators.
            """
            try:
                if not getattr(self, 'indicator_tab', None):
                    return
                market_tab = getattr(self.indicator_tab, 'market_tab', None)
                if market_tab is None:
                    return
                
                # Get current whitelist tokens
                whitelist_tokens = set(self.indicator_tab._collect_indicator_whitelist_tokens())
                if not whitelist_tokens:
                    print("ðŸ“‹ No indicators selected in whitelist - skipping preexport")
                    return
                
                print(f"ðŸ“‹ Checking whitelist indicators: {', '.join(sorted(whitelist_tokens))}")
                
                # Gather selected symbols and timeframes
                symbols = list(getattr(market_tab, 'checked_symbols', []) or [])
                if not symbols:
                    return
                tf_checkboxes = getattr(market_tab, 'tf_checkboxes', {}) or {}
                tf_spinboxes = getattr(market_tab, 'tf_spinboxes', {}) or {}
                selected_tfs: List[tuple[str,int]] = []
                for tf, cb in tf_checkboxes.items():
                    try:
                        if cb.isChecked():
                            cnt = tf_spinboxes[tf].value() if tf in tf_spinboxes else 200
                            selected_tfs.append((tf, cnt))
                    except Exception:
                        continue
                if not selected_tfs:
                    return
                
                import json
                import time
                current_time = time.time()
                
                # Check each symbol/timeframe file for missing indicators
                files_to_export = []
                for sym in symbols:
                    for tf, cnt in selected_tfs:
                        indicator_file = f"indicator_output/{sym}_{tf}_indicators.json"
                        needs_export = False
                        
                        if not os.path.exists(indicator_file):
                            print(f"ðŸ“Š File missing: {indicator_file}")
                            needs_export = True
                        else:
                            # Check if file is very old (>24 hours) 
                            file_age = current_time - os.path.getmtime(indicator_file)
                            if file_age > 86400:  # 24 hours
                                print(f"â° File too old: {indicator_file} ({file_age/3600:.1f}h)")
                                needs_export = True
                            else:
                                # Check if whitelist indicators are present in file
                                try:
                                    with open(indicator_file, 'r') as f:
                                        data = json.load(f)
                                    
                                    # Get available indicators from file
                                    available_indicators = set()
                                    if isinstance(data, list) and len(data) > 0 and isinstance(data[0], dict):
                                        # List format - get keys from first row
                                        available_indicators = set(key.lower() for key in data[0].keys())
                                    elif isinstance(data, dict):
                                        # Dict format - flatten all keys
                                        for key, value in data.items():
                                            if isinstance(value, (list, dict)):
                                                available_indicators.add(key.lower())
                                    
                                    # Map whitelist tokens to actual indicator patterns in files
                                    def check_indicator_present(token, available):
                                        token = token.lower()
                                        # Direct match
                                        if token in available:
                                            return True
                                        # Pattern matching for complex indicators
                                        if token == 'bollinger' and any(k.startswith('bb_') for k in available):
                                            return True
                                        if token == 'donchian' and any('donchian' in k for k in available):
                                            return True
                                        if token == 'fibonacci' and any('fib_' in k for k in available):
                                            return True
                                        if token == 'ichimoku' and any('ichimoku' in k or 'senkou' in k or 'tenkan' in k or 'kijun' in k for k in available):
                                            return True
                                        if token == 'stochastic' and any('stoch' in k for k in available):
                                            return True
                                        if token.startswith('ema') and any(f'ema{token[3:]}' in k or f'ema_{token[3:]}' in k for k in available):
                                            return True
                                        return False
                                    
                                    # Check which whitelist indicators are missing
                                    missing_indicators = {token for token in whitelist_tokens 
                                                        if not check_indicator_present(token, available_indicators)}
                                    if missing_indicators:
                                        print(f"âŒ Missing indicators in {indicator_file}: {', '.join(missing_indicators)}")
                                        needs_export = True
                                    else:
                                        print(f"âœ… All whitelist indicators present in {indicator_file}")
                                        
                                except Exception as e:
                                    print(f"âš ï¸ Error checking {indicator_file}: {e}")
                                    needs_export = True
                        
                        if needs_export:
                            files_to_export.append((sym, tf, cnt))
                
                # Only export files that need it
                if not files_to_export:
                    print("âœ… All required indicators already present - no export needed")
                    return
                
                print(f"ðŸ“¤ Exporting {len(files_to_export)} files with missing/outdated indicators")
                
                # Build comprehensive indicator list for export
                indicator_list = self._build_indicator_list_for_export()
                if not indicator_list:
                    # Ensure all whitelist indicators are included
                    indicator_list = [
                        {"name": "RSI", "params": {"period": 14}},
                        {"name": "MACD", "params": {"fast": 12, "slow": 26, "signal": 9}},
                        {"name": "ATR", "params": {"period": 14}},
                        {"name": "MA", "params": {"period": 20, "ma_type": "EMA"}},
                        {"name": "MA", "params": {"period": 50, "ma_type": "EMA"}},
                        {"name": "MA", "params": {"period": 100, "ma_type": "EMA"}},
                        {"name": "MA", "params": {"period": 200, "ma_type": "EMA"}},
                        {"name": "Bollinger Bands", "params": {"window": 20, "dev": 2}},
                        {"name": "Donchian Channel", "params": {"window": 20}},
                        {"name": "Stochastic", "params": {"k_period": 14, "d_period": 3}},
                        {"name": "Ichimoku", "params": {"tenkan": 9, "kijun": 26, "senkou": 52}},
                        {"name": "Fibonacci", "params": {}},
                    ]
                
                # Import exporter and run for needed files only
                try:
                    from mt5_indicator_exporter import export_indicators
                    for sym, tf, cnt in files_to_export:
                        try:
                            print(f"ðŸ“Š Exporting whitelist indicators for {sym}_{tf}")
                            export_indicators(sym, tf, cnt, indicator_list, skip_cleanup=True)
                        except Exception as e:
                            print(f"âš ï¸ Export failed for {sym}_{tf}: {e}")
                except ImportError:
                    print("âš ï¸ Could not import mt5_indicator_exporter")
                    
            except Exception as e:
                print(f"âš ï¸ Smart preexport error: {e}")

        def _build_ui(self):
            layout = QVBoxLayout(self)

            self.title_label = QLabel("ðŸ“Š Signal Aggregator")
            self.title_label.setFont(QFont("Segoe UI", 16, QFont.Bold))  # Reduced from 18 to 16
            layout.addWidget(self.title_label)

            # === AI Model Selection Section ===
            ai_section_label = QLabel(I18N.t("ðŸ¤– AI Analysis Settings", "ðŸ¤– CÃ i Ä‘áº·t phÃ¢n tÃ­ch AI"))
            ai_section_label.setStyleSheet("font-size: 13px; font-weight: bold; color: #333; padding: 8px 0;")
            layout.addWidget(ai_section_label)
            
            ai_row = QHBoxLayout()
            self.ai_model_label = QLabel(I18N.t("AI Model:", "MÃ´ hÃ¬nh AI:"))
            self.ai_model_combo = QComboBox()
            self.ai_model_combo.addItems([
                I18N.t("Aggregator (Local)", "Tá»•ng há»£p (Local)"),
                I18N.t("XGBoost AI (Port 5001)", "XGBoost AI (Port 5001)"),
                I18N.t("CNN-LSTM Pro (Port 5002)", "CNN-LSTM Pro (Port 5002)"),
                I18N.t("Transformer Pro (Port 5003)", "Transformer Pro (Port 5003)")
            ])
            self.ai_model_combo.setCurrentIndex(0)
            self.ai_model_combo.currentIndexChanged.connect(self._on_ai_model_changed)
            self.ai_model_combo.setStyleSheet("""
                QComboBox {
                    min-width: 200px;
                    padding: 6px 12px;
                    border: 1px solid #ccc;
                    border-radius: 4px;
                    background-color: white;
                }
            """)
            ai_row.addWidget(self.ai_model_label)
            ai_row.addWidget(self.ai_model_combo)
            ai_row.addStretch()
            layout.addLayout(ai_row)
            
            # === AI Server URL Configuration (for remote AI Server) ===
            self.ai_server_widget = QWidget()
            server_layout = QHBoxLayout(self.ai_server_widget)
            server_layout.setContentsMargins(0, 5, 0, 5)
            server_layout.setSpacing(8)
            
            self.ai_server_url_label = QLabel(I18N.t("ðŸŒ AI Server URL:", "ðŸŒ URL MÃ¡y chá»§ AI:"))
            self.ai_server_url_input = QLineEdit()
            self.ai_server_url_input.setPlaceholderText("http://your-server-ip:8080")
            self.ai_server_url_input.setText(self._load_ai_server_url())
            self.ai_server_url_input.setMinimumWidth(280)
            self.ai_server_url_input.setStyleSheet("""
                QLineEdit {
                    padding: 6px 10px;
                    border: 1px solid #ccc;
                    border-radius: 4px;
                    background-color: white;
                    font-size: 12px;
                }
            """)
            self.ai_server_url_input.textChanged.connect(self._save_ai_server_url)
            
            self.ai_check_btn = QPushButton(I18N.t("ðŸ”„ Check", "ðŸ”„ Kiá»ƒm tra"))
            self.ai_check_btn.setFixedWidth(90)
            self.ai_check_btn.clicked.connect(self._check_ai_server_status)
            self.ai_check_btn.setStyleSheet("""
                QPushButton {
                    background-color: #2196F3;
                    color: white;
                    border: none;
                    border-radius: 4px;
                    padding: 6px 12px;
                    font-weight: bold;
                }
                QPushButton:hover {
                    background-color: #1976D2;
                }
            """)
            
            self.ai_server_status = QLabel("ðŸ”´ Offline")
            self.ai_server_status.setStyleSheet("color: #ff6b6b; font-weight: bold; min-width: 150px;")
            
            server_layout.addWidget(self.ai_server_url_label)
            server_layout.addWidget(self.ai_server_url_input)
            server_layout.addWidget(self.ai_check_btn)
            server_layout.addWidget(self.ai_server_status)
            server_layout.addStretch()
            
            self.ai_server_widget.setVisible(False)  # Hidden by default
            layout.addWidget(self.ai_server_widget)
            
            # Separator after AI settings
            separator = QFrame()
            separator.setFrameShape(QFrame.HLine)
            separator.setStyleSheet("background-color: #ddd;")
            layout.addWidget(separator)

            ctrl = QHBoxLayout()
            self.refresh_btn = QPushButton(I18N.t("ðŸ”„ Refresh", "ðŸ”„ LÃ m má»›i")); self.refresh_btn.clicked.connect(self.load_latest_signals)
            # Min confidence (%) filter
            self.min_conf_spin = QDoubleSpinBox(); self.min_conf_spin.setRange(0.0, 100.0); self.min_conf_spin.setDecimals(1); self.min_conf_spin.setSingleStep(1.0); self.min_conf_spin.setValue(0.0)
            self.min_conf_spin.setToolTip(I18N.t("Filter signals by minimum confidence percentage", "Lá»c tÃ­n hiá»‡u theo má»©c Ä‘á»™ tin cáº­y tá»‘i thiá»ƒu"))
            # ðŸ”§ Auto-save to risk_settings when confidence threshold changes
            self.min_conf_spin.valueChanged.connect(self._save_signal_confidence_threshold)
            # Removed old inline language selector; now controlled from main menu
            self.run_btn = QPushButton(I18N.t("â–¶ï¸ Run Aggregator", "â–¶ï¸ Cháº¡y tá»•ng há»£p")); self.run_btn.clicked.connect(self.on_run)

            ctrl.addWidget(self.refresh_btn)
            ctrl.addSpacing(10)
            self.min_conf_label = QLabel("Min confidence %:"); ctrl.addWidget(self.min_conf_label); ctrl.addWidget(self.min_conf_spin)
            ctrl.addStretch(1)
            ctrl.addWidget(self.run_btn)
            
            # Notification button - ensure space and visibility
            ctrl.addSpacing(10)  # Add spacing before button
            self.notification_btn = QPushButton(I18N.t("ðŸ“± Send Notification", "ðŸ“± Gá»­i thÃ´ng bÃ¡o"))
            self.notification_btn.clicked.connect(self.open_notification_dialog)
            self.notification_btn.setVisible(True)  # Ensure visibility
            self.notification_btn.show()  # Force show
            self.notification_btn.setMinimumWidth(150)  # Set minimum width
            
            # Add keyboard shortcut Ctrl+N for notification dialog
            from PyQt5.QtWidgets import QShortcut
            from PyQt5.QtGui import QKeySequence
            shortcut = QShortcut(QKeySequence("Ctrl+N"), self)
            shortcut.activated.connect(self.open_notification_dialog)
            self.notification_btn.setToolTip("ðŸ“± Open notification dialog (Ctrl+N)")
            
            ctrl.addWidget(self.notification_btn)
            print(f"ðŸ” [BUTTON_DEBUG] Notification button added: visible={self.notification_btn.isVisible()}, size={self.notification_btn.size()}")
            print("âŒ¨ï¸ [SHORTCUT] Ctrl+N shortcut added for notification dialog")
            
            layout.addLayout(ctrl)

            # Force notification button visibility after layout
            def force_button_visibility():
                try:
                    if hasattr(self, 'notification_btn'):
                        self.notification_btn.setVisible(True)
                        self.notification_btn.show()
                        self.notification_btn.raise_()
                        print(f"ðŸ”§ [POST_LAYOUT] Button forced visible: {self.notification_btn.isVisible()}")
                except Exception as e:
                    print(f"âŒ [POST_LAYOUT] Button fix failed: {e}")
            
            # Schedule visibility fix after layout is complete
            from PyQt5.QtCore import QTimer
            QTimer.singleShot(100, force_button_visibility)

            # Signals table
            self.sig_group = QGroupBox("Latest signals")
            sig_layout = QVBoxLayout(self.sig_group)
            self.sig_table = QTableWidget(0, 7)
            self.sig_table.setHorizontalHeaderLabels(["Symbol", "Signal", "Conf %", "Entry", "SL", "TP", "Order"])
            self.sig_table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
            self.sig_table.cellClicked.connect(self.on_signal_clicked)
            sig_layout.addWidget(self.sig_table)
            layout.addWidget(self.sig_group, 2)

            # Report + Actions
            pan = QHBoxLayout()
            self.rep_group = QGroupBox("Report (per symbol)")
            rep_layout = QVBoxLayout(self.rep_group)
            self.report_view = QTextEdit(); self.report_view.setReadOnly(True)
            rep_layout.addWidget(self.report_view)
            pan.addWidget(self.rep_group, 3)

            self.act_group = QGroupBox("Order Status")
            act_layout = QVBoxLayout(self.act_group)
            self.actions_view = QTextEdit(); self.actions_view.setReadOnly(True)
            act_layout.addWidget(self.actions_view)
            # Add refresh button for actions
            self.refresh_actions_btn = QPushButton("ðŸ”„ Refresh Actions")
            self.refresh_actions_btn.clicked.connect(self.load_actions_text)
            act_layout.addWidget(self.refresh_actions_btn)
            pan.addWidget(self.act_group, 2)
            layout.addLayout(pan, 3)

            # Load actions initially
            self.load_actions_text()
            
            # Setup auto-refresh timer for signals AND actions (every 10 seconds)
            self.signal_refresh_timer = QTimer()
            self.signal_refresh_timer.timeout.connect(self.load_latest_signals)
            self.signal_refresh_timer.timeout.connect(self.load_actions_text)  # Also refresh actions
            self.signal_refresh_timer.start(10000)  # Refresh every 10 seconds
            print("âœ… Signal & Actions auto-refresh timer started (10s interval)")

        def retranslate_ui(self):
            """Refresh visible texts based on current AppState language"""
            self.title_label.setText(I18N.t("ðŸ“Š Signal Aggregator", "ðŸ“Š TrÃ¬nh tá»•ng há»£p tÃ­n hiá»‡u"))
            self.refresh_btn.setText(I18N.t("ðŸ”„ Refresh", "ðŸ”„ LÃ m má»›i"))
            self.run_btn.setText(I18N.t("â–¶ï¸ Run Aggregator", "â–¶ï¸ Cháº¡y trÃ¬nh tá»•ng há»£p"))
            self.min_conf_label.setText(I18N.t("Min confidence %:", "% tin cáº­y tá»‘i thiá»ƒu:"))
            self.min_conf_spin.setToolTip(I18N.t("Filter signals by minimum confidence percentage", "Lá»c tÃ­n hiá»‡u theo má»©c Ä‘á»™ tin cáº­y tá»‘i thiá»ƒu"))
            # Removed strict checkbox and MA family selector
            self.notification_btn.setText(I18N.t("ðŸ“± Send Notification", "ðŸ“± Gá»­i thÃ´ng bÃ¡o"))
            self.sig_group.setTitle(I18N.t("Latest signals", "TÃ­n hiá»‡u má»›i nháº¥t"))
            self.sig_table.setHorizontalHeaderLabels([
                I18N.t("Symbol", "MÃ£"),
                I18N.t("Signal", "TÃ­n hiá»‡u"),
                I18N.t("Conf %", "% tin cáº­y"),
                I18N.t("Entry", "GiÃ¡ vÃ o"),
                I18N.t("SL", "SL"),
                I18N.t("TP", "TP"),
                I18N.t("Order", "Lá»‡nh"),
            ])
            self.rep_group.setTitle(I18N.t("Report (per symbol)", "BÃ¡o cÃ¡o (theo mÃ£)"))
            self.act_group.setTitle(I18N.t("Order Status", "Tráº¡ng thÃ¡i lá»‡nh"))
            # Update any 'Order Now' buttons in the table
            rows = self.sig_table.rowCount()
            for r in range(rows):
                w = self.sig_table.cellWidget(r, 6)
                if isinstance(w, QPushButton):
                    w.setText(I18N.t("Order Now", "Äáº·t lá»‡nh ngay"))

        def load_latest_signals(self):
            try:
                out_dir = os.path.join(os.getcwd(), 'analysis_results')
                rows = []
                for fp in glob.glob(os.path.join(out_dir, "*_signal_*.json")):
                    try:
                        with open(fp, 'r', encoding='utf-8') as f:
                            data = json.load(f)
                        sym = data.get('symbol') or os.path.basename(fp).split('_signal_')[0]
                        fi = (data.get('final_signal') or {})
                        rows.append((sym, fi.get('signal'), fi.get('confidence'), fi.get('entry'), fi.get('stoploss'), fi.get('takeprofit')))
                    except Exception:
                        pass
                # Apply min confidence filter
                min_conf = float(self.min_conf_spin.value())
                rows = [r for r in rows if (r[2] or 0) >= min_conf]
                rows.sort(key=lambda r: str(r[0]))
                self.sig_table.setRowCount(len(rows))
                for i, r in enumerate(rows):
                    for j, val in enumerate(r):
                        item = QTableWidgetItem("" if val is None else str(val))
                        if j == 1 and str(val).upper() == 'BUY':
                            item.setForeground(QColor(0,150,0))
                            item.setFont(QFont("Segoe UI", 11, QFont.Bold))  # Reduced from 12 to 11
                        elif j == 1 and str(val).upper() == 'SELL':
                            item.setForeground(QColor(200,0,0))
                            item.setFont(QFont("Segoe UI", 11, QFont.Bold))  # Reduced from 12 to 11
                        self.sig_table.setItem(i, j, item)
                    # Add Order Now button
                    btn = QPushButton("Order Now")
                    sym = r[0]
                    btn.clicked.connect(lambda _, s=sym: self.order_now_for_symbol(s))
                    self.sig_table.setCellWidget(i, 6, btn)
            except Exception as e:
                print(f"[SignalTab] load_latest_signals error: {e}")

        def latest_file(self, pattern: str) -> Optional[str]:
            files = glob.glob(pattern)
            if not files:
                return None
            files.sort(key=lambda p: os.path.getmtime(p), reverse=True)
            return files[0]
            
        def _find_signal_file_smart(self, out_dir: str, trading_symbol: str) -> Optional[str]:
            """Tá»± Ä‘á»™ng tÃ¬m signal file vá»›i smart mapping"""
            
            # 1. Thá»­ trá»±c tiáº¿p vá»›i trading symbol
            fp = self.latest_file(os.path.join(out_dir, f"{trading_symbol}_signal_*.json"))
            if fp:
                return fp
            
            # 2. Normalize symbol Ä‘á»ƒ tÃ¬m base symbol
            base_symbol = self._normalize_symbol_to_base(trading_symbol)
            if base_symbol != trading_symbol:
                fp = self.latest_file(os.path.join(out_dir, f"{base_symbol}_signal_*.json"))
                if fp:
                    print(f"ðŸŽ¯ Found signal using base symbol: {trading_symbol} -> {base_symbol}")
                    return fp
            
            # 3. Thá»­ cÃ¡c variant phá»• biáº¿n cá»§a base symbol
            variants = self._generate_symbol_variants(base_symbol)
            for variant in variants:
                if variant != trading_symbol:  # Skip the original one we already tried
                    fp = self.latest_file(os.path.join(out_dir, f"{variant}_signal_*.json"))
                    if fp:
                        print(f"ðŸŽ¯ Found signal using variant: {trading_symbol} -> {variant}")
                        return fp
            
            # 4. Debug: list available signal files
            try:
                available_files = os.listdir(out_dir) if os.path.exists(out_dir) else []
                signal_files = [f for f in available_files if 'signal' in f and f.endswith('.json')]
                print(f"ðŸ” Available signal files: {signal_files[:10]}")  # First 10
            except Exception as e:
                print(f"ðŸ” Error listing signal files: {e}")
            
            return None
        
        def _normalize_symbol_to_base(self, symbol: str) -> str:
            """Chuáº©n hÃ³a symbol vá» dáº¡ng base (bá» suffix)"""
            import re
            # Remove common broker suffixes
            normalized = symbol.upper()
            normalized = re.sub(r'[._#-][a-z0-9]*$', '', normalized, flags=re.IGNORECASE)
            return normalized
            
        def _generate_symbol_variants(self, base_symbol: str) -> List[str]:
            """Generate cÃ¡c variant cÃ³ thá»ƒ cÃ³ cá»§a symbol"""
            variants = [
                base_symbol,                    # EURUSD
                base_symbol + '.',              # EURUSD.  
                base_symbol + '_m',             # EURUSD_m
                base_symbol + 'm',              # EURUSDm
                base_symbol + '_',              # EURUSD_
                base_symbol.lower(),            # eurusd
                base_symbol.lower() + '.',      # eurusd.
                f"#{base_symbol}",              # #EURUSD
                f"{base_symbol}pro",            # EURUSDpro
                f"{base_symbol}c",              # EURUSDc
                f"{base_symbol}i",              # EURUSDi
            ]
            return variants

        def _save_signal_confidence_threshold(self):
            """ðŸ†• Save Signal confidence threshold to risk_settings.json"""
            try:
                # Get current value from spinbox
                conf_value = float(self.min_conf_spin.value())
                
                # Convert percentage to the 0-10 scale used by order_executor
                # 30% â†’ 3.0, 20% â†’ 2.0, etc.
                conf_scaled = conf_value / 10.0
                
                # Load existing risk settings
                settings_file = "risk_management/risk_settings.json"
                if os.path.exists(settings_file):
                    with open(settings_file, 'r', encoding='utf-8') as f:
                        settings = json.load(f)
                else:
                    settings = {}
                
                # Update confidence threshold
                settings['min_confidence_for_entry'] = conf_scaled
                
                # Add metadata
                settings['saved_timestamp'] = datetime.now().isoformat()
                settings['version'] = '3.0'
                
                # Save back
                os.makedirs("risk_management", exist_ok=True)
                with open(settings_file, 'w', encoding='utf-8') as f:
                    json.dump(settings, f, indent=2, ensure_ascii=False)
                
                print(f"ðŸ’¾ Saved Signal confidence threshold: {conf_value}% â†’ {conf_scaled} (0-10 scale) to risk_settings.json")
                return True
                
            except Exception as e:
                print(f"âŒ Error saving signal confidence threshold: {e}")
                return False

        def _load_signal_confidence_threshold(self):
            """ðŸ†• Load Signal confidence threshold from risk_settings.json on startup"""
            try:
                settings_file = "risk_management/risk_settings.json"
                if os.path.exists(settings_file):
                    with open(settings_file, 'r', encoding='utf-8') as f:
                        settings = json.load(f)
                    
                    # Read min_confidence_for_entry (in 0-10 scale)
                    conf_scaled = settings.get('min_confidence_for_entry', 2.0)
                    
                    # Convert to percentage for GUI (0-100 scale)
                    # 3.0 â†’ 30%, 2.0 â†’ 20%, etc.
                    conf_percentage = conf_scaled * 10.0
                    
                    # Set the spinbox value (blocking signals to avoid immediate save)
                    if hasattr(self, 'min_conf_spin'):
                        # Temporarily disconnect to avoid triggering save during loading
                        try:
                            self.min_conf_spin.valueChanged.disconnect()
                        except:
                            pass
                        
                        self.min_conf_spin.setValue(conf_percentage)
                        
                        # Reconnect the save handler
                        self.min_conf_spin.valueChanged.connect(self._save_signal_confidence_threshold)
                        
                        print(f"ðŸ“‚ Loaded Signal confidence threshold: {conf_scaled} (0-10 scale) â†’ {conf_percentage}% from risk_settings.json")
                    
                    return True
                else:
                    print(f"ðŸ“‚ Risk settings file not found, using default confidence threshold")
                    return False
                    
            except Exception as e:
                print(f"âŒ Error loading signal confidence threshold: {e}")
                return False

        def load_latest_report(self, sym: Optional[str] = None):
            try:
                if not sym:
                    self.report_view.setText("(No symbol)")
                    return
                out_dir = os.path.join(os.getcwd(), 'analysis_results')
                # Pick report by AppState language; fallback to the other
                lang = AppState.language()
                primary = 'en' if lang == 'en' else 'vi'
                secondary = 'vi' if primary == 'en' else 'en'
                fp = (
                    self.latest_file(os.path.join(out_dir, f"{sym}_report_{primary}_*.txt"))
                    or self.latest_file(os.path.join(out_dir, f"{sym}_report_{secondary}_*.txt"))
                )
                if not fp:
                    # try base without _m
                    if sym.endswith('_m'):
                        fp = (
                            self.latest_file(os.path.join(out_dir, f"{sym[:-2]}_report_{primary}_*.txt"))
                            or self.latest_file(os.path.join(out_dir, f"{sym[:-2]}_report_{secondary}_*.txt"))
                        )
                if fp and os.path.exists(fp):
                    with open(fp, 'r', encoding='utf-8') as f:
                        self.report_view.setText(f.read())
                else:
                    self.report_view.setText("(No report for this symbol)")
            except Exception as e:
                self.report_view.setText(f"Failed to load report: {e}")

        def load_actions_text(self):
            try:
                out_dir = os.path.join(os.getcwd(), 'analysis_results')
                # Choose actions file based on language if both exist
                lang = AppState.language()
                cand = [
                    os.path.join(out_dir, 'account_positions_actions_en.txt'),
                    os.path.join(out_dir, 'account_positions_actions_vi.txt')
                ]
                # prefer EN if requested and file exists
                if lang == 'en' and os.path.exists(cand[0]):
                    fp = cand[0]
                else:
                    fp = cand[1]
                if os.path.exists(fp):
                    with open(fp, 'r', encoding='utf-8') as f:
                        txt = f.read()
                        # Minimal on-the-fly translation for header phrase if VI selected but EN preferred
                        if lang == 'en':
                            txt = txt.replace("HÃ nh Ä‘á»™ng Ä‘á» xuáº¥t cho vá»‹ tháº¿:", "Suggested actions for positions:")
                        # ðŸ”§ Force clear and refresh to prevent cache issues
                        self.actions_view.clear()
                        self.actions_view.setText(txt)
                        # ðŸ”§ Force GUI update
                        self.actions_view.repaint()
                        print(f"âœ… Actions loaded from {os.path.basename(fp)} ({len(txt)} chars)")
                else:
                    self.actions_view.setText("(No actions yet â€” run Aggregator)")
            except Exception as e:
                self.actions_view.setText(f"Failed to load actions: {e}")
                print(f"âŒ Error loading actions: {e}")

        @safe_method
        def on_run(self, *args, **kwargs):
            # ========== LICENSE CHECK ==========
            # Kiá»ƒm tra license trÆ°á»›c khi cho phÃ©p cháº¡y phÃ¢n tÃ­ch
            if not check_license_for_service(self, "Signal Analysis"):
                return
            # ========== END LICENSE CHECK ==========
            
            # Handle both button click (with checked param) and direct call (without params)
            checked = args[0] if args else kwargs.get('checked', False)
            if self.thread and self.thread.isRunning():
                QMessageBox.information(
                    self,
                    I18N.t("Running", "Äang cháº¡y"),
                    I18N.t("Analysis is running, please waitâ€¦", "PhÃ¢n tÃ­ch Ä‘ang cháº¡y, vui lÃ²ng chá»â€¦")
                )
                return
            
            # Get selected AI model
            ai_model = self._get_selected_ai_model()
            model_port = self._get_ai_model_port()
            
            # If using AI Server (XGBoost, CNN-LSTM, or Transformer)
            if ai_model != "aggregator":
                self._run_ai_server_analysis(ai_model, model_port)
                return
            
            # Use Local Aggregator (comprehensive_aggregator.py)
            print("ðŸ¤– Running Local Aggregator via comprehensive_aggregator.py")
            
            # Ensure latest UI selections are saved to whitelist before run
            try:
                # Persist from IndicatorTab (source of truth for selected indicators)
                if getattr(self, 'indicator_tab', None) is not None:
                    try:
                        if hasattr(self.indicator_tab, 'save_current_user_config'):
                            self.indicator_tab.save_current_user_config()
                    except Exception as _e:
                        print(f"Could not save indicator tab config before run: {_e}")
                    try:
                        if hasattr(self.indicator_tab, '_persist_indicator_whitelist'):
                            self.indicator_tab._persist_indicator_whitelist()
                    except Exception as _e:
                        print(f"Could not persist whitelist before run: {_e}")
                    # Smart pre-export: Only export if whitelist indicators are missing from existing files
                    try:
                        self._run_smart_preexport_for_whitelist()
                    except Exception as _e:
                        print(f"Smart pre-export failed (will continue to aggregator): {_e}")
                    print("ðŸ”„ Comprehensive aggregator will use existing + updated indicator_output files")
            except Exception as _e:
                print(f"Could not persist whitelist before run: {_e}")
            run_args: List[str] = []
            # Always enforce strict-indicators (was default ON)
            run_args.append("--strict-indicators")
            # MA family handling: use expand mode (WMA excluded to avoid errors)
            run_args.extend(["--ma-family", "expand"])
            # Add verbose for debugging
            run_args.append("--verbose")  # Enable verbose logging
            
            # âœ… Get confidence threshold from GUI
            if hasattr(self, 'min_conf_spin'):
                conf_value = float(self.min_conf_spin.value())
                if conf_value > 0:
                    run_args.extend(["--conf-strong", str(conf_value)])
                    print(f"ðŸŽ¯ Using confidence threshold from GUI: {conf_value}%")
            
            # Get symbols from Market Tab
            selected_symbols = []
            if hasattr(self, 'market_tab') and self.market_tab:
                selected_symbols = list(getattr(self.market_tab, 'checked_symbols', []) or [])
                print(f"ðŸ” DEBUG: Market tab checked_symbols = {getattr(self.market_tab, 'checked_symbols', 'NOT_FOUND')}")
                
            if selected_symbols:
                # Use selected symbols from GUI
                run_args.extend(["--symbols", ",".join(selected_symbols)])
                print(f"ðŸ“Š Using selected symbols from GUI: {', '.join(selected_symbols)}")
            else:
                # Fallback: limit to 3 symbols for faster testing
                run_args.extend(["--limit", "3"])
                print("âš ï¸ No symbols selected in GUI, using auto-detection with limit 3")
            
            # DISABLED: Let system auto-detect timeframes from pattern files instead of forcing specific ones
            # This fixes the issue where CLI works but GUI fails due to --timeframes parameter
            print("ðŸ”„ Auto-detecting timeframes from available pattern files (for better signal generation)")
            
            # Run for all symbols with current defaults
            print(f"ðŸ”§ DEBUG: Args being passed to comprehensive_aggregator.py: {run_args}")

            self.run_btn.setEnabled(False)
            self.thread = RunAggregatorWorker(run_args)
            self.thread.finished.connect(self._after_run)
            self.thread.start()
        
        def _run_ai_server_analysis(self, model_name: str, port: int):
            """Run analysis using AI Server model (XGBoost, CNN-LSTM, or Transformer)"""
            import requests
            import glob
            
            model_labels = {"xgboost": "XGBoost", "cnn_lstm": "CNN-LSTM Pro", "transformer": "Transformer Pro"}
            model_label = model_labels.get(model_name, model_name)
            
            print(f"ðŸ¤– Running {model_label} AI Server on port {port}")
            
            # Get selected symbols
            selected_symbols = []
            if hasattr(self, 'market_tab') and self.market_tab:
                selected_symbols = list(getattr(self.market_tab, 'checked_symbols', []) or [])
            
            if not selected_symbols:
                QMessageBox.warning(
                    self,
                    I18N.t("No Symbols", "KhÃ´ng cÃ³ mÃ£"),
                    I18N.t("Please select symbols in Market tab first!", "Vui lÃ²ng chá»n mÃ£ trong tab Market trÆ°á»›c!")
                )
                return
            
            # ðŸ”§ FIX: Clean up ALL old files in analysis_results BEFORE running AI model
            # This prevents accumulation of old signal/report files
            print(f"ðŸ—‘ï¸ Cleaning up old analysis files for {len(selected_symbols)} symbols...")
            deleted_count = 0
            for symbol in selected_symbols:
                # Delete old signal files
                old_signals = glob.glob(f"analysis_results/{symbol}_signal_*.json")
                for f in old_signals:
                    try:
                        os.remove(f)
                        deleted_count += 1
                    except: pass
                
                # Delete old report files (English + Vietnamese)
                old_reports_en = glob.glob(f"analysis_results/{symbol}_report_en_*.txt")
                old_reports_vi = glob.glob(f"analysis_results/{symbol}_report_vi_*.txt")
                for f in old_reports_en + old_reports_vi:
                    try:
                        os.remove(f)
                        deleted_count += 1
                    except: pass
            
            if deleted_count > 0:
                print(f"ðŸ—‘ï¸ Deleted {deleted_count} old analysis files")
            
            # Check server connection
            server_url = f"http://localhost:{port}"
            try:
                health_resp = requests.get(f"{server_url}/health", timeout=5)
                if health_resp.status_code != 200:
                    # ðŸ”§ FIX: Ask user if they want to fallback to aggregator
                    reply = QMessageBox.question(
                        self,
                        I18N.t("Server Error", "Lá»—i Server"),
                        I18N.t(f"{model_label} server not responding on port {port}!\n\nDo you want to use Aggregator instead?",
                               f"Server {model_label} khÃ´ng pháº£n há»“i trÃªn port {port}!\n\nBáº¡n cÃ³ muá»‘n dÃ¹ng Aggregator thay tháº¿?"),
                        QMessageBox.Yes | QMessageBox.No
                    )
                    if reply == QMessageBox.Yes:
                        # Switch to aggregator mode
                        self.ai_model_combo.setCurrentIndex(0)  # Select Aggregator
                        self.on_run()  # Re-run with aggregator
                    return
            except requests.exceptions.ConnectionError:
                # ðŸ”§ FIX: Ask user if they want to fallback to aggregator
                reply = QMessageBox.question(
                    self,
                    I18N.t("Connection Error", "Lá»—i Káº¿t ná»‘i"),
                    I18N.t(f"Cannot connect to {model_label} server on port {port}!\n\nDo you want to use Aggregator instead?",
                           f"KhÃ´ng thá»ƒ káº¿t ná»‘i Ä‘áº¿n server {model_label} trÃªn port {port}!\n\nBáº¡n cÃ³ muá»‘n dÃ¹ng Aggregator thay tháº¿?"),
                    QMessageBox.Yes | QMessageBox.No
                )
                if reply == QMessageBox.Yes:
                    # Switch to aggregator mode
                    self.ai_model_combo.setCurrentIndex(0)  # Select Aggregator
                    self.on_run()  # Re-run with aggregator
                return
            
            self.run_btn.setEnabled(False)
            
            # Run analysis for each symbol
            results = []
            for symbol in selected_symbols:
                try:
                    # ðŸ”§ FIX: Load ALL required data for AI model (46 features)
                    payload = self._build_ai_payload(symbol)
                    
                    if payload:
                        # Send to AI server
                        resp = requests.post(f"{server_url}/predict", json=payload, timeout=30)
                        if resp.status_code == 200:
                            result = resp.json()
                            results.append({
                                "symbol": symbol,
                                "signal": result.get("signal", "HOLD"),
                                "confidence": result.get("confidence", 0),
                                "model": model_label
                            })
                            print(f"âœ… {symbol}: {result.get('signal')} ({result.get('confidence'):.1f}%)")
                        else:
                            print(f"âŒ {symbol}: Server error {resp.status_code}")
                    else:
                        print(f"âš ï¸ {symbol}: No indicator data found")
                        
                except Exception as e:
                    print(f"âŒ {symbol} error: {e}")
            
            # Save results to analysis_results
            if results:
                # Files already cleaned at the start, just save new ones
                timestamp_str = datetime.now().strftime('%Y%m%d_%H%M%S')
                
                for result in results:
                    symbol = result['symbol']
                    
                    # ðŸ”§ Build comprehensive signal data with Entry/SL/TP
                    signal_data = self._build_signal_data_for_report(symbol, result, model_label)
                    
                    # Save signal JSON file
                    signal_file = f"analysis_results/{symbol}_signal_{timestamp_str}.json"
                    with open(signal_file, 'w', encoding='utf-8') as f:
                        json.dump(signal_data, f, indent=2, ensure_ascii=False)
                    
                    # ðŸ“ Generate reports (EN and VI)
                    self._generate_ai_report(symbol, signal_data, timestamp_str)
                
                # ðŸ“Š Generate position actions (xá»­ lÃ½ lá»‡nh tráº¡ng thÃ¡i)
                self._generate_ai_position_actions(results, model_label)
                
                print(f"âœ… {model_label} analysis completed: {len(results)} symbols")
                print(f"ðŸ“ Reports and position actions saved to analysis_results/")
            else:
                print(f"âŒ {model_label} analysis: no results")
            
            self.run_btn.setEnabled(True)
            self.load_latest_signals()

        def _build_ai_payload(self, symbol: str) -> dict:
            """Build complete payload with all features for AI model based on UI settings"""
            import glob
            from datetime import datetime
            
            payload = {"symbol": symbol, "indicators": {}, "patterns": {}, 
                       "support_resistance": {}, "sideway_analysis": {}, "news_analysis": {}}
            
            def load_latest_from_file(filepath):
                """Load latest data from JSON file"""
                if os.path.exists(filepath):
                    try:
                        with open(filepath, 'r', encoding='utf-8') as f:
                            data = json.load(f)
                        if isinstance(data, list) and len(data) > 0:
                            return data[-1]
                        return data
                    except Exception as e:
                        print(f"âš ï¸ Error loading {filepath}: {e}")
                return {}
            
            # ðŸ”§ Get selected timeframes from UI (IndicatorTab)
            selected_timeframes = ["M15", "M30", "H1"]  # Default
            if hasattr(self, 'indicator_tab') and self.indicator_tab:
                if hasattr(self.indicator_tab, 'tf_checkboxes'):
                    selected_timeframes = [tf for tf, cb in self.indicator_tab.tf_checkboxes.items() if cb.isChecked()]
                elif hasattr(self.indicator_tab, 'selected_timeframes'):
                    selected_timeframes = self.indicator_tab.selected_timeframes
            
            print(f"ðŸ“Š [{symbol}] Loading indicators for timeframes: {selected_timeframes}")
            
            # 1. Load indicators for selected timeframes only
            m15_data = {}
            h1_data = {}
            for tf in selected_timeframes:
                indicator_file = f"indicator_output/{symbol}_{tf}_indicators.json"
                tf_data = load_latest_from_file(indicator_file)
                if tf_data:
                    payload["indicators"][tf] = tf_data
                    print(f"   âœ… {tf}: {len(tf_data)} fields")
                    # Keep reference for calculations
                    if tf == "M15":
                        m15_data = tf_data
                    elif tf == "H1":
                        h1_data = tf_data
                else:
                    print(f"   âŒ {tf}: NOT FOUND")
            
            # Use first available data for calculations
            if not m15_data and payload["indicators"]:
                m15_data = list(payload["indicators"].values())[0]
            if not h1_data and len(payload["indicators"]) > 1:
                h1_data = list(payload["indicators"].values())[1]
            
            # 2. Load pattern signals (candle + price patterns from pattern_signals folder)
            # Only load patterns for selected timeframes
            all_patterns = []
            for tf in selected_timeframes:
                pattern_file = f"pattern_signals/{symbol}_{tf}_priority_patterns.json"
                if os.path.exists(pattern_file):
                    pdata = load_latest_from_file(pattern_file)
                    if isinstance(pdata, list):
                        all_patterns.extend(pdata)
                    elif pdata:
                        all_patterns.append(pdata)
            
            if all_patterns:
                candle_types = ["doji", "hammer", "engulfing", "harami", "morning_star", "evening_star", 
                               "shooting_star", "spinning_top", "marubozu", "kicker", "piercing", "dark_cloud"]
                
                candle_bullish = candle_bearish = price_bullish = price_bearish = 0
                total_score = total_confidence = 0
                
                for p in all_patterns:
                    ptype = p.get("type", "").lower()
                    signal = p.get("signal", "").lower()
                    score = p.get("score", 0)
                    confidence = p.get("confidence", 0.5)
                    
                    total_score += score
                    total_confidence += confidence
                    
                    is_candle = any(ct in ptype for ct in candle_types)
                    is_bullish = "bull" in ptype or signal == "buy" or score > 0
                    is_bearish = "bear" in ptype or signal == "sell" or score < 0
                    
                    if is_candle:
                        if is_bullish: candle_bullish += 1
                        elif is_bearish: candle_bearish += 1
                    else:
                        if is_bullish: price_bullish += 1
                        elif is_bearish: price_bearish += 1
                
                payload["patterns"] = {
                    "candle_bullish": candle_bullish,
                    "candle_bearish": candle_bearish,
                    "candle_score": total_score / len(all_patterns) if all_patterns else 0,
                    "price_bullish": price_bullish,
                    "price_bearish": price_bearish,
                    "price_confidence": total_confidence / len(all_patterns) if all_patterns else 0.5,
                    "overall_bias": 1 if total_score > 0 else (-1 if total_score < 0 else 0),
                    "momentum_score": total_score / len(all_patterns) if all_patterns else 0
                }
                print(f"   ðŸ•¯ï¸ Patterns: {len(all_patterns)} (candle: {candle_bullish}â†‘/{candle_bearish}â†“, price: {price_bullish}â†‘/{price_bearish}â†“)")
            
            # 3. Load support/resistance from trendline_sr (for selected timeframes)
            for tf in selected_timeframes:
                sr_file = f"trendline_sr/{symbol}_{tf}_trendline_sr.json"
                if os.path.exists(sr_file):
                    sr_data = load_latest_from_file(sr_file)
                    if sr_data:
                        close_price = float(m15_data.get("close", h1_data.get("close", 0)) or 0)
                        supports = [float(x) for x in sr_data.get("support_levels", []) if x]
                        resistances = [float(x) for x in sr_data.get("resistance_levels", []) if x]
                        
                        if supports and close_price:
                            nearest_support = min(supports, key=lambda x: abs(x - close_price))
                            payload["support_resistance"]["distance_to_support"] = (close_price - nearest_support) / close_price * 100
                        
                        if resistances and close_price:
                            nearest_resistance = min(resistances, key=lambda x: abs(x - close_price))
                            payload["support_resistance"]["distance_to_resistance"] = (nearest_resistance - close_price) / close_price * 100
                        
                        if supports and resistances:
                            payload["support_resistance"]["sr_ratio"] = len(supports) / (len(supports) + len(resistances))
                        
                        payload["support_resistance"]["trend_strength"] = sr_data.get("trend_strength", 0)
                        payload["sideway_analysis"]["trend_direction"] = 1 if sr_data.get("trend_direction") == "Up" else (-1 if sr_data.get("trend_direction") == "Down" else 0)
                        payload["sideway_analysis"]["is_sideway"] = 1 if sr_data.get("trend_direction") == "Sideway" else 0
                        print(f"   ðŸ“ S/R ({tf}): {len(supports)}S/{len(resistances)}R, Trend: {sr_data.get('trend_direction')}")
                        break  # Use first found SR data
            
            # 4. Calculate position in range using BB
            if m15_data:
                bb_upper = float(m15_data.get("BBU_20_2.0", m15_data.get("bb_upper", 0)) or 0)
                bb_lower = float(m15_data.get("BBL_20_2.0", m15_data.get("bb_lower", 0)) or 0)
                close = float(m15_data.get("close", 0) or 0)
                if bb_upper > bb_lower and close:
                    payload["sideway_analysis"]["position_in_range"] = (close - bb_lower) / (bb_upper - bb_lower)
            
            # 5. Load news sentiment from recent_news_with_actual (only published news)
            payload["news_analysis"] = self._get_news_sentiment_for_symbol(symbol)
            
            # Check if we have minimum data
            if not payload["indicators"]:
                print(f"âš ï¸ {symbol}: No indicator data found!")
                return None
            
            return payload

        def _get_news_sentiment_for_symbol(self, symbol: str) -> dict:
            """
            Get news sentiment for a symbol by checking relevant currency news.
            Maps symbol to currency pairs and calculates sentiment from recent news.
            """
            import glob
            from datetime import datetime, timedelta
            
            result = {"sentiment": 0, "impact": 0, "news_count": 0}
            
            # Map symbol to relevant currencies
            symbol_upper = symbol.upper().replace(".", "").replace("_M", "").replace("_", "")
            currency_map = {
                "XAUUSD": ["USD", "XAU", "GOLD"],
                "EURUSD": ["EUR", "USD"],
                "GBPUSD": ["GBP", "USD"],
                "USDJPY": ["USD", "JPY"],
                "AUDUSD": ["AUD", "USD"],
                "USDCAD": ["USD", "CAD"],
                "USDCHF": ["USD", "CHF"],
                "NZDUSD": ["NZD", "USD"],
                "BTCUSD": ["BTC", "USD", "BITCOIN"],
                "ETHUSD": ["ETH", "USD", "ETHEREUM"],
                "BNBUSD": ["BNB", "USD"],
                "SOLUSD": ["SOL", "USD", "SOLANA"],
                "LTCUSD": ["LTC", "USD", "LITECOIN"],
                "ADAUSD": ["ADA", "USD", "CARDANO"],
            }
            
            relevant_currencies = currency_map.get(symbol_upper, ["USD"])
            
            # ðŸ”§ FIX: First try to load from recent_news_with_actual (only published news with actual values)
            today = datetime.now().strftime("%Y%m%d")
            recent_news_file = f"news_output/recent_news_with_actual_{today}.json"
            
            # Fallback to yesterday if today's file is empty or doesn't exist
            if not os.path.exists(recent_news_file):
                yesterday = (datetime.now() - timedelta(days=1)).strftime("%Y%m%d")
                recent_news_file = f"news_output/recent_news_with_actual_{yesterday}.json"
            
            news_list = []
            
            # Try recent_news_with_actual first (only published news)
            if os.path.exists(recent_news_file):
                try:
                    with open(recent_news_file, 'r', encoding='utf-8') as f:
                        news_list = json.load(f)
                    if news_list:
                        print(f"   ðŸ“° News: Loaded {len(news_list)} published news from recent_news_with_actual")
                except Exception as e:
                    print(f"   âš ï¸ Error loading recent_news: {e}")
            
            # If no recent news, don't fallback to full news file (we only want published news)
            if not news_list:
                print(f"   ðŸ“° News: No published news with actual values found")
                return result
            
            # Filter news for relevant currencies only
            relevant_news = []
            for n in news_list:
                currency = n.get("currency", "").upper()
                if currency in relevant_currencies:
                    relevant_news.append(n)
            
            if not relevant_news:
                print(f"   ðŸ“° News: No news for currencies {relevant_currencies}")
                return result
            
            # Calculate sentiment and impact from published news only
            impact_scores = {"high": 3, "medium": 2, "low": 1}
            total_impact = 0
            sentiment_score = 0
            
            for news in relevant_news:
                impact = news.get("impact", "low").lower()
                impact_value = impact_scores.get(impact, 1)
                total_impact += impact_value
                
                # Check actual vs forecast for sentiment
                actual = news.get("actual", "")
                forecast = news.get("forecast", "")
                previous = news.get("previous", "")
                
                if actual:
                    try:
                        # Clean values (remove %, K, M, B suffixes)
                        def clean_value(val):
                            if not val: return None
                            val = str(val).replace("%", "").replace("K", "000").replace("M", "000000").replace("B", "000000000").strip()
                            return float(val) if val else None
                        
                        actual_clean = clean_value(actual)
                        forecast_clean = clean_value(forecast)
                        previous_clean = clean_value(previous)
                        
                        if actual_clean is not None:
                            # Compare with forecast first, then previous
                            compare_value = forecast_clean if forecast_clean is not None else previous_clean
                            
                            if compare_value is not None:
                                if actual_clean > compare_value:
                                    sentiment_score += impact_value  # Better than expected = positive
                                elif actual_clean < compare_value:
                                    sentiment_score -= impact_value  # Worse than expected = negative
                    except (ValueError, AttributeError, TypeError):
                        pass
            
            # Normalize scores
            max_possible = len(relevant_news) * 3 if relevant_news else 1
            result["sentiment"] = sentiment_score / max_possible  # -1 to 1
            result["impact"] = total_impact / max_possible  # 0 to 1
            result["news_count"] = len(relevant_news)
            
            print(f"   ðŸ“° News: {len(relevant_news)} relevant for {relevant_currencies} (sentiment: {result['sentiment']:.2f}, impact: {result['impact']:.2f})")
            
            return result

        def _build_signal_data_for_report(self, symbol: str, ai_result: dict, ai_model: str) -> dict:
            """Build comprehensive signal data with Entry/SL/TP for report generation"""
            import glob
            
            signal_data = {
                "symbol": symbol,
                "final_signal": {
                    "signal": ai_result.get('signal', 'HOLD'),
                    "confidence": ai_result.get('confidence', 0),
                    "entry": 0,
                    "stoploss": 0,
                    "takeprofit": 0
                },
                "model": ai_model,
                "timestamp": datetime.now().isoformat(),
                "indicators": {},
                "patterns": [],
                "support_resistance": {},
                "news": []
            }
            
            # Load indicators for context
            for tf in ['M15', 'M30', 'H1']:
                ind_file = f"indicator_output/{symbol}_{tf}_indicators.json"
                if os.path.exists(ind_file):
                    try:
                        with open(ind_file, 'r', encoding='utf-8') as f:
                            data = json.load(f)
                            if isinstance(data, list) and data:
                                signal_data["indicators"][tf] = data[-1]
                            else:
                                signal_data["indicators"][tf] = data
                    except:
                        pass
            
            # Load patterns
            pattern_files = glob.glob(f"pattern_signals/{symbol}_*_priority_patterns.json")
            for pf in pattern_files:
                try:
                    with open(pf, 'r', encoding='utf-8') as f:
                        patterns = json.load(f)
                        if isinstance(patterns, list):
                            signal_data["patterns"].extend(patterns)
                        else:
                            signal_data["patterns"].append(patterns)
                except:
                    pass
            
            # Load S/R
            sr_files = glob.glob(f"trendline_sr/{symbol}_*_trendline_sr.json")
            if sr_files:
                try:
                    with open(sr_files[0], 'r', encoding='utf-8') as f:
                        signal_data["support_resistance"] = json.load(f)
                except:
                    pass
            
            # Calculate entry, SL, TP based on signal and current price
            current_price = 0
            atr = 0
            
            # Get current price and ATR from indicators
            for tf in ['H1', 'M30', 'M15']:
                if tf in signal_data["indicators"]:
                    ind = signal_data["indicators"][tf]
                    if not current_price:
                        current_price = float(ind.get("close", 0) or 0)
                    if not atr:
                        atr = float(ind.get("atr", ind.get("ATR14", ind.get("ATRr_14", 0))) or 0)
            
            if current_price and signal_data["final_signal"]["signal"] != "HOLD":
                if not atr:
                    atr = current_price * 0.001  # Default 0.1% of price
                
                # Determine decimal places based on price
                if current_price > 1000:  # XAUUSD, indices
                    decimals = 2
                elif current_price > 10:  # JPY pairs
                    decimals = 3
                else:  # Most forex pairs
                    decimals = 5
                
                signal_data["final_signal"]["entry"] = round(current_price, decimals)
                
                # Get S/R levels for better SL/TP placement
                sr_data = signal_data.get("support_resistance", {})
                supports = sr_data.get("support_levels", [])
                resistances = sr_data.get("resistance_levels", [])
                
                if signal_data["final_signal"]["signal"] == "BUY":
                    # SL below support or ATR-based
                    if supports:
                        nearest_support = min([s for s in supports if s < current_price], default=None, key=lambda x: current_price - x)
                        if nearest_support:
                            signal_data["final_signal"]["stoploss"] = round(nearest_support - atr * 0.3, decimals)
                        else:
                            signal_data["final_signal"]["stoploss"] = round(current_price - atr * 1.5, decimals)
                    else:
                        signal_data["final_signal"]["stoploss"] = round(current_price - atr * 1.5, decimals)
                    
                    # TP at resistance or ATR-based
                    if resistances:
                        nearest_resistance = min([r for r in resistances if r > current_price], default=None, key=lambda x: x - current_price)
                        if nearest_resistance:
                            signal_data["final_signal"]["takeprofit"] = round(nearest_resistance - atr * 0.2, decimals)
                        else:
                            signal_data["final_signal"]["takeprofit"] = round(current_price + atr * 2.5, decimals)
                    else:
                        signal_data["final_signal"]["takeprofit"] = round(current_price + atr * 2.5, decimals)
                        
                else:  # SELL
                    # SL above resistance or ATR-based
                    if resistances:
                        nearest_resistance = min([r for r in resistances if r > current_price], default=None, key=lambda x: x - current_price)
                        if nearest_resistance:
                            signal_data["final_signal"]["stoploss"] = round(nearest_resistance + atr * 0.3, decimals)
                        else:
                            signal_data["final_signal"]["stoploss"] = round(current_price + atr * 1.5, decimals)
                    else:
                        signal_data["final_signal"]["stoploss"] = round(current_price + atr * 1.5, decimals)
                    
                    # TP at support or ATR-based
                    if supports:
                        nearest_support = min([s for s in supports if s < current_price], default=None, key=lambda x: current_price - x)
                        if nearest_support:
                            signal_data["final_signal"]["takeprofit"] = round(nearest_support + atr * 0.2, decimals)
                        else:
                            signal_data["final_signal"]["takeprofit"] = round(current_price - atr * 2.5, decimals)
                    else:
                        signal_data["final_signal"]["takeprofit"] = round(current_price - atr * 2.5, decimals)
            
            return signal_data

        def _generate_ai_report(self, symbol: str, signal_data: dict, timestamp: str):
            """Generate reports in EN and VI for AI signal - similar to comprehensive_aggregator.py"""
            
            final_signal = signal_data.get('final_signal', {})
            signal = final_signal.get('signal', 'HOLD')
            confidence = final_signal.get('confidence', 0)
            model = signal_data.get('model', 'AI')
            entry = final_signal.get('entry', 0)
            stoploss = final_signal.get('stoploss', 0)
            takeprofit = final_signal.get('takeprofit', 0)
            
            # Get indicator summary
            indicators = signal_data.get('indicators', {})
            h1_data = indicators.get('H1', {})
            m15_data = indicators.get('M15', {})
            
            # Extract key indicators
            rsi_h1 = h1_data.get('rsi', h1_data.get('RSI14', h1_data.get('RSI_14', 'N/A')))
            macd_h1 = h1_data.get('macd', h1_data.get('MACD_12_26_9', h1_data.get('macd_line', 'N/A')))
            adx_h1 = h1_data.get('adx', h1_data.get('ADX14', h1_data.get('ADX_14', 'N/A')))
            ema_h1 = h1_data.get('EMA20', h1_data.get('ema20', h1_data.get('EMA_20', 'N/A')))
            
            # Get patterns summary
            patterns = signal_data.get('patterns', [])
            bullish_patterns = []
            bearish_patterns = []
            for p in patterns:
                ptype = p.get('type', p.get('name', '')).lower()
                psignal = p.get('signal', p.get('direction', '')).lower()
                if 'bull' in ptype or 'bull' in psignal or psignal == 'buy':
                    bullish_patterns.append(p.get('type', p.get('name', 'unknown')))
                elif 'bear' in ptype or 'bear' in psignal or psignal == 'sell':
                    bearish_patterns.append(p.get('type', p.get('name', 'unknown')))
            
            # Get S/R summary
            sr_data = signal_data.get('support_resistance', {})
            supports = sr_data.get('support_levels', [])
            resistances = sr_data.get('resistance_levels', [])
            trend = sr_data.get('trend_direction', 'N/A')
            
            # Calculate Risk/Reward
            risk_reward = 0
            if signal == 'BUY' and entry and stoploss and takeprofit and entry != stoploss:
                risk = entry - stoploss
                reward = takeprofit - entry
                risk_reward = round(reward / risk, 2) if risk > 0 else 0
            elif signal == 'SELL' and entry and stoploss and takeprofit and entry != stoploss:
                risk = stoploss - entry
                reward = entry - takeprofit
                risk_reward = round(reward / risk, 2) if risk > 0 else 0
            
            # ===== ENGLISH REPORT =====
            report_en = f"""
{'='*60}
ðŸ“Š {model} ANALYSIS REPORT - {symbol}
{'='*60}
Generated: {timestamp}
Model: {model}

{'â”€'*60}
ðŸŽ¯ TRADING SIGNAL
{'â”€'*60}
Signal:      {signal}
Confidence:  {confidence:.1f}%

{'â”€'*60}
ðŸ’° TRADE SETUP
{'â”€'*60}
Entry:       {entry}
Stop Loss:   {stoploss}
Take Profit: {takeprofit}
Risk/Reward: 1:{risk_reward}

{'â”€'*60}
ðŸ“Š KEY INDICATORS (H1)
{'â”€'*60}
RSI(14):     {rsi_h1}
MACD:        {macd_h1}
ADX(14):     {adx_h1}
EMA(20):     {ema_h1}

{'â”€'*60}
ðŸ•¯ï¸ PATTERNS DETECTED
{'â”€'*60}
Bullish: {', '.join(bullish_patterns[:5]) if bullish_patterns else 'None'}
Bearish: {', '.join(bearish_patterns[:5]) if bearish_patterns else 'None'}

{'â”€'*60}
ðŸ“ SUPPORT/RESISTANCE
{'â”€'*60}
Supports:    {len(supports)} levels
Resistances: {len(resistances)} levels
Trend:       {trend}

{'='*60}
âš ï¸ DISCLAIMER: This is AI-generated analysis.
Always do your own research before trading.
{'='*60}
"""
            
            # ===== VIETNAMESE REPORT =====
            signal_vi = {'BUY': 'MUA', 'SELL': 'BÃN', 'HOLD': 'GIá»®'}.get(signal, signal)
            report_vi = f"""
{'='*60}
ðŸ“Š BÃO CÃO PHÃ‚N TÃCH {model} - {symbol}
{'='*60}
Thá»i gian: {timestamp}
MÃ´ hÃ¬nh: {model}

{'â”€'*60}
ðŸŽ¯ TÃN HIá»†U GIAO Dá»ŠCH
{'â”€'*60}
TÃ­n hiá»‡u:    {signal_vi}
Äá»™ tin cáº­y:  {confidence:.1f}%

{'â”€'*60}
ðŸ’° THIáº¾T Láº¬P GIAO Dá»ŠCH
{'â”€'*60}
GiÃ¡ vÃ o:     {entry}
Cáº¯t lá»—:      {stoploss}
Chá»‘t lá»i:    {takeprofit}
Risk/Reward: 1:{risk_reward}

{'â”€'*60}
ðŸ“Š CHá»ˆ BÃO CHÃNH (H1)
{'â”€'*60}
RSI(14):     {rsi_h1}
MACD:        {macd_h1}
ADX(14):     {adx_h1}
EMA(20):     {ema_h1}

{'â”€'*60}
ðŸ•¯ï¸ MáºªU HÃŒNH PHÃT HIá»†N
{'â”€'*60}
TÄƒng giÃ¡: {', '.join(bullish_patterns[:5]) if bullish_patterns else 'KhÃ´ng cÃ³'}
Giáº£m giÃ¡: {', '.join(bearish_patterns[:5]) if bearish_patterns else 'KhÃ´ng cÃ³'}

{'â”€'*60}
ðŸ“ Há»– TRá»¢/KHÃNG Cá»°
{'â”€'*60}
Há»— trá»£:      {len(supports)} má»©c
KhÃ¡ng cá»±:    {len(resistances)} má»©c
Xu hÆ°á»›ng:    {trend}

{'='*60}
âš ï¸ Cáº¢NH BÃO: ÄÃ¢y lÃ  phÃ¢n tÃ­ch do AI táº¡o ra.
LuÃ´n tá»± nghiÃªn cá»©u trÆ°á»›c khi giao dá»‹ch.
{'='*60}
"""
            
            # Save reports
            report_en_file = f"analysis_results/{symbol}_report_en_{timestamp}.txt"
            report_vi_file = f"analysis_results/{symbol}_report_vi_{timestamp}.txt"
            
            with open(report_en_file, 'w', encoding='utf-8') as f:
                f.write(report_en)
            
            with open(report_vi_file, 'w', encoding='utf-8') as f:
                f.write(report_vi)

        def _generate_ai_position_actions(self, results: list, ai_model: str):
            """Generate position actions based on AI signals - similar to create_advanced_strategies.py"""
            
            # Get current open positions from MT5
            current_positions = []
            if hasattr(self, 'mt5_tab') and self.mt5_tab:
                if hasattr(self.mt5_tab, 'positions'):
                    current_positions = list(self.mt5_tab.positions) if self.mt5_tab.positions else []
            
            actions = []
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            
            for result in results:
                symbol = result.get('symbol', '')
                signal = result.get('signal', 'HOLD')
                confidence = result.get('confidence', 0)
                
                # Normalize symbol for comparison
                symbol_clean = symbol.replace('.', '').replace('_m', '').replace('_', '').upper()
                
                # Find existing position for this symbol
                existing_position = None
                for pos in current_positions:
                    pos_symbol = str(pos.get('symbol', '')).replace('.', '').replace('_m', '').replace('_', '').upper()
                    if pos_symbol == symbol_clean or symbol_clean in pos_symbol or pos_symbol in symbol_clean:
                        existing_position = pos
                        break
                
                action = {
                    "symbol": symbol,
                    "signal": signal,
                    "confidence": confidence,
                    "model": ai_model,
                    "timestamp": timestamp,
                    "action": "NONE",
                    "reason_en": "",
                    "reason_vi": ""
                }
                
                if existing_position:
                    pos_type = str(existing_position.get('type', '')).upper()
                    if pos_type == '0':
                        pos_type = 'BUY'
                    elif pos_type == '1':
                        pos_type = 'SELL'
                    pos_profit = float(existing_position.get('profit', 0) or 0)
                    pos_volume = existing_position.get('volume', 0)
                    pos_ticket = existing_position.get('ticket', 0)
                    
                    action["ticket"] = pos_ticket
                    action["position_type"] = pos_type
                    action["position_profit"] = pos_profit
                    action["position_volume"] = pos_volume
                    
                    # Logic xá»­ lÃ½ lá»‡nh cÃ³ tráº¡ng thÃ¡i
                    if signal == 'HOLD':
                        action["action"] = "HOLD"
                        action["reason_en"] = f"AI signal is HOLD, keep current {pos_type} position"
                        action["reason_vi"] = f"TÃ­n hiá»‡u AI lÃ  GIá»®, giá»¯ nguyÃªn lá»‡nh {pos_type}"
                    
                    elif signal == pos_type:
                        # Same direction - keep or add
                        if confidence >= 80:
                            action["action"] = "ADD"
                            action["reason_en"] = f"Strong {signal} signal ({confidence:.1f}%), consider adding to position"
                            action["reason_vi"] = f"TÃ­n hiá»‡u {signal} máº¡nh ({confidence:.1f}%), cÃ¢n nháº¯c thÃªm vá»‹ tháº¿"
                        else:
                            action["action"] = "HOLD"
                            action["reason_en"] = f"Signal confirms current {pos_type} position"
                            action["reason_vi"] = f"TÃ­n hiá»‡u xÃ¡c nháº­n lá»‡nh {pos_type} hiá»‡n táº¡i"
                    
                    else:
                        # Opposite direction
                        if confidence >= 75:
                            if pos_profit > 0:
                                action["action"] = "CLOSE_PROFIT"
                                action["reason_en"] = f"Strong opposite {signal} signal ({confidence:.1f}%), close profitable position"
                                action["reason_vi"] = f"TÃ­n hiá»‡u ngÆ°á»£c {signal} máº¡nh ({confidence:.1f}%), Ä‘Ã³ng lá»‡nh Ä‘ang lÃ£i"
                            else:
                                action["action"] = "CLOSE_LOSS"
                                action["reason_en"] = f"Strong opposite {signal} signal ({confidence:.1f}%), cut loss"
                                action["reason_vi"] = f"TÃ­n hiá»‡u ngÆ°á»£c {signal} máº¡nh ({confidence:.1f}%), cáº¯t lá»—"
                        elif confidence >= 60:
                            action["action"] = "REDUCE"
                            action["reason_en"] = f"Moderate opposite {signal} signal ({confidence:.1f}%), reduce position size"
                            action["reason_vi"] = f"TÃ­n hiá»‡u ngÆ°á»£c {signal} vá»«a ({confidence:.1f}%), giáº£m khá»‘i lÆ°á»£ng"
                        else:
                            action["action"] = "HOLD"
                            action["reason_en"] = f"Weak opposite signal ({confidence:.1f}%), keep position"
                            action["reason_vi"] = f"TÃ­n hiá»‡u ngÆ°á»£c yáº¿u ({confidence:.1f}%), giá»¯ lá»‡nh"
                
                else:
                    # No existing position
                    if signal == 'HOLD' or confidence < 55:
                        action["action"] = "WAIT"
                        action["reason_en"] = "No clear signal, wait for better opportunity"
                        action["reason_vi"] = "KhÃ´ng cÃ³ tÃ­n hiá»‡u rÃµ rÃ ng, chá» cÆ¡ há»™i tá»‘t hÆ¡n"
                    elif confidence >= 75:
                        action["action"] = f"OPEN_{signal}"
                        action["reason_en"] = f"Strong {signal} signal ({confidence:.1f}%), consider opening position"
                        action["reason_vi"] = f"TÃ­n hiá»‡u {signal} máº¡nh ({confidence:.1f}%), cÃ¢n nháº¯c má»Ÿ lá»‡nh"
                    else:
                        action["action"] = f"WATCH_{signal}"
                        action["reason_en"] = f"Moderate {signal} signal ({confidence:.1f}%), watch for confirmation"
                        action["reason_vi"] = f"TÃ­n hiá»‡u {signal} vá»«a ({confidence:.1f}%), chá» xÃ¡c nháº­n"
                
                actions.append(action)
            
            # Save actions to files
            # JSON format
            actions_json_file = "analysis_results/account_positions_actions.json"
            with open(actions_json_file, 'w', encoding='utf-8') as f:
                json.dump(actions, f, indent=2, ensure_ascii=False)
            
            # Text format - English
            actions_en = self._format_position_actions_text(actions, 'en')
            with open("analysis_results/account_positions_actions_en.txt", 'w', encoding='utf-8') as f:
                f.write(actions_en)
            
            # Text format - Vietnamese
            actions_vi = self._format_position_actions_text(actions, 'vi')
            with open("analysis_results/account_positions_actions_vi.txt", 'w', encoding='utf-8') as f:
                f.write(actions_vi)
            
            print(f"   ðŸ“Š Position actions generated for {len(actions)} symbols")

        def _format_position_actions_text(self, actions: list, lang: str = 'en') -> str:
            """Format position actions as text report"""
            
            if lang == 'vi':
                header = f"""
{'='*60}
ðŸ“Š HÃ€NH Äá»˜NG Vá»Š THáº¾ - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
{'='*60}

"""
                action_trans = {
                    'NONE': 'âšª KhÃ´ng hÃ nh Ä‘á»™ng',
                    'HOLD': 'â¸ï¸ Giá»¯ lá»‡nh',
                    'ADD': 'âž• ThÃªm vá»‹ tháº¿',
                    'CLOSE_PROFIT': 'âœ… ÄÃ³ng lá»‡nh (lÃ£i)',
                    'CLOSE_LOSS': 'âŒ ÄÃ³ng lá»‡nh (lá»—)',
                    'REDUCE': 'ðŸ“‰ Giáº£m vá»‹ tháº¿',
                    'WAIT': 'â³ Chá» Ä‘á»£i',
                    'OPEN_BUY': 'ðŸŸ¢ Má»Ÿ lá»‡nh MUA',
                    'OPEN_SELL': 'ðŸ”´ Má»Ÿ lá»‡nh BÃN',
                    'WATCH_BUY': 'ðŸ‘€ Theo dÃµi MUA',
                    'WATCH_SELL': 'ðŸ‘€ Theo dÃµi BÃN'
                }
            else:
                header = f"""
{'='*60}
ðŸ“Š POSITION ACTIONS - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
{'='*60}

"""
                action_trans = {
                    'NONE': 'âšª No Action',
                    'HOLD': 'â¸ï¸ Hold Position',
                    'ADD': 'âž• Add to Position',
                    'CLOSE_PROFIT': 'âœ… Close (Profit)',
                    'CLOSE_LOSS': 'âŒ Close (Loss)',
                    'REDUCE': 'ðŸ“‰ Reduce Position',
                    'WAIT': 'â³ Wait',
                    'OPEN_BUY': 'ðŸŸ¢ Open BUY',
                    'OPEN_SELL': 'ðŸ”´ Open SELL',
                    'WATCH_BUY': 'ðŸ‘€ Watch BUY',
                    'WATCH_SELL': 'ðŸ‘€ Watch SELL'
                }
            
            lines = [header]
            
            for act in actions:
                symbol = act.get('symbol', '')
                signal = act.get('signal', 'HOLD')
                confidence = act.get('confidence', 0)
                action = act.get('action', 'NONE')
                reason = act.get('reason_vi' if lang == 'vi' else 'reason_en', '')
                model = act.get('model', 'AI')
                
                action_text = action_trans.get(action, action)
                
                # Check if has existing position
                if 'ticket' in act:
                    pos_info = f"Ticket #{act['ticket']} | {act.get('position_type', '')} | P/L: {act.get('position_profit', 0):.2f}"
                else:
                    pos_info = "No existing position" if lang == 'en' else "ChÆ°a cÃ³ lá»‡nh"
                
                lines.append(f"""
{'â”€'*60}
ðŸ“Œ {symbol}
   Signal: {signal} ({confidence:.1f}%)
   Model:  {model}
   Status: {pos_info}
   
   âž¡ï¸ {action_text}
   ðŸ’¡ {reason}
""")
            
            lines.append(f"\n{'='*60}")
            return ''.join(lines)

        def _after_run(self):
            self.run_btn.setEnabled(True)
            
            # Check for errors and display them
            if self.thread and self.thread.returncode != 0:
                print(f"âŒ comprehensive_aggregator.py failed with return code: {self.thread.returncode}")
                if self.thread.stderr:
                    print(f"âŒ Error details: {self.thread.stderr}")
                if hasattr(self, 'status_label'):
                    self.status_label.setText(f"âŒ Error: Return code {self.thread.returncode}")
            else:
                print("âœ… comprehensive_aggregator.py completed successfully")
                if hasattr(self, 'status_label'):
                    self.status_label.setText("âœ… Analysis completed")
                
                # ðŸš€ AUTO EXECUTE ACTIONS after successful analysis
                self.auto_execute_actions_after_analysis()
            
            # Refresh views
            self.load_latest_signals()
            
            # âš ï¸ SIGNAL NOTIFICATIONS DISABLED - Method does not exist, causes crash every 2 minutes!
            # self.send_signal_notification_after_analysis()  # DISABLED - method not defined
            
            self.load_actions_text()

        def auto_execute_actions_after_analysis(self):
            """âœ… Actions are now executed directly in comprehensive_aggregator.py"""
            print("âœ… Actions executed by aggregator - no app.py execution needed")
            return  # Disabled - aggregator handles execution now
            
            try:
                import time
                print("ðŸš€ Auto-executing actions after analysis...")
                
                # ðŸš« PREVENT DOUBLE EXECUTION - Check if UnifiedAutoTradingSystem is running
                # Check in all tabs for auto trading manager
                if hasattr(self, 'all_tabs') and 'auto_trading_tab' in self.all_tabs:
                    auto_tab = self.all_tabs['auto_trading_tab']
                    if (hasattr(auto_tab, 'auto_manager') and auto_tab.auto_manager and 
                        hasattr(auto_tab, 'auto_btn') and auto_tab.auto_btn.isChecked()):
                        print("ðŸš« UnifiedAutoTradingSystem pipeline is active - skipping manual execution to prevent duplicates")
                        print("ðŸ’¡ Actions will be executed by the automated pipeline instead")
                        print(f"ðŸ“Š Pipeline status: {'RUNNING' if auto_tab.auto_manager else 'STOPPED'}")
                        return
                
                # If no pipeline running, proceed with manual execution
                print("âœ… No pipeline conflict detected - proceeding with manual execution")
                
                # ðŸ›¡ï¸ DUPLICATE EXECUTION PROTECTION
                # Check if we've already executed actions recently (within 30 seconds)
                last_execution_file = os.path.join(os.getcwd(), 'risk_management', 'last_auto_execution.json')
                current_time = time.time()
                
                if os.path.exists(last_execution_file):
                    try:
                        with open(last_execution_file, 'r', encoding='utf-8') as f:
                            last_exec_data = json.load(f)
                        
                        last_execution_time = last_exec_data.get('timestamp', 0)
                        if current_time - last_execution_time < 30:  # 30 second cooldown
                            print(f"ðŸš« Auto-execution blocked: Last execution was {current_time - last_execution_time:.1f}s ago (cooldown: 30s)")
                            return
                    except Exception as e:
                        print(f"âš ï¸ Warning: Could not read last execution file: {e}")
                
                # Check if execute_actions.py exists
                execute_actions_path = os.path.join(os.getcwd(), 'execute_actions.py')
                if not os.path.exists(execute_actions_path):
                    print("âŒ execute_actions.py not found - skipping auto execution")
                    return
                
                # Check if there are actions to execute
                actions_path = os.path.join(os.getcwd(), 'analysis_results', 'account_positions_actions.json')
                if not os.path.exists(actions_path):
                    print("ðŸ“ No actions file found - skipping execution")
                    return
                
                # Load and check actions
                with open(actions_path, 'r', encoding='utf-8') as f:
                    actions_data = json.load(f)
                
                actions = actions_data.get('actions', [])
                total_actions = len(actions)
                if total_actions == 0:
                    print("ðŸ“ No actions to execute")
                    return
                
                # ðŸ” CHECK ACTION TYPES - Only apply cooldown to PRIMARY entries, allow DCA
                primary_entries = [a for a in actions if a.get('action_type', '').lower() in ['primary_entry', 'entry', 'new_entry']]
                dca_actions = [a for a in actions if 'dca' in a.get('action_type', '').lower()]
                
                if primary_entries and os.path.exists(last_execution_file):
                    # More strict cooldown for primary entries (they can create duplicates)
                    try:
                        with open(last_execution_file, 'r', encoding='utf-8') as f:
                            last_exec_data = json.load(f)
                        
                        last_execution_time = last_exec_data.get('timestamp', 0)
                        if current_time - last_execution_time < 30:  # 30 second cooldown for primary entries
                            print(f"ï¿½ Primary entry blocked: Last execution was {current_time - last_execution_time:.1f}s ago (cooldown: 30s)")
                            print(f"ðŸ’¡ DCA actions ({len(dca_actions)}) can still proceed if any")
                            # Only execute DCA actions, skip primary entries
                            actions = dca_actions
                            total_actions = len(actions)
                            if total_actions == 0:
                                return
                    except Exception as e:
                        print(f"âš ï¸ Warning: Could not read last execution file: {e}")
                
                print(f"ðŸŽ¯ Found {total_actions} actions to execute ({len(primary_entries)} primary, {len(dca_actions)} DCA)")
                
                # ðŸ“ If we filtered actions, create temporary actions file  
                temp_actions_path = actions_path
                if len(actions) < len(actions_data.get('actions', [])):
                    # Create filtered actions file
                    temp_actions_path = os.path.join(os.getcwd(), 'analysis_results', 'temp_filtered_actions.json')
                    filtered_data = actions_data.copy()
                    filtered_data['actions'] = actions
                    
                    with open(temp_actions_path, 'w', encoding='utf-8') as f:
                        json.dump(filtered_data, f, indent=2, ensure_ascii=False)
                    print(f"ðŸ“ Created filtered actions file: {len(actions)} actions (original: {len(actions_data.get('actions', []))})")
                
                # ðŸš€ EXECUTE ACTIONS VIA apply_actions_from_json() - Fast & Simple!
                if hasattr(self, 'status_label'):
                    self.status_label.setText(f"ðŸš€ Executing {total_actions} actions...")
                
                # Import executor directly (singleton - already initialized!)
                from order_executor import get_executor_instance
                
                try:
                    # Get executor instance (fast - already exists!)
                    executor = get_executor_instance()
                    print(f"âœ… Using existing executor (ID: {id(executor)})")
                    
                    # ðŸš€ Call apply_actions_from_json() - handles ALL action types!
                    print("ðŸ”§ Calling apply_actions_from_json()...")
                    result = executor.apply_actions_from_json()
                    
                    # Clean up temp file if created
                    if temp_actions_path != actions_path and os.path.exists(temp_actions_path):
                        try:
                            os.remove(temp_actions_path)
                        except Exception as e:
                            print(f"âš ï¸ Could not clean temp file: {e}")
                    
                    # Check results
                    if result.get('success'):
                        applied = result.get('applied', 0)
                        by_action = result.get('by_action', {})
                        
                        print(f"âœ… Actions executed successfully!")
                        print(f"   Total applied: {applied}")
                        for action_type, count in by_action.items():
                            print(f"   {action_type}: {count}")
                        
                        # ðŸ•’ UPDATE TIMESTAMP after successful execution
                        try:
                            os.makedirs(os.path.dirname(last_execution_file), exist_ok=True)
                            with open(last_execution_file, 'w', encoding='utf-8') as f:
                                json.dump({
                                    'timestamp': current_time,
                                    'actions_count': total_actions,
                                    'execution_time': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                                }, f, indent=2)
                            print(f"ðŸ•’ Updated execution timestamp: {datetime.now().strftime('%H:%M:%S')}")
                        except Exception as e:
                            print(f"âš ï¸ Warning: Could not save execution timestamp: {e}")
                        
                        if hasattr(self, 'status_label'):
                            self.status_label.setText(f"âœ… Executed {applied} actions")
                    else:
                        error = result.get('error', 'Unknown error')
                        print(f"âŒ Action execution failed: {error}")
                        if hasattr(self, 'status_label'):
                            self.status_label.setText("âš ï¸ Execution failed")
                
                except Exception as e:
                    print(f"âŒ Exception during action execution: {e}")
                    import traceback
                    traceback.print_exc()
                    if hasattr(self, 'status_label'):
                        self.status_label.setText("âŒ Execution error")
                        
            except subprocess.TimeoutExpired:
                print("â° Action execution timed out")
                if hasattr(self, 'status_label'):
                    self.status_label.setText("â° Execution timed out")
            except Exception as e:
                print(f"âŒ Auto execution error: {e}")
                if hasattr(self, 'status_label'):
                    self.status_label.setText("âš ï¸ Auto execution failed")

        def on_signal_clicked(self, row: int, col: int):
            try:
                sym_item = self.sig_table.item(row, 0)
                if not sym_item:
                    return
                sym = sym_item.text().strip()
                if sym:
                    self.load_latest_report(sym)
            except Exception as e:
                print(f"[SignalTab] on_signal_clicked error: {e}")

        def order_now_for_symbol(self, sym: str):
            # ========== LICENSE CHECK ==========
            # Kiá»ƒm tra license trÆ°á»›c khi cho phÃ©p Ä‘áº·t lá»‡nh
            if not check_license_for_service(self, "Order Execution"):
                return
            # ========== END LICENSE CHECK ==========
            
            try:
                # 1. Load latest signal JSON with enhanced debugging
                out_dir = os.path.join(os.getcwd(), 'analysis_results')
                print(f"ðŸ” [ORDER DEBUG] Looking for signal file for symbol: {sym}")
                print(f"ðŸ” [ORDER DEBUG] Analysis results directory: {out_dir}")
                
                # Smart symbol mapping for signal file lookup
                fp = self._find_signal_file_smart(out_dir, sym)
                print(f"ðŸ” [ORDER DEBUG] Smart signal file lookup for '{sym}': {fp}")
                
                if not fp:
                    # List available signal files for debugging
                    try:
                        available_files = os.listdir(out_dir) if os.path.exists(out_dir) else []
                        signal_files = [f for f in available_files if f.endswith('_signal_*.json') or 'signal' in f]
                        print(f"ðŸ” [ORDER DEBUG] Available signal files: {signal_files[:10]}")  # First 10
                    except Exception as e:
                        print(f"ðŸ” [ORDER DEBUG] Error listing files: {e}")
                    
                    QMessageBox.warning(
                        self,
                        I18N.t("Order", "Äáº·t lá»‡nh"),
                        I18N.t("No signal file found for {sym}", "KhÃ´ng tÃ¬m tháº¥y tá»‡p tÃ­n hiá»‡u cho {sym}", sym=sym)
                    )
                    return
                
                print(f"âœ… [ORDER DEBUG] Using signal file: {fp}")
                with open(fp, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                fi = (data.get('final_signal') or {})
                action = (fi.get('signal') or '').upper()
                if action not in ("BUY", "SELL"):
                    QMessageBox.warning(
                        self,
                        I18N.t("Order", "Äáº·t lá»‡nh"),
                        I18N.t("Unsupported signal for {sym}: {action}", "TÃ­n hiá»‡u khÃ´ng há»— trá»£ cho {sym}: {action}", sym=sym, action=action)
                    )
                    return

                # 2. Confidence guard
                conf = float(fi.get('confidence') or 0.0)
                min_conf = float(self.min_conf_spin.value())
                if conf < min_conf:
                    QMessageBox.warning(
                        self,
                        I18N.t("Order", "Äáº·t lá»‡nh"),
                        I18N.t(
                            "Signal confidence {conf}% is below min threshold {min_conf}%",
                            "Äá»™ tin cáº­y {conf}% tháº¥p hÆ¡n ngÆ°á»¡ng tá»‘i thiá»ƒu {min_conf}%",
                            conf=conf, min_conf=min_conf
                        )
                    )
                    return

                entry = fi.get('entry') or 0.0
                sl = fi.get('stoploss') or 0.0
                tp = fi.get('takeprofit') or 0.0

                # 3. Read risk settings for lot bounds
                risk_min = 0.01
                risk_max = 100.0
                try:
                    rfp = os.path.join(os.getcwd(), 'risk_management', 'risk_settings.json')
                    if os.path.exists(rfp):
                        with open(rfp, 'r', encoding='utf-8') as rf:
                            rcfg = json.load(rf)
                        risk_min = float(rcfg.get('min_lot_size', risk_min))
                        risk_max = float(rcfg.get('max_lot_size', risk_max))
                except Exception:
                    pass

                # 4. Ask user volume within risk bounds
                vol, ok = QInputDialog.getDouble(
                    self,
                    I18N.t("Order volume", "Khá»‘i lÆ°á»£ng lá»‡nh"),
                    I18N.t("Enter volume (lots) for {sym}:", "Nháº­p khá»‘i lÆ°á»£ng (lot) cho {sym}:", sym=sym),
                    max(risk_min, 0.01), risk_min, risk_max, 2
                )
                if not ok:
                    return
                volume = float(vol)

                # 5. Initialize / verify MT5 and map symbol variant
                trade_symbol = sym
                try:
                    import MetaTrader5 as mt5
                    if not mt5.initialize():
                        mt5.initialize()
                    
                    # Enhanced symbol mapping logic for different broker suffixes
                    sinfo = mt5.symbol_info(trade_symbol)
                    if not sinfo:
                        # Try common variations
                        variants = []
                        base_symbol = trade_symbol.replace('_m', '').replace('.', '')
                        
                        # Add variants with different suffixes
                        variants.extend([
                            base_symbol + '_m',    # Crypto style
                            base_symbol + '.',     # Forex style  
                            base_symbol,           # No suffix
                            base_symbol.upper() + '_m',
                            base_symbol.upper() + '.',
                            base_symbol.upper()
                        ])
                        
                        # Try each variant
                        for variant in variants:
                            if variant != trade_symbol:  # Skip original
                                test_info = mt5.symbol_info(variant)
                                if test_info:
                                    print(f"ðŸ” Symbol mapping: {trade_symbol} -> {variant}")
                                    trade_symbol = variant
                                    sinfo = test_info
                                    break
                    
                    if sinfo and not sinfo.visible:
                        mt5.symbol_select(trade_symbol, True)
                    tick = mt5.symbol_info_tick(trade_symbol)
                    if tick:
                        mkt_price = tick.ask if action == 'BUY' else tick.bid
                        if not entry or entry <= 0:
                            entry = mkt_price
                    # Clamp volume to broker limits
                    if sinfo:
                        if volume < sinfo.volume_min:
                            volume = sinfo.volume_min
                        if volume > sinfo.volume_max:
                            volume = sinfo.volume_max
                except Exception as e:
                    QMessageBox.warning(
                        self,
                        I18N.t("Order", "Äáº·t lá»‡nh"),
                        I18N.t("MT5 init / symbol check failed: {e}", "Khá»Ÿi táº¡o MT5 / kiá»ƒm tra mÃ£ lá»—i: {e}", e=e)
                    )
                    return

                # 6. Confirm
                confirm = QMessageBox.question(
                    self,
                    I18N.t("Confirm Order", "XÃ¡c nháº­n lá»‡nh"),
                    I18N.t(
                        "Place {action} {vol} lots {sym}?\nEntry: {entry}\nSL: {sl}\nTP: {tp}",
                        "Äáº·t lá»‡nh {action} {vol} lot {sym}?\nGiÃ¡ vÃ o: {entry}\nSL: {sl}\nTP: {tp}",
                        action=action, vol=volume, sym=trade_symbol, entry=entry, sl=sl, tp=tp
                    )
                )
                if confirm != QMessageBox.Yes:
                    return

                # 7. Execute
                try:
                    from order_executor import get_executor_instance, TradeSignal
                    # Reuse unified connection manager if available from global login flow
                    shared_manager = None
                    try:
                        if 'MT5ConnectionManager' in globals():
                            shared_manager = MT5ConnectionManager()
                    except Exception:
                        shared_manager = None
                    sig = TradeSignal(
                        symbol=trade_symbol,
                        action=action,
                        entry_price=float(entry or 0.0),
                        stop_loss=float(sl or 0.0),
                        take_profit=float(tp or 0.0),
                        volume=volume,
                        confidence=conf,
                        strategy="GUI_ORDER",
                        comment="SignalTab Order"
                    )
                    ex = get_executor_instance(connection=self.mt5_conn if hasattr(self, 'mt5_conn') else None)
                    # If we created an executor before account switch, ensure internal manager picks up reconfigured session
                    try:
                        if shared_manager and ex.connection_manager and ex.connection_manager is shared_manager:
                            # Optionally force a lightweight status check
                            ex.connection_manager.connect(force_reconnect=False)
                    except Exception:
                        pass
                    result = ex.execute_market_order(sig)
                    if result.success:
                        QMessageBox.information(
                            self,
                            I18N.t("Order", "Äáº·t lá»‡nh"),
                            I18N.t(
                                "Order executed successfully. Ticket: {ticket}",
                                "Äáº·t lá»‡nh thÃ nh cÃ´ng. MÃ£: {ticket}",
                                ticket=(result.ticket or result.order_id)
                            )
                        )
                    else:
                        QMessageBox.warning(
                            self,
                            I18N.t("Order", "Äáº·t lá»‡nh"),
                            I18N.t("Order failed: {msg}", "Äáº·t lá»‡nh tháº¥t báº¡i: {msg}", msg=result.error_message)
                        )
                except Exception as e:
                    QMessageBox.critical(
                        self,
                        I18N.t("Order", "Äáº·t lá»‡nh"),
                        I18N.t("Order exception: {e}", "Lá»—i khi Ä‘áº·t lá»‡nh: {e}", e=e)
                    )
            except Exception as e:
                QMessageBox.critical(
                    self,
                    I18N.t("Order", "Äáº·t lá»‡nh"),
                    I18N.t("Order exception outer: {e}", "Lá»—i Ä‘áº·t lá»‡nh (ngoÃ i): {e}", e=e)
                )

        def open_notification_dialog(self):
            """Open notification setup and send dialog"""
            try:
                print("ðŸ” [DEBUG] Opening notification dialog...")
                dialog = NotificationDialog(self)
                print("âœ… [DEBUG] NotificationDialog created successfully")
                result = dialog.exec_()
                print(f"âœ… [DEBUG] Dialog completed with result: {result}")
            except Exception as e:
                print(f"âŒ [ERROR] Failed to open notification dialog: {e}")
                import traceback
                print(f"âŒ [TRACEBACK] {traceback.format_exc()}")
                QMessageBox.critical(self, I18N.t("Error", "Lá»—i"), I18N.t("Failed to open notification dialog: {error}", "KhÃ´ng thá»ƒ má»Ÿ há»™p thoáº¡i thÃ´ng bÃ¡o: {error}", error=str(e)))

        # === AI Model Selection Methods ===
        def _on_ai_model_changed(self, index):
            """Handle AI model selection change"""
            # Models: 0=Aggregator, 1=XGBoost(5001), 2=CNN-LSTM(5002), 3=Transformer(5003)
            is_ai_server = index >= 1
            self.ai_server_widget.setVisible(is_ai_server)
            
            model_names = ["Aggregator (Local)", "XGBoost AI (5001)", "CNN-LSTM Pro (5002)", "Transformer Pro (5003)"]
            print(f"ðŸ¤– [SignalTab] Switched to {model_names[index]}")
            
            if is_ai_server:
                self._check_ai_server_status()

        def _load_ai_server_url(self):
            """Load saved AI Server URL from config"""
            try:
                config_file = os.path.join(os.path.dirname(__file__), "ai_server_config.json")
                if os.path.exists(config_file):
                    with open(config_file, 'r', encoding='utf-8') as f:
                        config = json.load(f)
                        return config.get('server_url', 'http://localhost:8001')
            except Exception as e:
                print(f"âš ï¸ Error loading AI server config: {e}")
            return 'http://localhost:8001'  # Default
        
        def _save_ai_server_url(self, url=None):
            """Save AI Server URL to config"""
            try:
                if url is None and hasattr(self, 'ai_server_url_input'):
                    url = self.ai_server_url_input.text().strip()
                
                if not url:
                    return
                
                config_file = os.path.join(os.path.dirname(__file__), "ai_server_config.json")
                config = {}
                if os.path.exists(config_file):
                    with open(config_file, 'r', encoding='utf-8') as f:
                        config = json.load(f)
                
                config['server_url'] = url
                config['last_updated'] = datetime.now().isoformat()
                
                with open(config_file, 'w', encoding='utf-8') as f:
                    json.dump(config, f, indent=2, ensure_ascii=False)
                
                print(f"ðŸ’¾ AI Server URL saved: {url}")
            except Exception as e:
                print(f"âš ï¸ Error saving AI server config: {e}")
        
        def _get_ai_server_url(self):
            """Get current AI Server URL with dynamic port"""
            port = self._get_ai_model_port()
            if port == 0:
                return None  # Local aggregator mode
            return f'http://localhost:{port}'

        def _check_ai_server_status(self):
            """Check if remote AI Server is running"""
            try:
                import requests
                port = self._get_ai_model_port()
                if port == 0:
                    self.ai_server_status.setText("ðŸ”µ Local Mode")
                    self.ai_server_status.setStyleSheet("color: #2196F3; font-weight: bold;")
                    return
                
                server_url = f"http://localhost:{port}"
                
                self.ai_server_status.setText("ðŸ”„ Checking...")
                self.ai_server_status.setStyleSheet("color: #ff9800; font-weight: bold;")
                QApplication.processEvents()
                
                response = requests.get(f"{server_url}/health", timeout=5)
                
                if response.status_code == 200:
                    data = response.json()
                    status = data.get('status', 'unknown')
                    model_name = data.get('model', 'Unknown')
                    
                    if status == 'healthy':
                        self.ai_server_status.setText(f"ðŸŸ¢ {model_name.upper()} Ready")
                        self.ai_server_status.setStyleSheet("color: #4caf50; font-weight: bold;")
                    else:
                        self.ai_server_status.setText(f"ðŸŸ¡ {status}")
                        self.ai_server_status.setStyleSheet("color: #ff9800; font-weight: bold;")
                else:
                    self.ai_server_status.setText(f"ðŸ”´ Error ({response.status_code})")
                    self.ai_server_status.setStyleSheet("color: #f44336; font-weight: bold;")
                    
            except requests.exceptions.Timeout:
                self.ai_server_status.setText("ðŸ”´ Timeout")
                self.ai_server_status.setStyleSheet("color: #f44336; font-weight: bold;")
            except requests.exceptions.ConnectionError:
                self.ai_server_status.setText("ðŸ”´ Cannot Connect")
                self.ai_server_status.setStyleSheet("color: #f44336; font-weight: bold;")
            except Exception as e:
                self.ai_server_status.setText("ðŸ”´ Error")
                self.ai_server_status.setStyleSheet("color: #f44336; font-weight: bold;")
                print(f"âš ï¸ AI Server check error: {e}")

        def _get_selected_ai_model(self):
            """Get currently selected AI model"""
            index = self.ai_model_combo.currentIndex()
            # 0=aggregator, 1=xgboost, 2=cnn_lstm, 3=transformer
            models = ["aggregator", "xgboost", "cnn_lstm", "transformer"]
            return models[index] if index < len(models) else "aggregator"
        
        def _get_ai_model_port(self):
            """Get port for selected AI model"""
            index = self.ai_model_combo.currentIndex()
            # 0=Local, 1=XGBoost(5001), 2=CNN-LSTM(5002), 3=Transformer(5003)
            ports = [0, 5001, 5002, 5003]
            return ports[index] if index < len(ports) else 0

try:
    import MetaTrader5 as mt5
    MT5_AVAILABLE = True
    # print("âœ… MetaTrader5 loaded successfully")
except ImportError as e:
    print(f"âš ï¸ MetaTrader5 not available: {e}")
    MT5_AVAILABLE = False
    # Mock MT5 module
    class MockMT5:
        TIMEFRAME_M1 = 1
        TIMEFRAME_M5 = 5
        TIMEFRAME_M15 = 15
        TIMEFRAME_M30 = 30
        TIMEFRAME_H1 = 60
        TIMEFRAME_H4 = 240
        TIMEFRAME_D1 = 1440
    mt5 = MockMT5()

try:
    import pandas as pd
    PANDAS_AVAILABLE = True
    import pandas as pd
    PANDAS_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸ Pandas not available: {e}")
    PANDAS_AVAILABLE = False

try:
    from dotenv import load_dotenv, set_key
    DOTENV_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸ Python-dotenv not available: {e}")
    DOTENV_AVAILABLE = False
    def load_dotenv(): pass
    def set_key(*args): pass

# Enhanced module imports with error handling
try:
    # Use clean news scraper (already imported above)
    # print("ðŸš€ News scraper already loaded")
    # NEWS_SCRAPER_AVAILABLE is already set above
    # print("âœ… News scraper ready")
    pass
except Exception as e:
    print(f"âš ï¸ News scraper issue: {e}")
    NEWS_SCRAPER_AVAILABLE = False
    class MockNewsScraper:
        @staticmethod
        def get_today_news(*args): 
            print("ðŸ“Š Using mock news data")
            return []
        @staticmethod
        def save_recent_news_to_json(*args): 
            print("ðŸ“ Mock save news")
            pass
    news_scraper = MockNewsScraper()

try:
    from mt5_indicator_exporter import update_data_with_new_candle
    from mt5_indicator_exporter import calculate_and_save_all
    INDICATOR_EXPORTER_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸ Indicator exporter not available: {e}")
    INDICATOR_EXPORTER_AVAILABLE = False
    def update_data_with_new_candle(*args): pass
    def calculate_and_save_all(*args): return {"success": 0, "failed": 0}

try:
    from pattern_detector import analyze_patterns
    PATTERN_DETECTOR_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸ Pattern detector not available: {e}")
    PATTERN_DETECTOR_AVAILABLE = False
    def analyze_patterns(*args): return []

try:
    from price_patterns_full_data import main as analyze_price_patterns
    PRICE_PATTERNS_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸ Price patterns not available: {e}")
    PRICE_PATTERNS_AVAILABLE = False
    def analyze_price_patterns(*args): pass

try:
    from gpt_analyst import analyze_symbol
    GPT_ANALYST_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸ GPT analyst not available: {e}")
    GPT_ANALYST_AVAILABLE = False
    def analyze_symbol(*args): return {"analysis": "Not available"}

try:
    # from risk_manager import RiskManagementSystem  # File removed
    RISK_MANAGER_AVAILABLE = False
except ImportError as e:
    print(f"âš ï¸ Risk manager not available: {e}")
    RISK_MANAGER_AVAILABLE = False

# Create stub classes for removed risk_manager module
class RiskManagementSystem:
    def __init__(self, *args): pass
    def validate_trade(self, *args): return True

class AdvancedRiskManagementSystem:
    def __init__(self, *args): pass
    def validate_signal(self, *args): return {"valid": True, "message": "Risk manager disabled"}
    def update_parameters(self, *args): pass

class AdvancedRiskParameters:
    def __init__(self, *args): pass

class TradeSignal:
    def __init__(self, *args): pass

class ValidationResult:
    def __init__(self, valid=True, message="OK", *args):
        self.valid = valid
        self.message = message

try:
    from order_executor import OrderHandler
    ORDER_EXECUTOR_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸ Order executor not available: {e}")
    ORDER_EXECUTOR_AVAILABLE = False
    class OrderHandler:
        def __init__(self, *args): pass
        def send_order(self, *args): return False

try:
    from mt5_connector import MT5ConnectionManager
    MT5_CONNECTOR_AVAILABLE = True
    # print("âœ… MT5 connector imported successfully")
except ImportError as e:
    print(f"âš ï¸ MT5 connector not available: {e}")
    MT5_CONNECTOR_AVAILABLE = False
    MT5ConnectionManager = None

try:
    from unified_auto_trading_system import UnifiedAutoTradingSystem as AutoTradingManager
    AUTO_TRADING_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸ Unified auto trading system not available: {e}")
    AUTO_TRADING_AVAILABLE = False
    class AutoTradingManagerStub:
        def __init__(self, *args): pass
        def start(self): pass
        def stop(self): pass

try:
    from mt5_data_fetcher import fetch_and_save_candles
    DATA_FETCHER_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸ Data fetcher not available: {e}")
    DATA_FETCHER_AVAILABLE = False
    def fetch_and_save_candles(*args): return []

# Configure safe logging for Windows console
import sys
import logging

# Set up logging with Windows-safe configuration
if sys.platform == "win32":
    # For Windows, use a simple configuration without emojis
    import io
    
    class SafeStreamHandler(logging.StreamHandler):
        def emit(self, record):
            try:
                # Remove emojis and special characters from log messages
                msg = self.format(record)
                # Replace common emoji patterns
                emoji_replacements = {
                    'âœ…': '[OK]',
                    'âŒ': '[ERROR]',
                    'âš ï¸': '[WARNING]',
                    'ðŸ”„': '[LOADING]',
                    'ðŸ“Š': '[DATA]',
                    'ðŸ“š': '[INFO]',
                    'ðŸ›¡ï¸': '[SHIELD]',
                    'ðŸŽ¯': '[TARGET]',
                    'ðŸ’°': '[MONEY]',
                    'ðŸ“ˆ': '[CHART]'
                }
                
                for emoji, replacement in emoji_replacements.items():
                    msg = msg.replace(emoji, replacement)
                
                # Encode safely for Windows console
                self.stream.write(msg + self.terminator)
                self.flush()
            except UnicodeEncodeError:
                # Fallback: encode with errors='replace'
                try:
                    msg_bytes = msg.encode('utf-8', errors='replace').decode('utf-8')
                    self.stream.write(msg_bytes + self.terminator)
                    self.flush()
                except:
                    # Ultimate fallback
                    self.stream.write(f"[LOG MESSAGE ENCODING ERROR]\n")
                    self.flush()
    
    logging.basicConfig(
        level=logging.INFO, 
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[SafeStreamHandler()],
        force=True  # Force reconfiguration
    )
else:
    logging.basicConfig(
        level=logging.INFO, 
        format='%(asctime)s - %(levelname)s - %(message)s'
    )

TIMEFRAME_MAP = {
    "M1": mt5.TIMEFRAME_M1,
    "M5": mt5.TIMEFRAME_M5,
    "M15": mt5.TIMEFRAME_M15,
    "M30": mt5.TIMEFRAME_M30,
    "H1": mt5.TIMEFRAME_H1,
    "H4": mt5.TIMEFRAME_H4,
    "D1": mt5.TIMEFRAME_D1,
    "W1": mt5.TIMEFRAME_W1,
    "MN1": mt5.TIMEFRAME_MN1,
}

ENV_PATH = ".env"

ALL_CURRENCY = ["USD", "EUR", "JPY", "GBP", "AUD", "CAD", "CHF", "NZD"]
ALL_IMPACT = [1, 2, 3]  # Bá» 0 khá»i danh sÃ¡ch Impact

DATA_FOLDER = "data"
INDICATOR_FOLDER = "indicator_output"

USER_CONFIG_PATH = "user_config.pkl"

def save_user_config(config):
    """Save user configuration to pickle file + save notification settings to JSON"""
    try:
        with open(USER_CONFIG_PATH, "wb") as f:
            pickle.dump(config, f)
        
        # ðŸ”§ FIX: Also save notification settings to JSON
        if 'notification_settings' in config:
            try:
                import json
                config_file = 'notification_config.json'
                # Load existing config
                full_config = {}
                if os.path.exists(config_file):
                    with open(config_file, 'r', encoding='utf-8') as f:
                        full_config = json.load(f)
                
                # Update settings section
                full_config['settings'] = config['notification_settings']
                
                # Save back to file
                with open(config_file, 'w', encoding='utf-8') as f:
                    json.dump(full_config, f, indent=2, ensure_ascii=False)
                print(f"âœ… User config + notification settings saved")
            except Exception as e:
                print(f"âš ï¸ Could not save notification settings: {e}")
        else:
            print(f"âœ… User config saved")
            
    except Exception as e:
        print(f"âŒ Could not save user config: {e}")

def load_user_config(apply_lang: bool = True):
    """Load user configuration from pickle file + load notification settings from JSON"""
    # ðŸ”§ FIX: Also load notification settings from JSON
    try:
        if os.path.exists(USER_CONFIG_PATH):
            with open(USER_CONFIG_PATH, "rb") as f:
                config = pickle.load(f)
        else:
            config = {}
        
        # Set defaults
        if "use_economic_calendar" not in config:
            config["use_economic_calendar"] = True
        if "language" not in config:
            config["language"] = AppState._lang
        elif apply_lang:
            stored_lang = config.get('language')
            if stored_lang in ('en','vi'):
                AppState._lang = stored_lang
        
        # ðŸ”§ FIX: Load notification settings from JSON
        try:
            import json
            config_file = 'notification_config.json'
            if os.path.exists(config_file):
                with open(config_file, 'r', encoding='utf-8') as f:
                    notif_config = json.load(f)
                    if 'settings' in notif_config:
                        config['notification_settings'] = notif_config['settings']
                        print(f"âœ… Notification settings loaded from JSON")
        except Exception as e:
            print(f"âš ï¸ Could not load notification settings: {e}")
        
        return config
        
    except Exception as e:
        print(f"âŒ Could not load user config: {e}")
        return {"use_economic_calendar": True, "language": AppState.language()}

# Define local MT5Connection class that works with GUI
class MT5Connection:
    def __init__(self, account, password, server):
        self.account = account
        self.password = password
        self.server = server
        self.connected = False
        self.connection_manager = None
        self.initialize()

    def initialize(self):
        if not MT5_AVAILABLE:
            logging.warning("MT5 not available, using mock connection")
            self.connected = True
            return
            
        # Use MT5ConnectionManager if available
        if MT5_CONNECTOR_AVAILABLE:
            try:
                self.connection_manager = MT5ConnectionManager()
                # If manager already had a config and it's different, reconfigure
                cfg = getattr(self.connection_manager, 'config', None)
                needs_reconf = False
                try:
                    if cfg and (str(cfg.account) != str(self.account) or str(cfg.server) != str(self.server)):
                        needs_reconf = True
                except Exception:
                    pass
                if needs_reconf:
                    self.connection_manager.reconfigure(self.account, self.password, self.server)
                elif not cfg:
                    # Initial configure via reconfigure to push env values
                    self.connection_manager.reconfigure(self.account, self.password, self.server)
                if self.connection_manager.connect(force_reconnect=needs_reconf):
                    self.connected = True
                    logging.info("MT5ConnectionManager connected successfully")
                    return
                else:
                    logging.error("MT5ConnectionManager connection failed")
            except Exception as e:
                logging.error(f"MT5ConnectionManager error: {e}")
        
        # Fallback to direct MT5 connection
        if mt5.initialize():
            authorized = mt5.login(int(self.account), password=self.password, server=self.server)
            if authorized:
                self.connected = True
                logging.info("Direct MT5 connection successful")
            else:
                logging.error(f"Meta Trader login failed, error code: {mt5.last_error()}")
                mt5.shutdown()
        else:
            logging.error(f"Meta Trader initialize failed, error code: {mt5.last_error()}")

    def shutdown(self):
        if self.connected:
            if self.connection_manager:
                self.connection_manager.disconnect()
                logging.info("MT5ConnectionManager disconnected")
            elif MT5_AVAILABLE:
                mt5.shutdown()
                logging.info("Direct MT5 shutdown completed")
            self.connected = False

    def perform_account_scan(self):
        """Perform account scan and save results"""
        if not self.connected:
            logging.warning("MT5 not connected, cannot perform account scan")
            return None
            
        if self.connection_manager:
            try:
                # Use MT5ConnectionManager's scan functionality with overwrite mode
                scan_file = self.connection_manager._save_timestamped_scan()
                if scan_file:
                    logging.info(f"Account scan completed: {scan_file}")
                    # Also print status
                    self.connection_manager.print_essential_status()
                    return scan_file
                else:
                    logging.error("Account scan failed")
                    return None
            except Exception as e:
                logging.error(f"Account scan error: {e}")
                return None
        else:
            logging.warning("MT5ConnectionManager not available, cannot perform detailed account scan")
            return None

    def get_all_symbols(self):
        if not MT5_AVAILABLE:
            # Return mock symbols for testing
            return ["XAUUSD", "EURUSD", "GBPUSD", "USDJPY", "AUDUSD", "USDCAD", "NZDUSD", "USDCHF"]
            
        symbols = mt5.symbols_get()
        if symbols is None:
            logging.error("Could not retrieve symbols from Meta Trader")
            return []
        return [s.name for s in symbols]

    def ensure_symbol_ready(self, symbol):
        if not MT5_AVAILABLE:
            return True  # Mock success
            
        info = mt5.symbol_info(symbol)
        if info is None:
            logging.error(f"Symbol '{symbol}' not found on broker")
            return False
        if not info.visible:
            logging.warning(f"Symbol '{symbol}' not visible. Adding to Market Watch...")
            if not mt5.symbol_select(symbol, True):
                logging.error(f"Failed to add symbol '{symbol}' to Market Watch")
                return False
            else:
                logging.info(f"Symbol '{symbol}' added to Market Watch")
        return True

class CandlestickChart(QWidget):
    """Widget for realtime candlestick chart"""
    
    def __init__(self, indicator_tab=None):
        super().__init__()
        self.layout = QVBoxLayout()
        self.indicator_tab = indicator_tab  # Reference to IndicatorTab
        self.mt5_conn = None  # Will be set by parent
        
        if not MATPLOTLIB_AVAILABLE:
            self.error_label = QLabel("âŒ Matplotlib not available - please install with: pip install matplotlib")
            self.error_label.setStyleSheet("color: red; font-weight: bold; padding: 20px;")
            self.layout.addWidget(self.error_label)
            self.setLayout(self.layout)
            return
        
        # Create matplotlib figure
        self.figure = Figure(figsize=(12, 8), facecolor='#2b2b2b')
        self.canvas = FigureCanvas(self.figure)
        self.ax = self.figure.add_subplot(111, facecolor='#1e1e1e')
        
        # Chart data storage
        self.ohlc_data = []
        self.dates = []
        self.volumes = []
        
        # Chart settings - removed fixed MA, now dynamic from IndicatorTab
        self.show_price_line = True  # Show current price line
        
        # Interactive features
        self.crosshair_enabled = True
        self.crosshair_h = None  # Horizontal line
        self.crosshair_v = None  # Vertical line
        self.info_text = None    # Info text box
        
        # Navigation features
        self.pan_enabled = True
        self.zoom_enabled = True
        self.press = None  # For pan functionality
        
        # Timer for real-time updates
        self.update_timer = QTimer()
        self.update_timer.timeout.connect(self.update_chart)
        
        # Current symbol and timeframe
        self.current_symbol = None
        self.current_timeframe = None
        
        self.setup_chart()
        
        # Setup interactive events FIRST (creates toolbar and time widget)
        self.setup_interactive_events()
        
        # Then add canvas
        self.layout.addWidget(self.canvas)
        
        # Create MT5-style trading panel EXACTLY like MT5
        self.create_mt5_trading_panel()
        
        self.setLayout(self.layout)
    
    def setup_chart(self):
        """Setup beautiful chart appearance like MT5"""
        if not MATPLOTLIB_AVAILABLE:
            return
            
        # MT5-style dark theme background
        self.ax.set_facecolor('#1a1a1a')  # Very dark background like MT5
        
        # MT5-style grid
        self.ax.grid(True, alpha=0.15, color='#404040', linewidth=0.8, linestyle='-')
        self.ax.set_axisbelow(True)  # Grid behind chart elements
        
        # Enhanced tick styling (MT5-like)
        self.ax.tick_params(colors='#cccccc', labelsize=9, width=1, length=5)
        self.ax.tick_params(axis='x', rotation=0)
        
        # Price axis on right side (MT5 style)
        self.ax.yaxis.tick_right()
        self.ax.yaxis.set_label_position("right")
        
        # MT5-style borders
        for spine in self.ax.spines.values():
            spine.set_color('#404040')
            spine.set_linewidth(1.2)
        
        # Set axis labels color
        self.ax.xaxis.label.set_color('#cccccc')
        self.ax.yaxis.label.set_color('#cccccc')
        
        # MT5-style figure background
        self.figure.patch.set_facecolor('#2d2d2d')  # MT5-like figure background
        
        # Clean MT5-style borders
        self.ax.spines['top'].set_visible(False)
        self.ax.spines['left'].set_visible(False)
        self.ax.spines['right'].set_visible(True)
        self.ax.spines['bottom'].set_visible(True)
        
        # MT5-style border colors
        self.ax.spines['right'].set_color('#555555')
        self.ax.spines['bottom'].set_color('#555555')

    def create_mt5_trading_panel(self):
        """Create MT5-style trading panel overlay in top-left corner with toggle button"""
        if not MATPLOTLIB_AVAILABLE:
            return
            
        # Create trading panel as overlay widget on chart
        self.mt5_overlay = QWidget(self)
        self.mt5_overlay.setFixedSize(300, 95)  # Smaller height without price display
        self.mt5_overlay.move(15, 60)  # Position in top-left corner (moved down a bit)
        
        # Main panel background (MT5 dark style) - make it more visible
        self.mt5_overlay.setStyleSheet("""
            QWidget {
                background-color: rgba(20, 20, 20, 0.98);
                border: 2px solid #ffa726;
                border-radius: 8px;
            }
        """)
        
        # Main layout
        overlay_layout = QVBoxLayout(self.mt5_overlay)
        overlay_layout.setContentsMargins(3, 3, 3, 3)
        overlay_layout.setSpacing(3)
        
        # Header with toggle button (like MT5)
        header_layout = QHBoxLayout()
        
        # Title
        title_label = QLabel("One Click Trading")
        title_label.setStyleSheet("""
            QLabel {
                color: #cccccc;
                font-size: 12px;
                font-weight: bold;
                padding: 2px;
            }
        """)
        header_layout.addWidget(title_label)
        
        header_layout.addStretch()
        
        # Toggle button (minimize/restore like MT5)
        self.toggle_btn = QPushButton("âˆ’")
        self.toggle_btn.setFixedSize(20, 20)
        self.toggle_btn.setStyleSheet("""
            QPushButton {
                background-color: #404040;
                color: #cccccc;
                border: 1px solid #666666;
                border-radius: 2px;
                font-size: 13px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #555555;
            }
        """)
        self.toggle_btn.clicked.connect(self.toggle_mt5_panel)
        header_layout.addWidget(self.toggle_btn)
        
        overlay_layout.addLayout(header_layout)
        
        # Trading content (collapsible)
        self.trading_content = QWidget()
        content_layout = QVBoxLayout(self.trading_content)
        content_layout.setContentsMargins(0, 0, 0, 0)
        content_layout.setSpacing(3)
        
        # Volume and Spread section
        volume_layout = QHBoxLayout()
        volume_label = QLabel("Volume:")
        volume_label.setStyleSheet("color: #cccccc; font-size: 12px;")
        volume_layout.addWidget(volume_label)
        
        self.mt5_volume = QDoubleSpinBox()
        self.mt5_volume.setRange(0.01, 100.0)
        self.mt5_volume.setSingleStep(0.01)
        self.mt5_volume.setValue(0.10)
        self.mt5_volume.setDecimals(2)
        self.mt5_volume.setFixedWidth(80)
        self.mt5_volume.setStyleSheet("""
            QDoubleSpinBox {
                background-color: #2a2a2a;
                color: #ffffff;
                border: 1px solid #555555;
                border-radius: 3px;
                padding: 3px;
                font-size: 12px;
            }
        """)
        volume_layout.addWidget(self.mt5_volume)
        
        # Add spacing between volume and spread
        volume_layout.addWidget(QLabel(""))
        
        # Spread display
        spread_label = QLabel("Spread:")
        spread_label.setStyleSheet("color: #cccccc; font-size: 12px;")
        volume_layout.addWidget(spread_label)
        
        self.spread_display = QLabel("--")
        self.spread_display.setFixedWidth(60)
        self.spread_display.setStyleSheet("""
            QLabel {
                background-color: #2a2a2a;
                color: #ffeb3b;
                border: 1px solid #555555;
                border-radius: 3px;
                padding: 3px;
                font-size: 12px;
                font-weight: bold;
                text-align: center;
            }
        """)
        self.spread_display.setAlignment(Qt.AlignCenter)
        volume_layout.addWidget(self.spread_display)
        
        volume_layout.addStretch()
        
        content_layout.addLayout(volume_layout)
        
        # Trading buttons (optimized MT5 style - táº­n dá»¥ng tá»‘i Ä‘a khÃ´ng gian)
        buttons_layout = QHBoxLayout()
        buttons_layout.setSpacing(8)  # Increased spacing
        
        # SELL button (red, with bid price) - larger to utilize space
        self.mt5_sell_btn = QPushButton("SELL\n--")
        self.mt5_sell_btn.setFixedSize(130, 45)  # Much larger size to utilize space
        self.mt5_sell_btn.setStyleSheet("""
            QPushButton {
                background-color: #d32f2f;
                color: white;
                border: 1px solid #b71c1c;
                border-radius: 4px;
                font-size: 12px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #f44336;
            }
            QPushButton:disabled {
                background-color: #666666;
                color: #999999;
            }
        """)
        self.mt5_sell_btn.clicked.connect(self.on_mt5_sell_click)
        self.mt5_sell_btn.setEnabled(False)
        buttons_layout.addWidget(self.mt5_sell_btn)
        
        # BUY button (green, with ask price) - larger to utilize space
        self.mt5_buy_btn = QPushButton("BUY\n--")
        self.mt5_buy_btn.setFixedSize(130, 45)  # Much larger size to utilize space
        self.mt5_buy_btn.setStyleSheet("""
            QPushButton {
                background-color: #388e3c;
                color: white;
                border: 1px solid #2e7d32;
                border-radius: 4px;
                font-size: 12px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #4caf50;
            }
            QPushButton:disabled {
                background-color: #666666;
                color: #999999;
            }
        """)
        self.mt5_buy_btn.clicked.connect(self.on_mt5_buy_click)
        self.mt5_buy_btn.setEnabled(False)
        buttons_layout.addWidget(self.mt5_buy_btn)
        
        content_layout.addLayout(buttons_layout)
        
        overlay_layout.addWidget(self.trading_content)
        
        # Initially show the panel and make sure it's visible
        self.mt5_overlay.show()
        self.mt5_overlay.raise_()  # Bring to front
        self.is_panel_collapsed = False
        
        # Add a debug print to confirm panel creation
        print("âœ… MT5 Trading Panel created and positioned at (15, 45) - Optimized layout without price display")
    
    def setup_interactive_events(self):
        """Setup interactive mouse events for crosshair and pan/zoom"""
        if not MATPLOTLIB_AVAILABLE:
            return
            
        # Connect mouse events
        self.canvas.mpl_connect('motion_notify_event', self.on_mouse_move)
        self.canvas.mpl_connect('button_press_event', self.on_mouse_press)
        self.canvas.mpl_connect('button_release_event', self.on_mouse_release)
        self.canvas.mpl_connect('scroll_event', self.on_mouse_scroll)
        self.canvas.mpl_connect('axes_leave_event', self.on_mouse_leave)  # New: Handle mouse leave
        
        # Enable navigation toolbar functionality - optimized size for visibility
        from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT
        self.toolbar = NavigationToolbar2QT(self.canvas, self)
        self.toolbar.setFixedHeight(35)  # Increased height for better visibility
        self.toolbar.setStyleSheet("""
            QToolBar {
                background-color: #2d2d2d;
                border: 1px solid #555555;
                spacing: 2px;
                padding: 3px;
            }
            QToolButton {
                background-color: #404040;
                color: #cccccc;
                border: 1px solid #666666;
                border-radius: 3px;
                padding: 3px;
                margin: 1px;
                min-width: 28px;
                min-height: 28px;
                max-width: 32px;
                max-height: 32px;
                font-size: 10px;
            }
            QToolButton:hover {
                background-color: #555555;
                border: 1px solid #ffa726;
            }
            QToolButton:pressed {
                background-color: #ffa726;
                border: 1px solid #ff8f00;
            }
        """)
        self.layout.addWidget(self.toolbar)  # Add toolbar at top first
        
        # Configure toolbar status bar for time display
        self.setup_toolbar_status()
        
        # Setup custom coordinate formatter to show only time (no X Y coordinates)
        self._current_time_display = "Time: --"
        self._original_format_coord = self.ax.format_coord
        
        def custom_format_coord(x, y):
            """Custom coordinate formatter that shows only time"""
            try:
                # Show only time in the status bar
                time_part = getattr(self, '_current_time_display', 'Time: --')
                return time_part
            except:
                return "Time: --"
        
        # Set the custom formatter
        self.ax.format_coord = custom_format_coord
    
    def setup_toolbar_status(self):
        """Setup matplotlib toolbar status bar for time display"""
        try:
            if hasattr(self, 'toolbar') and self.toolbar:
                # Try to access and configure the status bar
                if hasattr(self.toolbar, 'locLabel'):
                    # This is the coordinate display label in matplotlib toolbar
                    self.toolbar.locLabel.setMinimumWidth(200)
                    self.toolbar.locLabel.setStyleSheet("""
                        QLabel {
                            color: #ffa726;
                            background-color: #2d2d2d;
                            padding: 2px 5px;
                            font-size: 10px;
                            font-weight: bold;
                        }
                    """)
                    print("âœ… Toolbar status bar configured for time display")
                elif hasattr(self.toolbar, '_message'):
                    # Alternative message label
                    self.toolbar._message.setStyleSheet("""
                        QLabel {
                            color: #ffa726;
                            background-color: #2d2d2d;
                            padding: 2px 5px;
                            font-size: 10px;
                        }
                    """)
                    print("âœ… Toolbar message label configured")
                else:
                    print("âš ï¸ No suitable status bar element found in toolbar")
        except Exception as e:
            print(f"âŒ Toolbar status setup failed: {e}")
    
    def on_mouse_move(self, event):
        """Handle mouse movement for crosshair and info display - optimized for smooth performance"""
        if not MATPLOTLIB_AVAILABLE or not self.crosshair_enabled or event.inaxes != self.ax:
            return
            
        if len(self.ohlc_data) == 0:
            return
            
        # Get mouse position
        x, y = event.xdata, event.ydata
        if x is None or y is None:
            return
            
        # Find nearest candle
        candle_idx = int(round(x))
        if candle_idx < 0 or candle_idx >= len(self.ohlc_data):
            return
            
        # Throttle updates for better performance - only update every few pixels
        if hasattr(self, '_last_mouse_pos'):
            last_x, last_y = self._last_mouse_pos
            if abs(x - last_x) < 0.5 and abs(y - last_y) < (self.ax.get_ylim()[1] - self.ax.get_ylim()[0]) * 0.01:
                return
        
        self._last_mouse_pos = (x, y)
            
        # Update crosshair and info with optimized drawing
        try:
            self.update_crosshair(x, y)
            self.show_candle_info(candle_idx, x, y)
            
            # Update time display safely
            try:
                self.update_time_display(candle_idx)
            except Exception as e:
                # Silently handle time display errors
                pass
            
            # Use blit for faster drawing instead of full redraw
            self.canvas.draw_idle()
        except Exception as e:
            # Silently handle crosshair errors but print for debugging
            print(f"Mouse move error: {e}")
            pass
        """Test function to check if time widget is working"""
        try:
            print("\nðŸ” === TIME WIDGET DEBUG TEST ===")
            
            # Check widget existence and visibility
            if hasattr(self, 'time_widget'):
                print(f"âœ… time_widget exists: {self.time_widget}")
                print(f"   - visible: {self.time_widget.isVisible()}")
                print(f"   - size: {self.time_widget.size()}")
                print(f"   - geometry: {self.time_widget.geometry()}")
                print(f"   - parent: {self.time_widget.parent()}")
                
                # Force show the widget
                self.time_widget.show()
                self.time_widget.setVisible(True)
                self.time_widget.raise_()
                
            else:
                print("âŒ time_widget NOT FOUND!")
            
            # Check label existence and visibility
            if hasattr(self, 'time_label'):
                print(f"âœ… time_label exists: {self.time_label}")
                print(f"   - visible: {self.time_label.isVisible()}")
                print(f"   - text: '{self.time_label.text()}'")
                print(f"   - size: {self.time_label.size()}")
                print(f"   - parent: {self.time_label.parent()}")
                
                # Test updating the label
                self.time_label.setText("Time: TEST 2025.08.10 15:30")
                self.time_label.show()
                self.time_label.setVisible(True)
                
                print(f"   - updated text: '{self.time_label.text()}'")
                
            else:
                print("âŒ time_label NOT FOUND!")
            
            # Check layout
            if hasattr(self, 'layout'):
                print(f"âœ… Main layout has {self.layout.count()} widgets:")
                for i in range(self.layout.count()):
                    widget = self.layout.itemAt(i).widget()
                    if widget:
                        print(f"   - Widget {i}: {type(widget).__name__} - visible: {widget.isVisible()}")
            
            # Start a demo timer to update time every 2 seconds
            if hasattr(self, 'time_label'):
                self.demo_timer = QTimer()
                self.demo_timer.timeout.connect(self.demo_time_update)
                self.demo_timer.start(2000)
                self.demo_counter = 0
                print("ï¿½ Starting demo time updates every 2 seconds...")
            
            print("ï¿½ðŸ” === END DEBUG TEST ===\n")
            
        except Exception as e:
            print(f"âŒ Time widget test error: {e}")
            import traceback
            traceback.print_exc()
    
    def on_mouse_move(self, event):
        """Handle mouse movement for crosshair and info display - optimized for smooth performance"""
        if not MATPLOTLIB_AVAILABLE or not self.crosshair_enabled or event.inaxes != self.ax:
            return
            
        if len(self.ohlc_data) == 0:
            return
            
        # Get mouse position
        x, y = event.xdata, event.ydata
        if x is None or y is None:
            return
            
        # Find nearest candle
        candle_idx = int(round(x))
        if candle_idx < 0 or candle_idx >= len(self.ohlc_data):
            return
            
        # Throttle updates for better performance - only update every few pixels
        if hasattr(self, '_last_mouse_pos'):
            last_x, last_y = self._last_mouse_pos
            if abs(x - last_x) < 0.5 and abs(y - last_y) < (self.ax.get_ylim()[1] - self.ax.get_ylim()[0]) * 0.01:
                return
        
        self._last_mouse_pos = (x, y)
            
        # Update crosshair and info with optimized drawing
        try:
            self.update_crosshair(x, y)
            self.show_candle_info(candle_idx, x, y)
            
            # Update time display safely
            try:
                self.update_time_display(candle_idx)
            except Exception as e:
                # Silently handle time display errors
                pass
            
            # Use blit for faster drawing instead of full redraw
            self.canvas.draw_idle()
        except Exception as e:
            # Silently handle crosshair errors but print for debugging
            print(f"Mouse move error: {e}")
            pass
    
    def on_mouse_press(self, event):
        """Handle mouse press for pan functionality"""
        if event.inaxes != self.ax:
            return
        self.press = (event.x, event.y)
    
    def on_mouse_release(self, event):
        """Handle mouse release for pan functionality"""
        self.press = None
        self.canvas.draw_idle()
    
    def on_mouse_scroll(self, event):
        """Handle mouse scroll for zoom functionality"""
        if not self.zoom_enabled or event.inaxes != self.ax:
            return
            
        # Get current axis limits
        xlim = self.ax.get_xlim()
        ylim = self.ax.get_ylim()
        
        # Zoom factor
        zoom_factor = 1.2 if event.step < 0 else 1/1.2
        
        # Calculate new limits
        x_center = event.xdata if event.xdata else (xlim[0] + xlim[1]) / 2
        y_center = event.ydata if event.ydata else (ylim[0] + ylim[1]) / 2
        
        x_range = (xlim[1] - xlim[0]) * zoom_factor / 2
        y_range = (ylim[1] - ylim[0]) * zoom_factor / 2
        
        # Set new limits
        self.ax.set_xlim(x_center - x_range, x_center + x_range)
        self.ax.set_ylim(y_center - y_range, y_center + y_range)
        
        self.canvas.draw_idle()
    
    def on_mouse_leave(self, event):
        """Handle mouse leaving the chart area - clear time display and candle info"""
        try:
            # Clear time display in coordinate formatter (reset to default)
            self._current_time_display = "--"
            
            # Clear candle info display
            try:
                if self.info_text:
                    if hasattr(self.info_text, 'remove'):
                        self.info_text.remove()
                    self.info_text = None
            except Exception:
                pass
            
            # Clear crosshair
            try:
                if self.crosshair_h:
                    if hasattr(self.crosshair_h, 'remove'):
                        self.crosshair_h.remove()
                    self.crosshair_h = None
            except Exception:
                pass
                
            try:
                if self.crosshair_v:
                    if hasattr(self.crosshair_v, 'remove'):
                        self.crosshair_v.remove()
                    self.crosshair_v = None
            except Exception:
                pass
            
            # Redraw canvas
            try:
                self.canvas.draw_idle()
            except Exception:
                pass
            
        except Exception as e:
            print(f"Mouse leave error: {e}")
            pass
    
    def update_crosshair(self, x, y):
        """Update crosshair lines - improved safe removal method"""
        # Safely remove old crosshair with multiple methods
        try:
            if self.crosshair_h:
                if hasattr(self.crosshair_h, 'remove'):
                    self.crosshair_h.remove()
                elif self.crosshair_h in self.ax.lines:
                    self.ax.lines.remove(self.crosshair_h)
        except (ValueError, AttributeError, NotImplementedError):
            pass
        
        try:
            if self.crosshair_v:
                if hasattr(self.crosshair_v, 'remove'):
                    self.crosshair_v.remove()
                elif self.crosshair_v in self.ax.lines:
                    self.ax.lines.remove(self.crosshair_v)
        except (ValueError, AttributeError, NotImplementedError):
            pass
        
        # Clear and reset crosshair references
        self.crosshair_h = None
        self.crosshair_v = None
            
        # Draw new crosshair
        self.crosshair_h = self.ax.axhline(y=y, color='#ffa726', linewidth=1, alpha=0.7, linestyle='--')
        self.crosshair_v = self.ax.axvline(x=x, color='#ffa726', linewidth=1, alpha=0.7, linestyle='--')
    
    def update_time_display(self, candle_idx):
        """Update time display in matplotlib's status bar coordinates area (time only, no X Y)"""
        try:
            if candle_idx >= len(self.dates):
                return
                
            # Get the date for this candle
            date = self.dates[candle_idx]
            
            # Format date based on timeframe for time display
            tf_str = str(self.current_timeframe) if self.current_timeframe else ""
            
            if 'MN' in tf_str or self.current_timeframe in [49153]:  # Monthly
                time_display = date.strftime('%Y %B')  # "2024 January"
            elif 'W' in tf_str or self.current_timeframe in [32769]:  # Weekly
                time_display = date.strftime('%Y.%m.%d (Week %U)')  # "2024.01.15 (Week 03)"
            elif 'D' in tf_str or self.current_timeframe in [16408]:  # Daily
                time_display = date.strftime('%Y.%m.%d (%A)')  # "2024.01.15 (Monday)"
            elif 'H' in tf_str or self.current_timeframe in [16385, 16388]:  # Hours
                time_display = date.strftime('%Y.%m.%d %H:00')  # "2024.01.15 14:00"
            elif 'M' in tf_str or self.current_timeframe in [1, 5, 15, 30]:  # Minutes
                time_display = date.strftime('%Y.%m.%d %H:%M')  # "2024.01.15 14:30"
            else:
                time_display = date.strftime('%Y.%m.%d %H:%M')  # Default
            
            # Update the time display for coordinate formatter (time only)
            self._current_time_display = time_display
                
        except Exception as e:
            print(f"Time display error: {e}")
            pass
    
    def show_candle_info(self, candle_idx, x, y):
        """Show detailed candle information"""
        try:
            if candle_idx >= len(self.ohlc_data) or candle_idx >= len(self.dates):
                return
                
            # Get candle data
            ohlc = self.ohlc_data[candle_idx]
            date = self.dates[candle_idx]
            volume = self.volumes[candle_idx] if candle_idx < len(self.volumes) else 0
            
            open_price, high, low, close = ohlc
            
            # Format prices with correct decimals
            o_formatted = self.format_price_mt5_style(open_price)
            h_formatted = self.format_price_mt5_style(high)
            l_formatted = self.format_price_mt5_style(low)
            c_formatted = self.format_price_mt5_style(close)
            
            # Create compact info text for candle top display - single column format
            change = close - open_price
            change_pct = (change / open_price) * 100 if open_price != 0 else 0
            change_symbol = '+' if change >= 0 else ''
            
            # Single column info for display above candle
            info_text = f"O: {o_formatted}\nH: {h_formatted}\nL: {l_formatted}\nC: {c_formatted}\nVol: {volume:,.0f}\n{change_symbol}{self.format_price_mt5_style(abs(change))} ({change_pct:+.2f}%)"
            
            # Remove old info text safely
            try:
                if self.info_text and hasattr(self.info_text, 'remove'):
                    self.info_text.remove()
            except (ValueError, AttributeError, NotImplementedError):
                pass
            self.info_text = None
            
            # Position info box above the current candle
            candle_high = ohlc[1]  # High price of the candle
            ylim = self.ax.get_ylim()
            
            # Position above the candle high with some margin
            info_y = candle_high + (ylim[1] - ylim[0]) * 0.02  # Slightly above the candle high
            info_x = candle_idx  # X position at the candle
            
            # Make sure info box doesn't go off screen
            if info_y > ylim[1] * 0.95:  # If too close to top
                info_y = candle_high - (ylim[1] - ylim[0]) * 0.08  # Place below candle instead
                va = 'top'
            else:
                va = 'bottom'
            
            # Determine text color based on candle direction
            text_color = '#00e676' if change >= 0 else '#ff1744'  # Green for bullish, red for bearish
            
            # Add info text box positioned above/below the candle
            self.info_text = self.ax.text(info_x, info_y, info_text,
                                         fontsize=8, fontweight='bold',
                                         color=text_color, ha='center', va=va,
                                         bbox=dict(boxstyle='round,pad=0.4',
                                                 facecolor=(0.08, 0.08, 0.08, 0.9),  # Dark gray with alpha
                                                 edgecolor=text_color,
                                                 linewidth=1.5,
                                                 alpha=0.95))
                                                 
        except Exception as e:
            # Print error for debugging but don't crash
            print(f"Candle info error: {e}")
            pass

    def toggle_mt5_panel(self):
        """Toggle MT5 trading panel visibility (like MT5)"""
        if not hasattr(self, 'trading_content'):
            return
            
        if self.is_panel_collapsed:
            # Expand panel
            self.trading_content.show()
            self.toggle_btn.setText("âˆ’")
            self.mt5_overlay.setFixedSize(300, 95)  # Updated size without price display
            self.is_panel_collapsed = False
        else:
            # Collapse panel
            self.trading_content.hide()
            self.toggle_btn.setText("+")
            self.mt5_overlay.setFixedSize(300, 25)  # Only header visible
            self.is_panel_collapsed = True

    def resizeEvent(self, event):
        """Handle widget resize to keep overlay positioned correctly"""
        super().resizeEvent(event)
        if hasattr(self, 'mt5_overlay'):
            # Keep panel in top-left corner when window resizes
            self.mt5_overlay.move(15, 60)
            self.mt5_overlay.raise_()  # Bring to front after resize
            
        # Reposition message overlay if it exists
        if hasattr(self, 'message_overlay') and self.message_overlay.isVisible():
            self.message_overlay.move(self.width()//2 - 250, 60)
            self.message_overlay.raise_()

    def update_mt5_buttons_with_prices(self):
        """Update MT5 buttons with real-time bid/ask prices using proper decimals"""
        if not hasattr(self, 'mt5_sell_btn') or not hasattr(self, 'mt5_buy_btn'):
            return
            
        if not self.current_symbol:
            self.mt5_sell_btn.setText("SELL\n--")
            self.mt5_buy_btn.setText("BUY\n--")
            return
            
        try:
            import MetaTrader5 as mt5
            if mt5.initialize():
                tick = mt5.symbol_info_tick(self.current_symbol)
                if tick:
                    bid_price = tick.bid
                    ask_price = tick.ask
                    
                    # Format prices with correct decimal places
                    bid_formatted = self.format_price_mt5_style(bid_price)
                    ask_formatted = self.format_price_mt5_style(ask_price)
                    
                    # Update buttons with properly formatted prices
                    self.mt5_sell_btn.setText(f"SELL\n{bid_formatted}")
                    self.mt5_buy_btn.setText(f"BUY\n{ask_formatted}")
                else:
                    self.mt5_sell_btn.setText("SELL\n--")
                    self.mt5_buy_btn.setText("BUY\n--")
            else:
                self.mt5_sell_btn.setText("SELL\n--")
                self.mt5_buy_btn.setText("BUY\n--")
                
        except Exception as e:
            self.mt5_sell_btn.setText("SELL\n--")
            self.mt5_buy_btn.setText("BUY\n--")

    def update_mt5_buttons_state(self):
        """Update MT5 button states"""
        if hasattr(self, 'mt5_buy_btn') and hasattr(self, 'mt5_sell_btn'):
            has_connection = self.mt5_conn is not None
            has_symbol = self.current_symbol is not None
            can_trade = has_connection and has_symbol and ORDER_EXECUTOR_AVAILABLE
            
            self.mt5_buy_btn.setEnabled(can_trade)
            self.mt5_sell_btn.setEnabled(can_trade)
            
            # Update prices
            self.update_mt5_buttons_with_prices()

    def execute_mt5_buy(self):
        """Execute BUY order MT5 style"""
        if not ORDER_EXECUTOR_AVAILABLE:
            self.show_trading_message("âŒ Order executor not available!", "error")
            return
            
        if not self.current_symbol:
            self.show_trading_message("âŒ No symbol selected!", "error")
            return
            
        if not self.mt5_conn:
            self.show_trading_message("âŒ No MT5 connection!", "error")
            return
        
        try:
            volume = self.mt5_volume.value()
            
            # Create order executor instance
            from order_executor import get_executor_instance, TradeSignal
            import MetaTrader5 as mt5
            
            # Get current price
            tick = mt5.symbol_info_tick(self.current_symbol)
            if not tick:
                self.show_trading_message("âŒ Cannot get price data!", "error")
                return
            
            executor = get_executor_instance()
            
            # Format price for display
            price_formatted = self.format_price_mt5_style(tick.ask)
            
            # Create trade signal for BUY
            signal = TradeSignal(
                symbol=self.current_symbol,
                action="BUY",
                entry_price=tick.ask,
                stop_loss=0.0,
                take_profit=0.0,
                volume=volume,
                comment="MT5 BUY"
            )
            
            # Execute market buy order
            result = executor.execute_market_order(signal)
            
            if result.success:
                self.show_trading_message(f"âœ… BUY {volume} {self.current_symbol} @ {price_formatted}", "success")
            else:
                self.show_trading_message(f"âŒ BUY failed: {result.error_message}", "error")
                
        except Exception as e:
            self.show_trading_message(f"âŒ BUY error: {str(e)}", "error")

    def execute_mt5_sell(self):
        """Execute SELL order MT5 style"""
        if not ORDER_EXECUTOR_AVAILABLE:
            self.show_trading_message("âŒ Order executor not available!", "error")
            return
            
        if not self.current_symbol:
            self.show_trading_message("âŒ No symbol selected!", "error")
            return
            
        if not self.mt5_conn:
            self.show_trading_message("âŒ No MT5 connection!", "error")
            return
        
        try:
            volume = self.mt5_volume.value()
            
            # Create order executor instance
            from order_executor import get_executor_instance, TradeSignal
            import MetaTrader5 as mt5
            
            # Get current price
            tick = mt5.symbol_info_tick(self.current_symbol)
            if not tick:
                self.show_trading_message("âŒ Cannot get price data!", "error")
                return
            
            executor = get_executor_instance()
            
            # Format price for display
            price_formatted = self.format_price_mt5_style(tick.bid)
            
            # Create trade signal for SELL
            signal = TradeSignal(
                symbol=self.current_symbol,
                action="SELL",
                entry_price=tick.bid,
                stop_loss=0.0,
                take_profit=0.0,
                volume=volume,
                comment="MT5 SELL"
            )
            
            # Execute market sell order
            result = executor.execute_market_order(signal)
            
            if result.success:
                self.show_trading_message(f"âœ… SELL {volume} {self.current_symbol} @ {price_formatted}", "success")
            else:
                self.show_trading_message(f"âŒ SELL failed: {result.error_message}", "error")
                
        except Exception as e:
            self.show_trading_message(f"âŒ SELL error: {str(e)}", "error")

    def set_mt5_connection(self, mt5_conn):
        """Set MT5 connection for trading operations"""
        self.mt5_conn = mt5_conn
        self.update_mt5_buttons_state()
        
    def start_realtime_update(self, symbol, timeframe, mt5_conn=None):
        """Start real-time chart updates"""
        if not MATPLOTLIB_AVAILABLE:
            return
            
        self.current_symbol = symbol
        self.current_timeframe = timeframe
        
        # Set MT5 connection if provided
        if mt5_conn:
            self.set_mt5_connection(mt5_conn)
            
        # Clear previous data
        self.ohlc_data = []
        self.dates = []
        self.volumes = []
        
        # Start optimized timer for smoother updates
        self.update_timer.start(3000)  # Update every 3 seconds for better performance
        
        # Start price update timer for MT5 buttons (every 2 seconds for smoother performance)
        if hasattr(self, 'mt5_price_timer'):
            self.mt5_price_timer.stop()
        self.mt5_price_timer = QTimer()
        self.mt5_price_timer.timeout.connect(self.update_mt5_prices)
        self.mt5_price_timer.start(2000)  # Update prices every 2 seconds
        
        # Start settings auto-refresh timer (every 5 seconds)
        if hasattr(self, 'settings_refresh_timer'):
            self.settings_refresh_timer.stop()
        self.settings_refresh_timer = QTimer()
        # Note: auto_refresh_settings is not needed for CandlestickChart
        # self.settings_refresh_timer.timeout.connect(self.auto_refresh_settings)
        # self.settings_refresh_timer.start(5000)  # Check for settings changes every 5 seconds
        
        self.update_chart()
    
    def stop_realtime_update(self):
        """Stop real-time updates"""
        if self.update_timer.isActive():
            self.update_timer.stop()
    
    def update_chart(self):
        """Update chart with latest data - Enhanced for W1 and MN1 support"""
        if not MATPLOTLIB_AVAILABLE or not self.current_symbol:
            return
            
        try:
            # Get latest data from MT5
            import MetaTrader5 as mt5
            from datetime import datetime, timedelta
            
            if not mt5.initialize():
                print(f"âš ï¸ MT5 initialization failed for chart update")
                return
            
            # Ensure symbol is available in Market Watch
            symbol_info = mt5.symbol_info(self.current_symbol)
            if symbol_info is None:
                print(f"âš ï¸ Symbol {self.current_symbol} not found")
                return
                
            if not symbol_info.visible:
                if not mt5.symbol_select(self.current_symbol, True):
                    print(f"âš ï¸ Failed to add {self.current_symbol} to Market Watch")
                    return
            
            # Get appropriate count based on timeframe
            tf_str = str(self.current_timeframe)
            if 'MN' in tf_str or self.current_timeframe in [49153]:  # Monthly
                count = 60  # 5 years of monthly data
            elif 'W' in tf_str or self.current_timeframe in [32769]:  # Weekly  
                count = 100  # ~2 years of weekly data
            elif 'D' in tf_str or self.current_timeframe in [16408]:  # Daily
                count = 100  # ~3 months of daily data
            else:
                count = 100  # Standard count for intraday
            
            # Get rates with enhanced error handling
            rates = mt5.copy_rates_from_pos(self.current_symbol, self.current_timeframe, 0, count)
            
            if rates is None or len(rates) == 0:
                # Try alternative method for W1/MN1
                if self.current_timeframe in [32769, 49153]:  # W1 or MN1
                    print(f"âš ï¸ Trying alternative method for {tf_str} data...")
                    
                    # Go back further for weekly/monthly data
                    days_back = 730 if self.current_timeframe == 49153 else 365  # 2 years for monthly, 1 year for weekly
                    from_date = datetime.now() - timedelta(days=days_back)
                    
                    rates = mt5.copy_rates_from(self.current_symbol, self.current_timeframe, from_date, count)
                
                if rates is None or len(rates) == 0:
                    print(f"âš ï¸ No data available for {self.current_symbol} {tf_str}")
                    return
            
            # Convert to OHLC format
            self.ohlc_data = []
            self.dates = []
            self.volumes = []
            
            for rate in rates:
                date = datetime.fromtimestamp(rate['time'])
                self.dates.append(date)
                self.ohlc_data.append([rate['open'], rate['high'], rate['low'], rate['close']])
                self.volumes.append(rate['tick_volume'])  # Add volume data
            
            print(f"âœ… Chart updated: {len(self.ohlc_data)} candles for {self.current_symbol} {tf_str}")
            self.draw_candlesticks()
            
        except Exception as e:
            print(f"Error updating chart: {e}")
            # Try to continue with existing data if available
            if len(self.ohlc_data) > 0:
                self.draw_candlesticks()
    
    def draw_candlesticks(self):
        """Draw beautiful candlestick chart without indicators"""
        if not MATPLOTLIB_AVAILABLE or len(self.ohlc_data) == 0:
            return
            
        # Clear chart safely
        self.ax.clear()
        
        # Reset crosshair references after clearing
        self.crosshair_h = None
        self.crosshair_v = None
        self.info_text = None
        
        self.setup_chart()
        
        # Calculate candle width based on number of candles for better visual
        candle_width = 0.8
        
        # Draw candlesticks with enhanced styling
        for i, (date, ohlc) in enumerate(zip(self.dates, self.ohlc_data)):
            open_price, high, low, close = ohlc
            
            # Determine if bullish or bearish
            is_bullish = close >= open_price
            
            # Enhanced colors for professional look
            if is_bullish:
                body_color = '#00e676'  # Bright green
                wick_color = '#1de9b6'  # Teal green for wick
                edge_color = '#00c853'  # Darker green edge
                shadow_color = '#00e676'
            else:
                body_color = '#ff1744'  # Bright red
                wick_color = '#ff5722'  # Orange-red for wick
                edge_color = '#d50000'  # Darker red edge
                shadow_color = '#ff1744'
            
            # Draw high-low wick with gradient effect
            self.ax.plot([i, i], [low, high], color=wick_color, linewidth=1.2, alpha=0.9, solid_capstyle='round')
            
            # Draw body rectangle with enhanced styling
            body_height = abs(close - open_price)
            body_bottom = min(open_price, close)
            
            # Handle doji candles (open == close) with special styling
            if body_height == 0:
                body_height = (high - low) * 0.03  # Slightly larger body for doji
                body_bottom = open_price - body_height/2
                # Special doji styling
                rect = Rectangle((i - candle_width/2, body_bottom), candle_width, body_height, 
                               facecolor='#ffc107', 
                               edgecolor='#ff8f00', 
                               linewidth=0.8,
                               alpha=0.95)
            else:
                # Regular candle styling with shadow effect
                rect = Rectangle((i - candle_width/2, body_bottom), candle_width, body_height, 
                               facecolor=body_color, 
                               edgecolor=edge_color, 
                               linewidth=0.5,
                               alpha=0.95)
            
            self.ax.add_patch(rect)
        
        # Add subtle price line connecting closes for trend visualization
        if len(self.ohlc_data) > 1 and self.show_price_line:
            close_prices = [candle[3] for candle in self.ohlc_data]
            self.ax.plot(range(len(close_prices)), close_prices, 
                        color='#64b5f6', linewidth=1.2, alpha=0.7, 
                        linestyle='-', zorder=1)
        
        # Enhanced axis formatting with MT5-style time labels
        if len(self.dates) > 0:
            # Use smart time labeling system
            x_ticks, x_labels = self.get_smart_time_labels(self.dates, self.current_timeframe)
            
            self.ax.set_xticks(x_ticks)
            self.ax.set_xticklabels(x_labels, rotation=0, fontsize=8, ha='center')
        
        # Enhanced price formatting on y-axis with symbol-specific decimals
        decimal_places = self.get_symbol_decimal_places(self.current_symbol)
        self.ax.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'{x:.{decimal_places}f}'))
        
        # Remove axis labels and make tick labels smaller (MT5 style)
        self.ax.set_xlabel('')  # Remove "Time" label
        self.ax.set_ylabel('')  # Remove "Price" label
        
        # Make tick labels smaller
        self.ax.tick_params(axis='x', labelsize=8)  # Smaller time labels
        self.ax.tick_params(axis='y', labelsize=8)  # Smaller price labels
        
        # Enhanced title with current price info (MT5-style decimals)
        if self.ohlc_data:
            current_candle = self.ohlc_data[-1]
            open_price, high, low, close = current_candle
            change = close - open_price
            change_pct = (change / open_price) * 100 if open_price != 0 else 0
            
            # Color based on change
            title_color = '#00e676' if change >= 0 else '#ff1744'
            change_symbol = '+' if change >= 0 else ''
            
            # Format prices with correct decimals
            o_formatted = self.format_price_mt5_style(open_price)
            h_formatted = self.format_price_mt5_style(high)
            l_formatted = self.format_price_mt5_style(low)
            c_formatted = self.format_price_mt5_style(close)
            change_formatted = self.format_price_mt5_style(abs(change))
            
            title = f"{self.current_symbol} | O: {o_formatted} H: {h_formatted} L: {l_formatted} C: {c_formatted} | {change_symbol}{change_formatted} ({change_pct:+.2f}%)"
            self.ax.set_title(title, color=title_color, fontsize=9, fontweight='bold', pad=8)
            
            # Add current price line in yellow with price label (like MT5)
            if self.show_price_line:
                current_price = close
                # Main price line (current close price only)
                self.ax.axhline(y=current_price, color='#ffa726', linewidth=2, alpha=0.9, linestyle='-')
                
                # Price label with correct decimals
                price_formatted = self.format_price_mt5_style(current_price)
                self.ax.text(len(self.ohlc_data) + 0.5, current_price, f' {price_formatted}', 
                            color='#ffa726', fontsize=9, fontweight='bold', 
                            verticalalignment='center', bbox=dict(boxstyle='round,pad=0.2', 
                            facecolor='#2a2a2a', edgecolor='#ffa726', alpha=0.8))
        
        # Adjust margins for better visualization
        self.ax.margins(x=0.02, y=0.05)
        
        # Set x-axis limits to create space for future candles
        if len(self.ohlc_data) > 0:
            extra_space = len(self.ohlc_data) * 0.05  # 5% extra space
            self.ax.set_xlim(-extra_space, len(self.ohlc_data) - 1 + extra_space)
        
        # Enhanced layout with optimized drawing
        self.figure.tight_layout(pad=0.8)  # Reduced padding for more compact layout
        
        # Draw the updated chart with optimized settings
        self.canvas.draw()
        
        # Update MT5 prices if connected
        if self.mt5_conn and hasattr(self.mt5_conn, 'connected') and self.mt5_conn.connected:
            self.update_mt5_prices()

    def get_symbol_decimal_places(self, symbol):
        """Get decimal places directly from MT5 symbol info"""
        if not symbol or not MT5_AVAILABLE:
            return 5
            
        try:
            # Get symbol info directly from MT5
            symbol_info = mt5.symbol_info(symbol)
            if symbol_info and hasattr(symbol_info, 'digits'):
                return symbol_info.digits
        except Exception as e:
            print(f"âš ï¸ Error getting symbol info for {symbol}: {e}")
        
        # Fallback to manual detection only if MT5 info is not available
        symbol_upper = symbol.upper()
        
        # JPY pairs typically use 3 decimal places
        if 'JPY' in symbol_upper:
            return 3
            
        # Indices typically use 2 decimal places
        if any(index in symbol_upper for index in ['US30', 'US500', 'NAS100', 'GER30', 'UK100', 'JPN225']):
            return 2
            
        # Metals typically use 2 decimal places
        if any(metal in symbol_upper for metal in ['XAU', 'XAG', 'GOLD', 'SILVER']):
            return 2
            
        # Default fallback for forex pairs
        return 5
            
        # Default fallback
        return 4

    def format_price_mt5_style(self, price, symbol=None):
        """Format price with correct decimal places like MT5"""
        if symbol is None:
            symbol = self.current_symbol
            
        decimal_places = self.get_symbol_decimal_places(symbol)
        return f'{price:.{decimal_places}f}'

    def get_smart_time_labels(self, dates, current_timeframe):
        """Generate smart time labels with current candle priority - Trading time format"""
        if not dates:
            return [], []
            
        # Determine label density based on chart size
        total_candles = len(dates)
        
        if total_candles <= 20:
            # Show every candle for small datasets
            step = 1
            max_labels = total_candles
        elif total_candles <= 50:
            # Show every 2-3 candles
            step = max(1, total_candles // 15)
            max_labels = 15
        elif total_candles <= 100:
            # Show every 5-8 candles  
            step = max(1, total_candles // 12)
            max_labels = 12
        else:
            # Show every 10+ candles for large datasets
            step = max(1, total_candles // 8)
            max_labels = 8
        
        # Always include the last candle (current trading)
        x_ticks = list(range(0, total_candles, step))
        if (total_candles - 1) not in x_ticks:
            x_ticks.append(total_candles - 1)
        
        # Limit total labels
        if len(x_ticks) > max_labels:
            # Keep first, last, and evenly spaced middle points
            keep_indices = [0]  # First
            middle_indices = x_ticks[1:-1]
            if len(middle_indices) > max_labels - 2:
                # Select evenly spaced middle points
                middle_step = len(middle_indices) // (max_labels - 2)
                keep_indices.extend(middle_indices[::middle_step][:max_labels-2])
            else:
                keep_indices.extend(middle_indices)
            keep_indices.append(x_ticks[-1])  # Last
            x_ticks = sorted(set(keep_indices))
        
        # Generate labels with MT5-style formatting - Updated time display logic
        x_labels = []
        for i, tick_idx in enumerate(x_ticks):
            date = dates[tick_idx]
            is_current = (tick_idx == total_candles - 1)  # Current trading candle
            
            # Determine timeframe type for appropriate time display
            tf_str = str(current_timeframe) if current_timeframe else ""
            
            # Check MN1 first (before M check) to avoid conflict
            if 'MN' in tf_str or current_timeframe in [49153]:  # Monthly timeframe (MN1=49153)
                # MN1: Show month and year (MMM YY)
                if is_current:
                    x_labels.append(f">{date.strftime('%b')}\n{date.strftime('%y')}")
                else:
                    x_labels.append(f"{date.strftime('%b')}\n{date.strftime('%y')}")
                    
            elif 'W' in tf_str or current_timeframe in [32769]:  # Weekly timeframe (W1=32769)
                # W1: Show week start date with month (DD/MM + week indicator)
                if is_current:
                    x_labels.append(f">{date.strftime('%d/%m')}\nW{date.isocalendar()[1]}")
                else:
                    x_labels.append(f"{date.strftime('%d/%m')}\nW{date.isocalendar()[1]}")
                    
            elif 'D' in tf_str or current_timeframe in [16408]:  # Daily timeframe (D1=16408)
                # D1: Only show date with day name (DD/MM + weekday)
                if is_current:
                    x_labels.append(f">{date.strftime('%d/%m')}\n{date.strftime('%a')}")
                else:
                    x_labels.append(f"{date.strftime('%d/%m')}\n{date.strftime('%a')}")
                    
            elif 'H' in tf_str or current_timeframe in [16385, 16388]:  # Hours timeframe (H1=16385, H4=16388)
                # H1-H4: Show full date and time (DD/MM HH:00)
                if is_current:
                    x_labels.append(f">{date.strftime('%d/%m')}\n{date.strftime('%H:00')}")
                else:
                    x_labels.append(f"{date.strftime('%d/%m')}\n{date.strftime('%H:00')}")
                        
            elif 'M' in tf_str or current_timeframe in [1, 5, 15, 30]:  # Minutes timeframe
                # M1-M30: Show full date and time (DD/MM HH:MM)
                if is_current:
                    x_labels.append(f">{date.strftime('%d/%m')}\n{date.strftime('%H:%M')}")
                else:
                    x_labels.append(f"{date.strftime('%d/%m')}\n{date.strftime('%H:%M')}")
                    
            else:  # Default fallback
                # Show date with day name for better context
                if is_current:
                    x_labels.append(f">{date.strftime('%d/%m')}\n{date.strftime('%a')}")
                else:
                    x_labels.append(f"{date.strftime('%d/%m')}\n{date.strftime('%a')}")
        
        return x_ticks, x_labels

    def update_mt5_buttons_state(self):
        """Update MT5 trading buttons state based on connection"""
        if not MATPLOTLIB_AVAILABLE or not hasattr(self, 'mt5_buy_btn'):
            return
            
        is_connected = self.mt5_conn and self.mt5_conn.connected
        
        # Enable/disable buttons
        self.mt5_buy_btn.setEnabled(is_connected)
        self.mt5_sell_btn.setEnabled(is_connected)
        self.mt5_volume.setEnabled(is_connected)
        
        # Update prices if connected
        if is_connected and self.current_symbol:
            self.update_mt5_prices()
        else:
            # Show disconnected state
            self.mt5_sell_btn.setText("SELL\n--")
            self.mt5_buy_btn.setText("BUY\n--")
            # Reset spread display
            if hasattr(self, 'spread_display'):
                self.spread_display.setText("--")
            
    def update_mt5_prices(self):
        """Update real-time bid/ask prices on MT5 buttons with proper decimals and spread in USD/LOT"""
        if not MATPLOTLIB_AVAILABLE or not hasattr(self, 'mt5_buy_btn'):
            return
            
        if not self.mt5_conn or not self.mt5_conn.connected or not self.current_symbol:
            return
            
        try:
            # Get current tick using MT5 directly
            import MetaTrader5 as mt5
            tick = mt5.symbol_info_tick(self.current_symbol)
            if tick:
                bid_price = tick.bid
                ask_price = tick.ask
                
                # Calculate spread in USD/LOT
                spread_raw = ask_price - bid_price
                
                # Get symbol info for contract specifications
                symbol_info = mt5.symbol_info(self.current_symbol)
                if symbol_info:
                    # Calculate spread in USD per 1 lot
                    # For most symbols: spread_usd = spread * contract_size * tick_value / tick_size
                    contract_size = symbol_info.trade_contract_size
                    tick_value = symbol_info.trade_tick_value
                    tick_size = symbol_info.trade_tick_size
                    
                    if tick_size > 0:
                        # Calculate spread cost in USD for 1 lot
                        spread_usd = (spread_raw / tick_size) * tick_value
                        
                        # Format spread as USD/LOT
                        if spread_usd >= 1:
                            spread_formatted = f"${spread_usd:.2f}"
                        elif spread_usd >= 0.1:
                            spread_formatted = f"${spread_usd:.3f}"
                        else:
                            spread_formatted = f"${spread_usd:.4f}"
                    else:
                        spread_formatted = f"${spread_raw:.2f}"
                else:
                    # Fallback calculation for standard lot
                    spread_formatted = f"${spread_raw * 100000:.2f}"
                
                # Format prices with correct decimal places for the symbol
                bid_formatted = self.format_price_mt5_style(bid_price)
                ask_formatted = self.format_price_mt5_style(ask_price)
                
                # Update button texts with properly formatted prices
                self.mt5_sell_btn.setText(f"SELL\n{bid_formatted}")
                self.mt5_buy_btn.setText(f"BUY\n{ask_formatted}")
                
                # Update spread display with USD/LOT
                if hasattr(self, 'spread_display'):
                    self.spread_display.setText(spread_formatted)
                
        except Exception as e:
            print(f"Error updating MT5 prices: {e}")
            # Reset spread display on error
            if hasattr(self, 'spread_display'):
                self.spread_display.setText("--")
            
    def on_mt5_sell_click(self):
        """Handle MT5 SELL button click"""
        if not self.mt5_conn or not self.mt5_conn.connected:
            return
            
        volume = self.mt5_volume.value()
        if volume <= 0:
            return
            
        try:
            from order_executor import get_executor_instance, TradeSignal
            import MetaTrader5 as mt5
            
            # Get current price for the signal
            tick = mt5.symbol_info_tick(self.current_symbol)
            if not tick:
                print(f"âŒ Cannot get tick data for {self.current_symbol}")
                return
            
            # Create order executor instance
            executor = get_executor_instance()
            
            # Create trade signal for SELL
            signal = TradeSignal(
                symbol=self.current_symbol,
                action="SELL",
                entry_price=tick.bid,  # Use bid price for SELL
                stop_loss=0.0,  # No SL for now
                take_profit=0.0,  # No TP for now
                volume=volume,
                comment="MT5 Panel SELL"
            )
            
            # Execute the order
            result = executor.execute_market_order(signal)
            
            if result.success:
                # Show success notification
                price_formatted = self.format_price_mt5_style(tick.bid)
                success_msg = f"âœ… SELL Order Executed!\n{self.current_symbol} | {volume} lots @ {price_formatted}\nTicket: {result.ticket}"
                self.show_trading_message(success_msg, "success")
                print(f"âœ… SELL order executed: {self.current_symbol} {volume} lots (Ticket: {result.ticket})")
            else:
                # Show error notification
                error_msg = f"âŒ SELL Order Failed!\n{result.error_message}"
                self.show_trading_message(error_msg, "error")
                print(f"âŒ SELL order failed: {result.error_message}")
                
        except Exception as e:
            # Show exception notification
            error_msg = f"âŒ SELL Order Error!\n{str(e)}"
            self.show_trading_message(error_msg, "error")
            print(f"Error executing SELL order: {e}")
            
    def on_mt5_buy_click(self):
        """Handle MT5 BUY button click"""
        if not self.mt5_conn or not self.mt5_conn.connected:
            return
            
        volume = self.mt5_volume.value()
        if volume <= 0:
            return
            
        try:
            from order_executor import get_executor_instance, TradeSignal
            import MetaTrader5 as mt5
            
            # Get current price for the signal
            tick = mt5.symbol_info_tick(self.current_symbol)
            if not tick:
                print(f"âŒ Cannot get tick data for {self.current_symbol}")
                return
            
            # Create order executor instance
            executor = get_executor_instance()
            
            # Create trade signal for BUY
            signal = TradeSignal(
                symbol=self.current_symbol,
                action="BUY",
                entry_price=tick.ask,  # Use ask price for BUY
                stop_loss=0.0,  # No SL for now
                take_profit=0.0,  # No TP for now
                volume=volume,
                comment="MT5 Panel BUY"
            )
            
            # Execute the order
            result = executor.execute_market_order(signal)
            
            if result.success:
                # Show success notification
                price_formatted = self.format_price_mt5_style(tick.ask)
                success_msg = f"âœ… BUY Order Executed!\n{self.current_symbol} | {volume} lots @ {price_formatted}\nTicket: {result.ticket}"
                self.show_trading_message(success_msg, "success")
                print(f"âœ… BUY order executed: {self.current_symbol} {volume} lots (Ticket: {result.ticket})")
            else:
                # Show error notification
                error_msg = f"âŒ BUY Order Failed!\n{result.error_message}"
                self.show_trading_message(error_msg, "error")
                print(f"âŒ BUY order failed: {result.error_message}")
                
        except Exception as e:
            # Show exception notification
            error_msg = f"âŒ BUY Order Error!\n{str(e)}"
            self.show_trading_message(error_msg, "error")
            print(f"Error executing BUY order: {e}")

    def show_trading_message(self, message, msg_type="info"):
        """Show trading message overlay on chart with enhanced styling"""
        if not hasattr(self, 'message_overlay'):
            self.message_overlay = QLabel(self)
            self.message_overlay.setFixedSize(500, 80)  # Larger size for better visibility
            self.message_overlay.setAlignment(Qt.AlignCenter)
            self.message_overlay.setWordWrap(True)  # Allow text wrapping
        
        # Position in center-top of chart
        self.message_overlay.move(self.width()//2 - 250, 60)
        
        # Enhanced styling based on message type
        if msg_type == "success":
            style = """
                QLabel {
                    background-color: rgba(76, 175, 80, 0.95);
                    color: white;
                    border: 2px solid #4caf50;
                    border-radius: 8px;
                    font-weight: bold;
                    font-size: 12px;
                    padding: 10px;
                    text-align: center;
                }
            """
        elif msg_type == "error":
            style = """
                QLabel {
                    background-color: rgba(244, 67, 54, 0.95);
                    color: white;
                    border: 2px solid #f44336;
                    border-radius: 8px;
                    font-weight: bold;
                    font-size: 12px;
                    padding: 10px;
                    text-align: center;
                }
            """
        else:
            style = """
                QLabel {
                    background-color: rgba(33, 150, 243, 0.95);
                    color: white;
                    border: 2px solid #2196f3;
                    border-radius: 8px;
                    font-weight: bold;
                    font-size: 12px;
                    padding: 10px;
                    text-align: center;
                }
            """
        
        self.message_overlay.setStyleSheet(style)
        self.message_overlay.setText(message)
        self.message_overlay.show()
        self.message_overlay.raise_()  # Bring to front
        
        # Auto-hide message after 5 seconds (longer for order notifications)
        QTimer.singleShot(5000, self.message_overlay.hide)


class WorkerSignals(QObject):
    finished = pyqtSignal(str)

class FetchCandlesRunnable(QRunnable):
    def __init__(self, mt5_conn, symbol, timeframe, count):
        super().__init__()
        self.mt5_conn = mt5_conn
        self.symbol = symbol
        self.timeframe = timeframe
        self.count = count
        self.signals = WorkerSignals()

    def run(self):
        success, msg = self.mt5_conn.fetch_candles(self.symbol, self.timeframe, self.count)
        self.signals.finished.emit(msg)

class AccountTab(QWidget):
    connection_changed = pyqtSignal(bool)  # Signal Ä‘á»ƒ thÃ´ng bÃ¡o khi káº¿t ná»‘i thay Ä‘á»•i
    
    def __init__(self):
        super().__init__()
        self.mt5_conn = None
        self._login_in_progress = False  # guard against re-entrancy / spinner loop
        self._last_login_attempt_ts = 0.0
        self._login_cooldown_sec = 5
        self.user_config = load_user_config()
        self.init_ui()
        self.load_env()
        
        # Timer Ä‘á»ƒ cáº­p nháº­t thÃ´ng tin tÃ i khoáº£n hiá»ƒn thá»‹
        self.account_timer = QTimer(self)
        self.account_timer.timeout.connect(self.update_account_info)
        self.account_timer.start(1000)  # Cáº­p nháº­t má»—i 1 giÃ¢y (liÃªn tá»¥c)
        
        # Timer Ä‘á»ƒ save account scan file (real-time updates)
        self.scan_save_timer = QTimer(self)
        self.scan_save_timer.timeout.connect(self.save_account_scan)
        self.scan_save_timer.start(2000)  # Save scan file má»—i 2 giÃ¢y (liÃªn tá»¥c)

    def init_ui(self):
        layout = QVBoxLayout()

        # Header with logo and contact info
        top_layout = QHBoxLayout()
        spacer = QLabel()
        top_layout.addWidget(spacer, 1)

        img_path = os.path.join("images", "robot.png")
        self.robot_label = QLabel()
        if os.path.exists(img_path):
            pixmap = QPixmap(img_path)
            self.robot_label.setPixmap(pixmap.scaled(64, 64, Qt.KeepAspectRatio))
        else:
            self.robot_label.setText("ðŸ¤–")
            self.robot_label.setStyleSheet("font-size: 32px;")
        top_layout.addWidget(self.robot_label, 0, Qt.AlignRight)
        layout.addLayout(top_layout)

        # User info and license countdown label (will be updated after login)
        self.user_license_label = QLabel(I18N.t("Welcome! Please login to continue.", "ChÃ o má»«ng! Vui lÃ²ng Ä‘Äƒng nháº­p Ä‘á»ƒ tiáº¿p tá»¥c."))
        self.user_license_label.setAlignment(Qt.AlignRight)
        self.user_license_label.setStyleSheet("font-weight: bold; color: #2196F3; font-size: 14px; padding: 5px;")
        layout.addWidget(self.user_license_label)
        
        # License countdown timer (updates every second)
        self.license_countdown_timer = QTimer(self)
        self.license_countdown_timer.timeout.connect(self._update_license_countdown)
        self._license_expire_datetime = None  # Will be set after login

        # Connection Status Panel
        connection_panel = QGroupBox(I18N.t("ðŸ“¡ Connection Status", "ðŸ“¡ Tráº¡ng thÃ¡i Káº¿t ná»‘i"))
        connection_layout = QHBoxLayout()
        self.status_label = QLabel(I18N.t("ðŸ”´ Status: Disconnected", "ðŸ”´ Tráº¡ng thÃ¡i: Ngáº¯t káº¿t ná»‘i"))
        self.status_label.setStyleSheet(
            "font-weight:bold; color:red; padding: 8px; border: 1px solid #ccc; border-radius: 4px; background-color: #f9f9f9;"
        )
        connection_layout.addWidget(self.status_label)
        connection_panel.setLayout(connection_layout)
        layout.addWidget(connection_panel)

        # Login Form
        self.login_group = QGroupBox(I18N.t("MT5 Account Login", "ÄÄƒng nháº­p TÃ i khoáº£n MT5"))
        form_layout = QFormLayout()
        self.account_input = QLineEdit()
        self.password_input = QLineEdit()
        self.password_input.setEchoMode(QLineEdit.Password)
        self.server_input = QLineEdit()
        self.save_account_cb = QCheckBox(I18N.t("Save Account Info", "LÆ°u thÃ´ng tin tÃ i khoáº£n"))
        self.save_account_cb.setToolTip(I18N.t("Save login credentials to .env file", "LÆ°u thÃ´ng tin Ä‘Äƒng nháº­p vÃ o file .env"))

        form_layout.addRow(I18N.t("Account:", "TÃ i khoáº£n:"), self.account_input)
        form_layout.addRow(I18N.t("Password:", "Máº­t kháº©u:"), self.password_input)
        form_layout.addRow(I18N.t("Server:", "MÃ¡y chá»§:"), self.server_input)
        form_layout.addRow("", self.save_account_cb)

        # Login / Disconnect buttons (Force Reset removed)
        button_layout = QHBoxLayout()
        self.login_button = QPushButton(I18N.t("ðŸ”‘ Login to MT5", "ðŸ”‘ ÄÄƒng nháº­p MT5"))
        self.login_button.clicked.connect(self.login_mt5)
        self.login_button.setStyleSheet(
            """
            QPushButton { background-color: #4CAF50; color: white; font-weight: bold; padding: 8px; border: none; border-radius: 4px; }
            QPushButton:hover { background-color: #45a049; }
            """
        )
        self.logout_button = QPushButton(I18N.t("ðŸ”“ Disconnect", "ðŸ”“ Ngáº¯t káº¿t ná»‘i"))
        self.logout_button.clicked.connect(self.logout_mt5)
        self.logout_button.setEnabled(False)
        self.logout_button.setStyleSheet(
            """
            QPushButton { background-color: #cccccc; color: #666666; font-weight: bold; padding: 8px; border: none; border-radius: 4px; }
            QPushButton:enabled { background-color: #f44336; color: white; }
            QPushButton:enabled:hover { background-color: #d32f2f; }
            """
        )
        button_layout.addWidget(self.login_button)
        button_layout.addWidget(self.logout_button)
        form_layout.addRow(button_layout)
        self.login_group.setLayout(form_layout)
        layout.addWidget(self.login_group)

        # Account Information Group
        self.account_group = QGroupBox(I18N.t("Account Information", "ThÃ´ng tin TÃ i khoáº£n"))
        self.account_group.setEnabled(False)
        account_layout = QVBoxLayout()

        # Basics
        basics_layout = QFormLayout()
        self.login_label = QLabel("--")
        self.name_label = QLabel("--")
        self.company_label = QLabel("--")
        self.server_label = QLabel("--")
        self.currency_label = QLabel("--")
        self.leverage_label = QLabel("--")
        basics_layout.addRow(I18N.t("Login:", "TÃ i khoáº£n:"), self.login_label)
        basics_layout.addRow(I18N.t("Name:", "TÃªn:"), self.name_label)
        basics_layout.addRow(I18N.t("Company:", "CÃ´ng ty:"), self.company_label)
        basics_layout.addRow(I18N.t("Server:", "MÃ¡y chá»§:"), self.server_label)
        basics_layout.addRow(I18N.t("Currency:", "Tiá»n tá»‡:"), self.currency_label)
        basics_layout.addRow(I18N.t("Leverage:", "ÄÃ²n báº©y:"), self.leverage_label)
        account_layout.addLayout(basics_layout)

        # Balance Information
        balance_group = QGroupBox(I18N.t("ðŸ’° Balance Information", "ðŸ’° ThÃ´ng tin Sá»‘ dÆ°"))
        balance_layout = QFormLayout()
        self.balance_label = QLabel("$0.00")
        self.equity_label = QLabel("$0.00")
        self.margin_label = QLabel("$0.00")
        self.free_margin_label = QLabel("$0.00")
        self.margin_level_label = QLabel("0.00%")
        self.profit_label = QLabel("$0.00")
        balance_layout.addRow(I18N.t("Balance:", "Sá»‘ dÆ°:"), self.balance_label)
        balance_layout.addRow(I18N.t("Equity:", "Vá»‘n thá»±c:"), self.equity_label)
        balance_layout.addRow(I18N.t("Margin Used:", "KÃ½ quá»¹ sá»­ dá»¥ng:"), self.margin_label)
        balance_layout.addRow(I18N.t("Free Margin:", "KÃ½ quá»¹ kháº£ dá»¥ng:"), self.free_margin_label)
        balance_layout.addRow(I18N.t("Margin Level:", "Má»©c kÃ½ quá»¹:"), self.margin_level_label)
        balance_layout.addRow(I18N.t("Profit/Loss:", "LÃ£i/Lá»—:"), self.profit_label)
        balance_group.setLayout(balance_layout)
        account_layout.addWidget(balance_group)

        # Trading Status
        trading_group = QGroupBox(I18N.t("ðŸ“ˆ Trading Status", "ðŸ“ˆ Tráº¡ng thÃ¡i Giao dá»‹ch"))
        trading_layout = QFormLayout()
        self.positions_label = QLabel("0")
        self.orders_label = QLabel("0")
        self.trade_allowed_label = QLabel("--")
        trading_layout.addRow(I18N.t("Open Positions:", "Vá»‹ tháº¿ Ä‘ang má»Ÿ:"), self.positions_label)
        trading_layout.addRow(I18N.t("Pending Orders:", "Lá»‡nh chá»:"), self.orders_label)
        trading_layout.addRow(I18N.t("Trade Allowed:", "Cho phÃ©p giao dá»‹ch:"), self.trade_allowed_label)
        trading_group.setLayout(trading_layout)
        account_layout.addWidget(trading_group)

        # Positions Table
        positions_group = QGroupBox(I18N.t("ðŸ“Š Active Positions", "ðŸ“Š Vá»‹ tháº¿ Äang má»Ÿ"))
        positions_layout = QVBoxLayout()
        self.positions_table = QTableWidget()
        self.positions_table.setColumnCount(11)
        self.positions_table.setHorizontalHeaderLabels([
            I18N.t("Ticket", "MÃ£ lá»‡nh"), I18N.t("Symbol", "Cáº·p tiá»n"), I18N.t("Type", "Loáº¡i"), I18N.t("Volume", "Khá»‘i lÆ°á»£ng"), I18N.t("Open Price", "GiÃ¡ má»Ÿ"),
            I18N.t("Current Price", "GiÃ¡ hiá»‡n táº¡i"), I18N.t("Stop Loss", "Cáº¯t lá»—"), I18N.t("Take Profit", "Chá»‘t lÃ£i"), I18N.t("Swap", "Swap"),
            I18N.t("Profit", "LÃ£i/Lá»—"), I18N.t("Actions", "HÃ nh Ä‘á»™ng")
        ])
        header = self.positions_table.horizontalHeader()
        for i in range(self.positions_table.columnCount()):
            header.setSectionResizeMode(i, QHeaderView.Stretch)
        self.positions_table.setAlternatingRowColors(True)
        positions_layout.addWidget(self.positions_table)
        positions_control_layout = QHBoxLayout()
        self.close_all_positions_btn = QPushButton(I18N.t("ðŸš« Close All Positions", "ðŸš« ÄÃ³ng Táº¥t cáº£ Vá»‹ tháº¿"))
        self.close_all_positions_btn.setStyleSheet("background-color: #E74C3C; color: white; font-weight: bold;")
        self.close_all_positions_btn.clicked.connect(self.close_all_positions)
        positions_control_layout.addWidget(self.close_all_positions_btn)
        self.refresh_positions_btn = QPushButton(I18N.t("ðŸ”„ Refresh Positions", "ðŸ”„ LÃ m má»›i Vá»‹ tháº¿"))
        self.refresh_positions_btn.setStyleSheet("background-color: #3498DB; color: white; font-weight: bold;")
        self.refresh_positions_btn.clicked.connect(self.refresh_account_info)
        positions_control_layout.addWidget(self.refresh_positions_btn)
        positions_control_layout.addStretch()
        positions_layout.addLayout(positions_control_layout)
        positions_group.setLayout(positions_layout)
        account_layout.addWidget(positions_group)

        # Orders Table
        orders_group = QGroupBox(I18N.t("ðŸ“‹ Pending Orders", "ðŸ“‹ Lá»‡nh Chá»"))
        orders_layout = QVBoxLayout()
        self.orders_table = QTableWidget()
        self.orders_table.setColumnCount(10)
        self.orders_table.setHorizontalHeaderLabels([
            I18N.t("Ticket", "MÃ£ lá»‡nh"), I18N.t("Symbol", "Cáº·p tiá»n"), I18N.t("Type", "Loáº¡i"), I18N.t("Volume", "Khá»‘i lÆ°á»£ng"), I18N.t("Open Price", "GiÃ¡ má»Ÿ"),
            I18N.t("Current Price", "GiÃ¡ hiá»‡n táº¡i"), I18N.t("Stop Loss", "Cáº¯t lá»—"), I18N.t("Take Profit", "Chá»‘t lÃ£i"), I18N.t("Time", "Thá»i gian"), I18N.t("Actions", "HÃ nh Ä‘á»™ng")
        ])
        header = self.orders_table.horizontalHeader()
        for i in range(self.orders_table.columnCount()):
            header.setSectionResizeMode(i, QHeaderView.Stretch)
        self.orders_table.setAlternatingRowColors(True)
        orders_layout.addWidget(self.orders_table)
        orders_control_layout = QHBoxLayout()
        self.cancel_all_orders_btn = QPushButton(I18N.t("âŒ Cancel All Orders", "âŒ Há»§y Táº¥t cáº£ Lá»‡nh"))
        self.cancel_all_orders_btn.setStyleSheet("background-color: #F39C12; color: white; font-weight: bold;")
        self.cancel_all_orders_btn.clicked.connect(self.cancel_all_orders)
        orders_control_layout.addWidget(self.cancel_all_orders_btn)
        self.refresh_orders_btn = QPushButton(I18N.t("ðŸ”„ Refresh Orders", "ðŸ”„ LÃ m má»›i Lá»‡nh"))
        self.refresh_orders_btn.setStyleSheet("background-color: #3498DB; color: white; font-weight: bold;")
        self.refresh_orders_btn.clicked.connect(self.refresh_account_info)
        orders_control_layout.addWidget(self.refresh_orders_btn)
        orders_control_layout.addStretch()
        orders_layout.addLayout(orders_control_layout)
        orders_group.setLayout(orders_layout)
        account_layout.addWidget(orders_group)

        self.account_group.setLayout(account_layout)
        layout.addWidget(self.account_group)
        self.setLayout(layout)

    def retranslate_ui(self):
        """Retranslate UI strings when language changes"""
        try:
            # Update group box titles
            self.login_group.setTitle(I18N.t("MT5 Account Login", "ÄÄƒng nháº­p TÃ i khoáº£n MT5"))
            self.account_group.setTitle(I18N.t("Account Information", "ThÃ´ng tin TÃ i khoáº£n"))
            
            # Update labels and buttons
            self.user_license_label.setText(I18N.t("Welcome! Please login to continue.", "ChÃ o má»«ng! Vui lÃ²ng Ä‘Äƒng nháº­p Ä‘á»ƒ tiáº¿p tá»¥c."))
            self.status_label.setText(I18N.t("ðŸ”´ Status: Disconnected", "ðŸ”´ Tráº¡ng thÃ¡i: Ngáº¯t káº¿t ná»‘i"))
            self.save_account_cb.setText(I18N.t("Save Account Info", "LÆ°u thÃ´ng tin tÃ i khoáº£n"))
            self.login_button.setText(I18N.t("ðŸ”‘ Login to MT5", "ðŸ”‘ ÄÄƒng nháº­p MT5"))
            self.logout_button.setText(I18N.t("ðŸ”“ Disconnect", "ðŸ”“ Ngáº¯t káº¿t ná»‘i"))
            self.close_all_positions_btn.setText(I18N.t("ðŸš« Close All Positions", "ðŸš« ÄÃ³ng Táº¥t cáº£ Vá»‹ tháº¿"))
            self.refresh_positions_btn.setText(I18N.t("ðŸ”„ Refresh Positions", "ðŸ”„ LÃ m má»›i Vá»‹ tháº¿"))
            self.cancel_all_orders_btn.setText(I18N.t("âŒ Cancel All Orders", "âŒ Há»§y Táº¥t cáº£ Lá»‡nh"))
            self.refresh_orders_btn.setText(I18N.t("ðŸ”„ Refresh Orders", "ðŸ”„ LÃ m má»›i Lá»‡nh"))
            print("âœ… AccountTab retranslated")
        except Exception as e:
            print(f"âš ï¸ Error retranslating AccountTab: {e}")

    def load_env(self):
        """Load saved credentials from .env file"""
        if os.path.exists(ENV_PATH) and DOTENV_AVAILABLE:
            load_dotenv(ENV_PATH)
            self.account_input.setText(os.getenv("MT5_ACCOUNT", ""))
            self.password_input.setText(os.getenv("MT5_PASSWORD", ""))
            self.server_input.setText(os.getenv("MT5_SERVER", ""))
            
            # If all fields are filled, check the save checkbox
            if all([self.account_input.text(), self.password_input.text(), self.server_input.text()]):
                self.save_account_cb.setChecked(True)

    def save_env(self):
        """Save credentials to .env file if checkbox is checked"""
        if self.save_account_cb.isChecked() and DOTENV_AVAILABLE:
            set_key(ENV_PATH, "MT5_ACCOUNT", self.account_input.text())
            set_key(ENV_PATH, "MT5_PASSWORD", self.password_input.text())
            set_key(ENV_PATH, "MT5_SERVER", self.server_input.text())
            print("âœ… Account credentials saved to .env file")

    def login_mt5(self):
        """Login to MT5"""
        # ========== LICENSE CHECK ==========
        # Kiá»ƒm tra license trÆ°á»›c khi cho phÃ©p Ä‘Äƒng nháº­p MT5
        if not check_license_for_service(self, "MT5 Login"):
            return
        # ========== END LICENSE CHECK ==========
        
        account = self.account_input.text()
        password = self.password_input.text()
        server = self.server_input.text()
        
        if not account or not password or not server:
            QMessageBox.warning(
                self,
                I18N.t("Warning", "Cáº£nh bÃ¡o"),
                I18N.t("Please fill in all login fields!", "Vui lÃ²ng Ä‘iá»n Ä‘áº§y Ä‘á»§ thÃ´ng tin Ä‘Äƒng nháº­p!")
            )
            return

        self.login_button.setEnabled(False)
        self.login_button.setText(I18N.t("ðŸ”„ Connecting...", "ðŸ”„ Äang káº¿t ná»‘i..."))
        
        try:
            print(f"[MT5][LOGIN] Start login workflow for {account}@{server}")
            # If already connected with different credentials, force shutdown first
            if self.mt5_conn and self.mt5_conn.connected:
                prev_acc = getattr(self.mt5_conn, 'account', None)
                prev_srv = getattr(self.mt5_conn, 'server', None)
                if str(prev_acc) != str(account) or str(prev_srv) != str(server):
                    print(f"[MT5] Switching account {prev_acc}@{prev_srv} -> {account}@{server}")
                    # Use connection manager reconfigure path if available
                    if self.mt5_conn.connection_manager:
                        try:
                            print("[MT5][LOGIN] Reconfigure existing manager...")
                            self.mt5_conn.connection_manager.reconfigure(account, password, server)
                            # Force reconnect
                            ok = self.mt5_conn.connection_manager.connect(force_reconnect=True)
                            print(f"[MT5][LOGIN] Connect after reconfigure => {ok}")
                            # Sync attributes
                            self.mt5_conn.account = account
                            self.mt5_conn.password = password
                            self.mt5_conn.server = server
                            self.mt5_conn.connected = self.mt5_conn.connection_manager.state.name.lower() == 'connected'
                        except Exception as _re:
                            print(f"[MT5] Reconfigure path failed: {_re}; falling back to full restart")
                            try:
                                self.mt5_conn.shutdown()
                            except Exception:
                                pass
                            self.mt5_conn = None
                    else:
                        # Legacy path
                        try:
                            self.mt5_conn.shutdown()
                        except Exception:
                            pass
                        self.mt5_conn = None
            if not self.mt5_conn or not self.mt5_conn.connected:
                # Fresh instance (covers first login or fallback case)
                print("[MT5][LOGIN] Creating fresh MT5Connection object")
                self.mt5_conn = MT5Connection(account, password, server)
            
            if self.mt5_conn.connected:
                print("[MT5][LOGIN] Connection marked connected, updating UI")
                self.status_label.setText(I18N.t("ðŸŸ¢ Status: Connected", "ðŸŸ¢ Tráº¡ng thÃ¡i: ÄÃ£ káº¿t ná»‘i"))
                self.status_label.setStyleSheet("font-weight:bold; color:green; padding: 8px; border: 1px solid #4CAF50; border-radius: 4px; background-color: #e8f5e8;")
                self.login_button.setText(I18N.t("âœ… Connected", "âœ… ÄÃ£ káº¿t ná»‘i"))
                self.logout_button.setEnabled(True)
                self.account_group.setEnabled(True)
                
                # Enable logout button when connected successfully
                self.logout_button.setEnabled(True)
                
                # Save credentials if checkbox is checked
                self.save_env()
                
                # Update account info immediately
                self.update_account_info()
                
                # Perform account scan after successful connection
                try:
                    scan_file = self.mt5_conn.perform_account_scan()
                    if scan_file:
                        logging.info(f"âœ… Account scan completed and saved: {scan_file}")
                    else:
                        logging.warning("âš ï¸ Account scan failed or not available")
                except Exception as e:
                    logging.error(f"âŒ Account scan error: {e}")

                    # Invalidate aggregator/analysis cached account scan & refresh risk manager after account switch
                    try:
                        from comprehensive_aggregator import invalidate_account_scan_cache
                        invalidate_account_scan_cache()
                        logging.info("Cache: account scan cache invalidated after login")
                    except Exception:
                        pass
                    # Risk manager refresh hook
                    try:
                        if hasattr(self.parent(), 'risk_manager') and self.parent().risk_manager:
                            rm = self.parent().risk_manager
                            if hasattr(rm, 'refresh_after_account_switch'):
                                rm.refresh_after_account_switch()
                                logging.info("Risk manager refreshed after account switch")
                    except Exception:
                        pass
                
                # Emit signal for other tabs
                self.connection_changed.emit(True)
                
                QMessageBox.information(
                    self,
                    I18N.t("Success", "ThÃ nh cÃ´ng"),
                    I18N.t("Successfully connected to MT5!", "Káº¿t ná»‘i MT5 thÃ nh cÃ´ng!")
                )
                
            else:
                # Collect diagnostic info
                diag = None
                try:
                    if self.mt5_conn and self.mt5_conn.connection_manager:
                        diag = self.mt5_conn.connection_manager.stats.last_error
                        if not diag:
                            # Try raw last error tuple captured
                            raw_err = self.mt5_conn.connection_manager.get_last_mt5_error()
                            if raw_err:
                                diag = f"Raw MT5 last_error: {raw_err}"
                except Exception:
                    pass
                # Try mt5.last_error for more context
                try:
                    if not diag and MT5_AVAILABLE:
                        diag = str(mt5.last_error())
                except Exception:
                    pass
                print(f"[MT5][LOGIN] Failed to connect. Diagnostic => {diag}")
                # Restore button so user can retry
                self.login_button.setEnabled(True)
                self.login_button.setText(I18N.t("ðŸ”‘ Login to MT5", "ðŸ”‘ ÄÄƒng nháº­p MT5"))
                self.show_connection_error(diag)
                
        except Exception as e:
            print(f"[MT5][LOGIN] Exception during login: {e}")
            self.login_button.setEnabled(True)
            self.login_button.setText(I18N.t("ðŸ”‘ Login to MT5", "ðŸ”‘ ÄÄƒng nháº­p MT5"))
            self.show_connection_error(str(e))

    def logout_mt5(self):
        """Logout from MT5"""
        if self.mt5_conn:
            self.mt5_conn.shutdown()
            self.mt5_conn = None
            
        self.status_label.setText(I18N.t("ðŸ”´ Status: Disconnected", "ðŸ”´ Tráº¡ng thÃ¡i: Ngáº¯t káº¿t ná»‘i"))
        self.status_label.setStyleSheet("font-weight:bold; color:red; padding: 8px; border: 1px solid #ccc; border-radius: 4px; background-color: #f9f9f9;")
        self.login_button.setText(I18N.t("ðŸ”‘ Login to MT5", "ðŸ”‘ ÄÄƒng nháº­p MT5"))
        self.login_button.setEnabled(True)
        self.logout_button.setEnabled(False)
        self.account_group.setEnabled(False)
        
        # Disable logout button when disconnected
        self.logout_button.setEnabled(False)
        
        # Clear account info
        self.clear_account_info()
        
        # Emit signal for other tabs
        self.connection_changed.emit(False)
        
        print("âœ… Disconnected from MT5")

    def show_connection_error(self, error_msg=None):
        """Show connection error"""
        self.status_label.setText(I18N.t("ðŸ”´ Status: Connection Failed", "ðŸ”´ Tráº¡ng thÃ¡i: Káº¿t ná»‘i Tháº¥t báº¡i"))
        self.status_label.setStyleSheet("font-weight:bold; color:red; padding: 8px; border: 1px solid #f44336; border-radius: 4px; background-color: #ffebee;")
        self.login_button.setText(I18N.t("ðŸ”‘ Login to MT5", "ðŸ”‘ ÄÄƒng nháº­p MT5"))
        self.login_button.setEnabled(True)
        
        # Disable logout button when connection fails
        self.logout_button.setEnabled(False)
        
        error_text = I18N.t("Failed to connect to MT5!", "Káº¿t ná»‘i MT5 tháº¥t báº¡i!")
        if error_msg:
            error_text += I18N.t("\nError: {msg}", "\nLá»—i: {msg}", msg=error_msg)
        QMessageBox.critical(self, I18N.t("Connection Error", "Lá»—i káº¿t ná»‘i"), error_text)

    @safe_method
    def update_account_info(self):
        """Update account information display from MT5 or fallback to scan file"""
        try:
            # Try to get from live MT5 connection first
            if self.mt5_conn and self.mt5_conn.connected:
                try:
                    # Get account info from MT5
                    if MT5_AVAILABLE:
                        account_info = mt5.account_info()
                        positions = mt5.positions_get()
                        orders = mt5.orders_get()
                        
                        if account_info:
                            # Update basic info
                            self.login_label.setText(str(account_info.login))
                            self.name_label.setText(account_info.name or "N/A")
                            self.company_label.setText(account_info.company or "N/A")
                            self.server_label.setText(account_info.server or "N/A")
                            self.currency_label.setText(account_info.currency or "USD")
                            self.leverage_label.setText(f"1:{account_info.leverage}")
                            
                            # Update balance info
                            currency = account_info.currency or "USD"
                            self.balance_label.setText(f"{account_info.balance:.2f} {currency}")
                            self.equity_label.setText(f"{account_info.equity:.2f} {currency}")
                            self.margin_label.setText(f"{account_info.margin:.2f} {currency}")
                            self.free_margin_label.setText(f"{account_info.margin_free:.2f} {currency}")
                            
                            # Calculate margin level
                            if account_info.margin > 0:
                                margin_level = (account_info.equity / account_info.margin) * 100
                                self.margin_level_label.setText(f"{margin_level:.2f}%")
                            else:
                                self.margin_level_label.setText("N/A")
                            
                            # Profit/Loss with color
                            profit = account_info.profit
                            profit_text = f"{profit:.2f} {currency}"
                            if profit > 0:
                                self.profit_label.setText(f"+{profit_text}")
                                self.profit_label.setStyleSheet("color: green; font-weight: bold;")
                            elif profit < 0:
                                self.profit_label.setText(profit_text)
                                self.profit_label.setStyleSheet("color: red; font-weight: bold;")
                            else:
                                self.profit_label.setText(profit_text)
                                self.profit_label.setStyleSheet("color: black;")
                            
                            # Update trading status
                            self.positions_label.setText(str(len(positions) if positions else 0))
                            self.orders_label.setText(str(len(orders) if orders else 0))
                            self.trade_allowed_label.setText("âœ… Yes" if account_info.trade_allowed else "âŒ No")
                            
                            # Update positions table
                            self.update_positions_table(positions)
                            
                            # Update orders table
                            self.update_orders_table(orders)
                            return  # Successfully updated from MT5
                            
                except Exception as e:
                    print(f"[WARN] Error updating from MT5: {e}")
                    # Fall through to try loading from file
            
            # Load from file (fast, no MT5 call needed)
            self._load_account_from_file()
        
        except Exception as e:
            # Outer catch - prevent ANY exception from breaking the timer
            print(f"[ERROR] Unexpected error in update_account_info: {e}")
    
    def _load_account_from_file(self):
        """Load account data from mt5_essential_scan.json file (fast, no MT5 call)"""
        try:
            import os, json
            scan_file = os.path.join(os.getcwd(), "account_scans", "mt5_essential_scan.json")
            if not os.path.exists(scan_file):
                return  # File doesn't exist yet
            
            with open(scan_file, 'r', encoding='utf-8') as f:
                scan_data = json.load(f)
            
            if not scan_data or 'account' not in scan_data:
                return
            
            acc = scan_data['account']
            
            # Update basic info from file
            self.login_label.setText(str(acc.get('login', 'N/A')))
            self.name_label.setText(acc.get('server', 'N/A'))
            self.company_label.setText("(From scan)")
            self.server_label.setText(acc.get('server', 'N/A'))
            currency = acc.get('currency', 'USD') or 'USD'
            self.currency_label.setText(currency)
            self.leverage_label.setText("N/A")
            
            # Update balance info from file
            self.balance_label.setText(f"{acc.get('balance', 0):.2f} {currency}")
            self.equity_label.setText(f"{acc.get('equity', 0):.2f} {currency}")
            self.margin_label.setText(f"{acc.get('margin', 0):.2f} {currency}")
            self.free_margin_label.setText(f"{acc.get('free_margin', 0):.2f} {currency}")
            
            # Calculate margin level from scan data
            margin = acc.get('margin', 0)
            equity = acc.get('equity', 0)
            if margin > 0:
                margin_level = (equity / margin) * 100
                self.margin_level_label.setText(f"{margin_level:.2f}%")
            else:
                self.margin_level_label.setText("N/A")
            
            # Profit/Loss with color
            profit = acc.get('profit', 0)
            profit_text = f"{profit:.2f} {currency}"
            if profit > 0:
                self.profit_label.setText(f"+{profit_text}")
                self.profit_label.setStyleSheet("color: green; font-weight: bold;")
            elif profit < 0:
                self.profit_label.setText(profit_text)
                self.profit_label.setStyleSheet("color: red; font-weight: bold;")
            else:
                self.profit_label.setText(profit_text)
                self.profit_label.setStyleSheet("color: black;")
            
            # Update trading status from scan
            positions = scan_data.get('active_positions', [])
            orders = scan_data.get('active_orders', [])
            self.positions_label.setText(str(len(positions) if positions else 0))
            self.orders_label.setText(str(len(orders) if orders else 0))
            self.trade_allowed_label.setText("Yes")
            
            # Update positions and orders tables
            self.update_positions_table(positions)
            self.update_orders_table(orders if orders else [])
                        
        except Exception as e:
            print(f"[WARN] Error loading account from file: {e}")

    def save_account_scan(self):
        """Save current account scan to file (real-time update)"""
        if not self.mt5_conn or not self.mt5_conn.connected:
            return
        
        try:
            # Use MT5ConnectionManager's save method if available
            result = self.mt5_conn.save_essential_account_scan()
            if result:
                print(f"[AUTO-SAVE] Account scan saved to {result}")
        except Exception as e:
            print(f"[WARN] Could not auto-save account scan: {e}")

    def refresh_account_info(self):
        """Refresh account information (alias for update_account_info)"""
        self.update_account_info()

    def update_positions_table(self, positions):
        """Update positions table with full MT5 information (from live MT5 or JSON file)"""
        try:
            if not positions:
                self.positions_table.setRowCount(0)
                return
                
            self.positions_table.setRowCount(len(positions))
            
            for row, pos in enumerate(positions):
                try:
                    # Handle both MT5 objects and dict from JSON file
                    def get_attr(obj, key, default=None):
                        if isinstance(obj, dict):
                            return obj.get(key, default)
                        else:
                            return getattr(obj, key, default)
                    
                    # Ticket
                    ticket = get_attr(pos, 'ticket', 'N/A')
                    self.positions_table.setItem(row, 0, QTableWidgetItem(str(ticket)))
                    
                    # Symbol
                    symbol = get_attr(pos, 'symbol', 'N/A')
                    self.positions_table.setItem(row, 1, QTableWidgetItem(str(symbol)))
                    
                    # Type
                    order_type = get_attr(pos, 'type', None)
                    if order_type is not None:
                        # Convert MT5 order type constants to readable text
                        # 0 = BUY, 1 = SELL
                        if order_type == 0:
                            type_name = "BUY"
                        elif order_type == 1:
                            type_name = "SELL"
                        else:
                            type_name = f"Type {order_type}"
                    else:
                        type_name = 'N/A'
                    self.positions_table.setItem(row, 2, QTableWidgetItem(type_name))

                    # Volume
                    volume = get_attr(pos, 'volume', 0)
                    self.positions_table.setItem(row, 3, QTableWidgetItem(f"{float(volume):.2f}"))

                    # Open Price
                    price_open = get_attr(pos, 'price_open', 0)
                    open_price_formatted = self.format_price_mt5_style(float(price_open), str(symbol))
                    self.positions_table.setItem(row, 4, QTableWidgetItem(open_price_formatted))

                    # Current Price
                    price_current = get_attr(pos, 'price_current', 0)
                    current_price_formatted = self.format_price_mt5_style(float(price_current), str(symbol))
                    self.positions_table.setItem(row, 5, QTableWidgetItem(current_price_formatted))

                    # Stop Loss
                    sl = get_attr(pos, 'sl', 0)
                    if float(sl) > 0:
                        sl_value = self.format_price_mt5_style(float(sl), str(symbol))
                    else:
                        sl_value = "N/A"
                    self.positions_table.setItem(row, 6, QTableWidgetItem(sl_value))
                    
                    # Take Profit
                    tp = get_attr(pos, 'tp', 0)
                    if float(tp) > 0:
                        tp_value = self.format_price_mt5_style(float(tp), str(symbol))
                    else:
                        tp_value = "N/A"
                    self.positions_table.setItem(row, 7, QTableWidgetItem(tp_value))
                    
                    # Swap
                    swap = get_attr(pos, 'swap', 0)
                    swap_item = QTableWidgetItem(f"{float(swap):.2f}")
                    swap_item.setFont(QFont("Segoe UI", 11))
                    if float(swap) > 0:
                        swap_item.setForeground(QColor('green'))
                    elif float(swap) < 0:
                        swap_item.setForeground(QColor('red'))
                    self.positions_table.setItem(row, 8, swap_item)

                    # Profit
                    profit = get_attr(pos, 'profit', 0)
                    profit_item = QTableWidgetItem(f"{float(profit):.2f}")
                    profit_item.setFont(QFont("Segoe UI", 12, QFont.Bold))  # Larger font for profit/loss visibility
                    if float(profit) > 0:
                        profit_item.setForeground(QColor('green'))
                    elif float(profit) < 0:
                        profit_item.setForeground(QColor('red'))
                    self.positions_table.setItem(row, 9, profit_item)
                    
                    # Close button (moved to column 10)
                    close_btn = QPushButton("ðŸš« Close")
                    close_btn.setStyleSheet("background-color: #E74C3C; color: white; font-weight: bold; padding: 4px;")
                    ticket_val = get_attr(pos, 'ticket', None)
                    close_btn.clicked.connect(lambda checked, t=ticket_val: self.close_position(t))
                    self.positions_table.setCellWidget(row, 10, close_btn)
                    
                except Exception as e:
                    print(f"[WARN] Error updating position row {row}: {e}")
                    continue
                    
        except Exception as e:
            print(f"[ERROR] Error in update_positions_table: {e}")

    def update_orders_table(self, orders):
        """Update orders table with full MT5 information (from live MT5 or JSON file)"""
        try:
            if not orders:
                self.orders_table.setRowCount(0)
                return
                
            self.orders_table.setRowCount(len(orders))
            
            order_types = ["BUY_LIMIT", "SELL_LIMIT", "BUY_STOP", "SELL_STOP", "BUY_STOP_LIMIT", "SELL_STOP_LIMIT"]
            
            # Helper to handle both objects and dicts
            def get_attr(obj, key, default=None):
                if isinstance(obj, dict):
                    return obj.get(key, default)
                else:
                    return getattr(obj, key, default)
            
            for row, order in enumerate(orders):
                try:
                    # Ticket
                    ticket = get_attr(order, 'ticket', 'N/A')
                    self.orders_table.setItem(row, 0, QTableWidgetItem(str(ticket)))
                    
                    # Symbol
                    symbol = get_attr(order, 'symbol', 'N/A')
                    self.orders_table.setItem(row, 1, QTableWidgetItem(str(symbol)))
                    
                    # Type
                    order_type_idx = get_attr(order, 'type', 0)
                    order_type = order_types[order_type_idx] if order_type_idx < len(order_types) else f"Type {order_type_idx}"
                    self.orders_table.setItem(row, 2, QTableWidgetItem(order_type))
                    
                    # Volume
                    volume = get_attr(order, 'volume_current', get_attr(order, 'volume', 0))
                    self.orders_table.setItem(row, 3, QTableWidgetItem(str(volume)))
                    
                    # Open Price - Format with correct decimals for the symbol
                    price_open = get_attr(order, 'price_open', 0)
                    open_price_formatted = self.format_price_mt5_style(float(price_open), str(symbol))
                    self.orders_table.setItem(row, 4, QTableWidgetItem(open_price_formatted))
                    
                    # Current Price (for reference) - Format with correct decimals for the symbol
                    try:
                        # Get current symbol price for comparison
                        import MetaTrader5 as mt5
                        symbol_info = mt5.symbol_info_tick(symbol)
                        if symbol_info:
                            current_price = symbol_info.bid if "SELL" in order_type else symbol_info.ask
                            current_price_formatted = self.format_price_mt5_style(current_price, str(symbol))
                            self.orders_table.setItem(row, 5, QTableWidgetItem(current_price_formatted))
                        else:
                            self.orders_table.setItem(row, 5, QTableWidgetItem("N/A"))
                    except:
                        self.orders_table.setItem(row, 5, QTableWidgetItem("N/A"))
                    
                    # Stop Loss - Format with correct decimals for the symbol
                    sl = get_attr(order, 'sl', 0)
                    if float(sl) > 0:
                        sl_value = self.format_price_mt5_style(float(sl), str(symbol))
                    else:
                        sl_value = "N/A"
                    self.orders_table.setItem(row, 6, QTableWidgetItem(sl_value))
                    
                    # Take Profit - Format with correct decimals for the symbol
                    tp = get_attr(order, 'tp', 0)
                    if float(tp) > 0:
                        tp_value = self.format_price_mt5_style(float(tp), str(symbol))
                    else:
                        tp_value = "N/A"
                    self.orders_table.setItem(row, 7, QTableWidgetItem(tp_value))
                    
                    # Time
                    time_setup = get_attr(order, 'time_setup', 0)
                    if time_setup > 0:
                        time_str = datetime.fromtimestamp(time_setup).strftime("%Y-%m-%d %H:%M")
                    else:
                        time_str = "N/A"
                    self.orders_table.setItem(row, 8, QTableWidgetItem(time_str))
                    
                    # Cancel button
                    cancel_btn = QPushButton("âŒ Cancel")
                    cancel_btn.setStyleSheet("background-color: #F39C12; color: white; font-weight: bold; padding: 4px;")
                    cancel_btn.clicked.connect(lambda checked, t=ticket: self.cancel_order(t))
                    self.orders_table.setCellWidget(row, 9, cancel_btn)
                    
                except Exception as e:
                    print(f"[WARN] Error updating order row {row}: {e}")
                    continue
        except Exception as e:
            print(f"[ERROR] Error in update_orders_table: {e}")

    def close_position(self, ticket):
        """Close a specific position"""
        try:
            reply = QMessageBox.question(
                self,
                I18N.t("Close Position", "ÄÃ³ng lá»‡nh"),
                I18N.t(
                    "Are you sure you want to close position #{ticket}?",
                    "Báº¡n cÃ³ cháº¯c muá»‘n Ä‘Ã³ng lá»‡nh #{ticket}?",
                    ticket=ticket
                ),
                QMessageBox.Yes | QMessageBox.No
            )
            
            if reply == QMessageBox.Yes:
                if ORDER_EXECUTOR_AVAILABLE:
                    from order_executor import get_executor_instance
                    executor = get_executor_instance()
                    result = executor.close_position(ticket)
                    
                    if result.success:
                        QMessageBox.information(
                            self,
                            I18N.t("Success", "ThÃ nh cÃ´ng"),
                            I18N.t("âœ… Position #{ticket} closed successfully!", "âœ… ÄÃ³ng lá»‡nh #{ticket} thÃ nh cÃ´ng!", ticket=ticket)
                        )
                        self.refresh_account_info()  # Refresh to update tables
                    else:
                        QMessageBox.warning(
                            self,
                            I18N.t("Error", "Lá»—i"),
                            I18N.t("âŒ Failed to close position #{ticket}:\n{msg}", "âŒ ÄÃ³ng lá»‡nh #{ticket} tháº¥t báº¡i:\n{msg}", ticket=ticket, msg=result.error_message)
                        )
                else:
                    # Direct MT5 approach
                    positions = mt5.positions_get(ticket=ticket)
                    if positions:
                        pos = positions[0]
                        close_type = mt5.ORDER_TYPE_SELL if pos.type == mt5.ORDER_TYPE_BUY else mt5.ORDER_TYPE_BUY
                        tick = mt5.symbol_info_tick(pos.symbol)
                        price = tick.bid if pos.type == mt5.ORDER_TYPE_BUY else tick.ask
                        
                        request = {
                            "action": mt5.TRADE_ACTION_DEAL,
                            "symbol": pos.symbol,
                            "volume": pos.volume,
                            "type": close_type,
                            "position": ticket,
                            "price": price,
                            "comment": "GUI close position",
                            "type_time": mt5.ORDER_TIME_GTC,
                            "type_filling": mt5.ORDER_FILLING_IOC,
                        }
                        
                        result = mt5.order_send(request)
                        if result and result.retcode == mt5.TRADE_RETCODE_DONE:
                            QMessageBox.information(
                                self,
                                I18N.t("Success", "ThÃ nh cÃ´ng"),
                                I18N.t("âœ… Position #{ticket} closed successfully!", "âœ… ÄÃ³ng lá»‡nh #{ticket} thÃ nh cÃ´ng!", ticket=ticket)
                            )
                            self.refresh_account_info()
                        else:
                            error_msg = f"Failed to close position. Error: {result.comment if result else 'Unknown error'}"
                            QMessageBox.warning(
                                self,
                                I18N.t("Error", "Lá»—i"),
                                I18N.t("âŒ {msg}", "âŒ {msg}", msg=error_msg)
                            )
                    else:
                        QMessageBox.warning(
                            self,
                            I18N.t("Error", "Lá»—i"),
                            I18N.t("âŒ Position #{ticket} not found!", "âŒ KhÃ´ng tÃ¬m tháº¥y lá»‡nh #{ticket}!", ticket=ticket)
                        )
                        
        except Exception as e:
            QMessageBox.critical(
                self,
                I18N.t("Error", "Lá»—i"),
                I18N.t("âŒ Error closing position #{ticket}: {err}", "âŒ Lá»—i khi Ä‘Ã³ng lá»‡nh #{ticket}: {err}", ticket=ticket, err=str(e))
            )

    def cancel_order(self, ticket):
        """Cancel a specific pending order"""
        try:
            reply = QMessageBox.question(
                self,
                I18N.t("Cancel Order", "Há»§y lá»‡nh chá»"),
                I18N.t("Are you sure you want to cancel order #{ticket}?", "Báº¡n cÃ³ cháº¯c muá»‘n há»§y lá»‡nh chá» #{ticket}?", ticket=ticket),
                QMessageBox.Yes | QMessageBox.No
            )
            
            if reply == QMessageBox.Yes:
                request = {
                    "action": mt5.TRADE_ACTION_REMOVE,
                    "order": ticket,
                }
                
                result = mt5.order_send(request)
                if result and result.retcode == mt5.TRADE_RETCODE_DONE:
                    QMessageBox.information(
                        self,
                        I18N.t("Success", "ThÃ nh cÃ´ng"),
                        I18N.t("âœ… Order #{ticket} cancelled successfully!", "âœ… Há»§y lá»‡nh #{ticket} thÃ nh cÃ´ng!", ticket=ticket)
                    )
                    self.refresh_account_info()  # Refresh to update tables
                else:
                    error_msg = f"Failed to cancel order. Error: {result.comment if result else 'Unknown error'}"
                    QMessageBox.warning(
                        self,
                        I18N.t("Error", "Lá»—i"),
                        I18N.t("âŒ {msg}", "âŒ {msg}", msg=error_msg)
                    )
                    
        except Exception as e:
            QMessageBox.critical(
                self,
                I18N.t("Error", "Lá»—i"),
                I18N.t("âŒ Error cancelling order #{ticket}: {err}", "âŒ Lá»—i khi há»§y lá»‡nh #{ticket}: {err}", ticket=ticket, err=str(e))
            )

    def close_all_positions(self):
        """Close all open positions"""
        try:
            positions = mt5.positions_get()
            if not positions:
                QMessageBox.information(
                    self,
                    I18N.t("No Positions", "KhÃ´ng cÃ³ vá»‹ tháº¿"),
                    I18N.t("â„¹ï¸ No open positions to close.", "â„¹ï¸ KhÃ´ng cÃ³ vá»‹ tháº¿ má»Ÿ Ä‘á»ƒ Ä‘Ã³ng.")
                )
                return
                
            reply = QMessageBox.question(
                self,
                I18N.t("Close All Positions", "ÄÃ³ng táº¥t cáº£ vá»‹ tháº¿"),
                I18N.t(
                    "ðŸš¨ Are you sure you want to close ALL {n} open positions?",
                    "ðŸš¨ Báº¡n cÃ³ cháº¯c muá»‘n Ä‘Ã³ng Táº¤T Cáº¢ {n} vá»‹ tháº¿ Ä‘ang má»Ÿ?",
                    n=len(positions)
                ),
                QMessageBox.Yes | QMessageBox.No
            )
            
            if reply == QMessageBox.Yes:
                closed_count = 0
                errors = []
                
                for pos in positions:
                    try:
                        if ORDER_EXECUTOR_AVAILABLE:
                            from order_executor import get_executor_instance
                            executor = get_executor_instance()
                            result = executor.close_position(pos.ticket)
                            if result.success:
                                closed_count += 1
                            else:
                                errors.append(f"Position #{pos.ticket}: {result.error_message}")
                        else:
                            # Direct MT5 approach
                            close_type = mt5.ORDER_TYPE_SELL if pos.type == mt5.ORDER_TYPE_BUY else mt5.ORDER_TYPE_BUY
                            tick = mt5.symbol_info_tick(pos.symbol)
                            price = tick.bid if pos.type == mt5.ORDER_TYPE_BUY else tick.ask
                            
                            request = {
                                "action": mt5.TRADE_ACTION_DEAL,
                                "symbol": pos.symbol,
                                "volume": pos.volume,
                                "type": close_type,
                                "position": pos.ticket,
                                "price": price,
                                "comment": "GUI close all",
                                "type_time": mt5.ORDER_TIME_GTC,
                                "type_filling": mt5.ORDER_FILLING_IOC,
                            }
                            
                            result = mt5.order_send(request)
                            if result and result.retcode == mt5.TRADE_RETCODE_DONE:
                                closed_count += 1
                            else:
                                errors.append(f"Position #{pos.ticket}: {result.comment if result else 'Unknown error'}")
                                
                    except Exception as e:
                        errors.append(f"Position #{pos.ticket}: {str(e)}")
                
                # Show results
                if AppState.language() == 'vi':
                    message = f"ðŸ“Š Káº¿t quáº£ ÄÃ³ng Táº¥t cáº£ Vá»‹ tháº¿:\n\n"
                    message += f"âœ… ÄÃ³ng thÃ nh cÃ´ng: {closed_count} vá»‹ tháº¿\n"
                    if errors:
                        message += f"âŒ Lá»—i: {len(errors)}\n\n"
                        message += "Chi tiáº¿t lá»—i:\n"
                        for error in errors[:5]:  # Show first 5 errors
                            message += f"â€¢ {error}\n"
                        if len(errors) > 5:
                            message += f"â€¢ ... vÃ  {len(errors) - 5} lá»—i khÃ¡c"
                else:
                    message = f"ðŸ“Š Close All Positions Results:\n\n"
                    message += f"âœ… Successfully closed: {closed_count} positions\n"
                    if errors:
                        message += f"âŒ Errors: {len(errors)}\n\n"
                        message += "Error details:\n"
                        for error in errors[:5]:  # Show first 5 errors
                            message += f"â€¢ {error}\n"
                        if len(errors) > 5:
                            message += f"â€¢ ... and {len(errors) - 5} more errors"
                
                QMessageBox.information(
                    self,
                    I18N.t("Close All Results", "Káº¿t quáº£ Ä‘Ã³ng táº¥t cáº£"),
                    message
                )
                self.refresh_account_info()  # Refresh to update tables
                
        except Exception as e:
            QMessageBox.critical(
                self,
                I18N.t("Error", "Lá»—i"),
                I18N.t("âŒ Error closing all positions: {err}", "âŒ Lá»—i khi Ä‘Ã³ng táº¥t cáº£ lá»‡nh: {err}", err=str(e))
            )

    def cancel_all_orders(self):
        """Cancel all pending orders"""
        try:
            orders = mt5.orders_get()
            if not orders:
                QMessageBox.information(
                    self,
                    I18N.t("No Orders", "KhÃ´ng cÃ³ lá»‡nh"),
                    I18N.t("â„¹ï¸ No pending orders to cancel.", "â„¹ï¸ KhÃ´ng cÃ³ lá»‡nh chá» Ä‘á»ƒ há»§y.")
                )
                return
                
            reply = QMessageBox.question(
                self,
                I18N.t("Cancel All Orders", "Há»§y táº¥t cáº£ lá»‡nh"),
                I18N.t(
                    "ðŸš¨ Are you sure you want to cancel ALL {n} pending orders?",
                    "ðŸš¨ Báº¡n cÃ³ cháº¯c muá»‘n há»§y Táº¤T Cáº¢ {n} lá»‡nh Ä‘ang chá»?",
                    n=len(orders)
                ),
                QMessageBox.Yes | QMessageBox.No
            )
            
            if reply == QMessageBox.Yes:
                cancelled_count = 0
                errors = []
                
                for order in orders:
                    try:
                        request = {
                            "action": mt5.TRADE_ACTION_REMOVE,
                            "order": order.ticket,
                        }
                        
                        result = mt5.order_send(request)
                        if result and result.retcode == mt5.TRADE_RETCODE_DONE:
                            cancelled_count += 1
                        else:
                            errors.append(f"Order #{order.ticket}: {result.comment if result else 'Unknown error'}")
                            
                    except Exception as e:
                        errors.append(f"Order #{order.ticket}: {str(e)}")
                
                # Show results
                if AppState.language() == 'vi':
                    message = f"ðŸ“Š Káº¿t quáº£ Há»§y Táº¥t cáº£ Lá»‡nh:\n\n"
                    message += f"âœ… Há»§y thÃ nh cÃ´ng: {cancelled_count} lá»‡nh\n"
                    if errors:
                        message += f"âŒ Lá»—i: {len(errors)}\n\n"
                        message += "Chi tiáº¿t lá»—i:\n"
                        for error in errors[:5]:  # Show first 5 errors
                            message += f"â€¢ {error}\n"
                        if len(errors) > 5:
                            message += f"â€¢ ... vÃ  {len(errors) - 5} lá»—i khÃ¡c"
                else:
                    message = f"ðŸ“Š Cancel All Orders Results:\n\n"
                    message += f"âœ… Successfully cancelled: {cancelled_count} orders\n"
                    if errors:
                        message += f"âŒ Errors: {len(errors)}\n\n"
                        message += "Error details:\n"
                        for error in errors[:5]:  # Show first 5 errors
                            message += f"â€¢ {error}\n"
                        if len(errors) > 5:
                            message += f"â€¢ ... and {len(errors) - 5} more errors"
                
                QMessageBox.information(
                    self,
                    I18N.t("Cancel All Results", "Káº¿t quáº£ há»§y táº¥t cáº£"),
                    message
                )
                self.refresh_account_info()  # Refresh to update tables
                
        except Exception as e:
            QMessageBox.critical(
                self,
                I18N.t("Error", "Lá»—i"),
                I18N.t("âŒ Error cancelling all orders: {err}", "âŒ Lá»—i khi há»§y táº¥t cáº£ lá»‡nh: {err}", err=str(e))
            )

    def clear_account_info(self):
        """Clear all account information displays"""
        self.login_label.setText("--")
        self.name_label.setText("--")
        self.company_label.setText("--")
        self.server_label.setText("--")
        self.currency_label.setText("--")
        self.leverage_label.setText("--")
        
        self.balance_label.setText("$0.00")
        self.equity_label.setText("$0.00")
        self.margin_label.setText("$0.00")
        self.free_margin_label.setText("$0.00")
        self.margin_level_label.setText("0.00%")
        self.profit_label.setText("$0.00")
        self.profit_label.setStyleSheet("color: black;")
        
        self.positions_label.setText("0")
        self.orders_label.setText("0")
        self.trade_allowed_label.setText("--")
        
        self.positions_table.setRowCount(0)
        self.orders_table.setRowCount(0)

    def get_symbol_decimal_places(self, symbol):
        """Get decimal places directly from MT5 symbol info"""
        if not symbol or not MT5_AVAILABLE:
            return 5
            
        try:
            # Get symbol info directly from MT5
            symbol_info = mt5.symbol_info(symbol)
            if symbol_info and hasattr(symbol_info, 'digits'):
                return symbol_info.digits
        except Exception as e:
            print(f"âš ï¸ Error getting symbol info for {symbol}: {e}")
        
        # Fallback to manual detection only if MT5 info is not available
        symbol_upper = symbol.upper()
        
        # JPY pairs typically use 3 decimal places
        if 'JPY' in symbol_upper:
            return 3
            
        # Indices typically use 2 decimal places
        if any(index in symbol_upper for index in ['US30', 'US500', 'NAS100', 'GER30', 'UK100', 'JPN225']):
            return 2
            
        # Metals typically use 2 decimal places
        if any(metal in symbol_upper for metal in ['XAU', 'XAG', 'GOLD', 'SILVER']):
            return 2
            
        # Default fallback for forex pairs
        return 5

    def format_price_mt5_style(self, price, symbol=None):
        """Format price with correct decimal places like MT5"""
        if symbol is None:
            symbol = ""
            
        decimal_places = self.get_symbol_decimal_places(symbol)
        return f'{price:.{decimal_places}f}'

    def get_mt5_connection(self):
        """Get MT5 connection for other tabs"""
        return self.mt5_conn if self.mt5_conn and self.mt5_conn.connected else None

    def set_user_license_info(self, username: str, expire_date_str: str, days_remaining: int):
        """
        Set user info and start license countdown timer.
        Called after successful login.
        
        Args:
            username: Username or email of the logged in user
            expire_date_str: ISO format expire date string (e.g., "2025-01-15T23:59:59")
            days_remaining: Number of days remaining (for display)
        """
        self._logged_in_username = username
        self._days_remaining = days_remaining
        
        # Reset expired flag if license is renewed/extended
        if days_remaining > 0:
            self._license_expired_handled = False
        
        # Parse expire date
        try:
            from datetime import datetime
            if expire_date_str:
                # Handle different date formats
                expire_date_str = expire_date_str.replace('Z', '+00:00')
                self._license_expire_datetime = datetime.fromisoformat(expire_date_str).replace(tzinfo=None)
            else:
                self._license_expire_datetime = None
        except Exception as e:
            print(f"âš ï¸ Error parsing expire date: {e}")
            self._license_expire_datetime = None
        
        # Update label immediately
        self._update_license_countdown()
        
        # Start countdown timer (update every second for accurate countdown)
        if self._license_expire_datetime:
            self.license_countdown_timer.start(1000)  # 1 second interval
        
    def _update_license_countdown(self):
        """Update the license countdown display and check for expiration"""
        from datetime import datetime
        
        username = getattr(self, '_logged_in_username', None)
        expire_dt = getattr(self, '_license_expire_datetime', None)
        
        if not username:
            self.user_license_label.setText(I18N.t("Welcome! Please login.", "ChÃ o má»«ng! Vui lÃ²ng Ä‘Äƒng nháº­p."))
            self.user_license_label.setStyleSheet("font-weight: bold; color: #2196F3; font-size: 14px; padding: 5px;")
            return
        
        if not expire_dt:
            # No expire date - show username only
            self.user_license_label.setText(I18N.t(
                f"ðŸ‘‹ Hello {username}!",
                f"ðŸ‘‹ Xin chÃ o {username}!"
            ))
            self.user_license_label.setStyleSheet("font-weight: bold; color: #2196F3; font-size: 14px; padding: 5px;")
            return
        
        # Calculate remaining time
        now = datetime.now()
        remaining = expire_dt - now
        
        if remaining.total_seconds() <= 0:
            # LICENSE EXPIRED - BLOCK IMMEDIATELY!
            self.license_countdown_timer.stop()
            self.user_license_label.setText(I18N.t(
                f"âŒ {username} - LICENSE EXPIRED!",
                f"âŒ {username} - LICENSE Háº¾T Háº N!"
            ))
            self.user_license_label.setStyleSheet("font-weight: bold; color: #FF0000; font-size: 14px; padding: 5px; background-color: #FFEBEE;")
            
            # Trigger license expiration handling
            self._on_license_expired()
            return
        
        # Calculate days, hours, minutes, seconds
        total_seconds = int(remaining.total_seconds())
        days = total_seconds // 86400
        hours = (total_seconds % 86400) // 3600
        minutes = (total_seconds % 3600) // 60
        seconds = total_seconds % 60
        
        # Format countdown string
        if days > 0:
            countdown_str = I18N.t(
                f"{days}d {hours}h {minutes}m",
                f"{days} ngÃ y {hours} giá» {minutes} phÃºt"
            )
            color = "#4CAF50" if days > 7 else "#FF9800"  # Green if >7 days, orange if <=7 days
        elif hours > 0:
            countdown_str = I18N.t(
                f"{hours}h {minutes}m {seconds}s",
                f"{hours} giá» {minutes} phÃºt {seconds} giÃ¢y"
            )
            color = "#FF9800"  # Orange - less than 1 day
        else:
            countdown_str = I18N.t(
                f"{minutes}m {seconds}s",
                f"{minutes} phÃºt {seconds} giÃ¢y"
            )
            color = "#F44336"  # Red - less than 1 hour
        
        self.user_license_label.setText(I18N.t(
            f"ðŸ‘‹ Hello {username} | â±ï¸ License: {countdown_str}",
            f"ðŸ‘‹ Xin chÃ o {username} | â±ï¸ CÃ²n láº¡i: {countdown_str}"
        ))
        self.user_license_label.setStyleSheet(f"font-weight: bold; color: {color}; font-size: 14px; padding: 5px;")
    
    def _on_license_expired(self):
        """Handle license expiration - block all services but keep app open"""
        # Avoid showing message multiple times
        if hasattr(self, '_license_expired_handled') and self._license_expired_handled:
            return
        self._license_expired_handled = True
        
        print("ðŸš¨ LICENSE EXPIRED! Blocking all services...")
        
        # Stop auto trading if running
        try:
            main_window = self.window()
            if main_window and hasattr(main_window, 'all_tabs'):
                if 'auto_trading_tab' in main_window.all_tabs:
                    auto_tab = main_window.all_tabs['auto_trading_tab']
                    if hasattr(auto_tab, 'is_auto_on') and auto_tab.is_auto_on:
                        print("âš ï¸ Stopping auto trading due to license expiration...")
                        if hasattr(auto_tab, 'auto_btn'):
                            auto_tab.auto_btn.setChecked(False)
                        if hasattr(auto_tab, 'stop_auto'):
                            auto_tab.stop_auto()
        except Exception as e:
            print(f"âš ï¸ Error stopping auto trading: {e}")
        
        # Disconnect MT5
        try:
            if self.mt5_conn and self.mt5_conn.connected:
                self.logout_mt5()
        except Exception as e:
            print(f"âš ï¸ Error disconnecting MT5: {e}")
        
        # Show expiration warning (NOT critical - don't close app)
        QMessageBox.warning(self, 
            I18N.t("âš ï¸ License Expired", "âš ï¸ License Háº¿t Háº¡n"),
            I18N.t(
                "Your license has expired!\n\nAll services have been stopped.\n\nYou can still use the app to renew your license.\n\nGo to Menu â†’ Account â†’ View Pricing to renew.",
                "License cá»§a báº¡n Ä‘Ã£ háº¿t háº¡n!\n\nTáº¥t cáº£ dá»‹ch vá»¥ Ä‘Ã£ bá»‹ dá»«ng.\n\nBáº¡n váº«n cÃ³ thá»ƒ sá»­ dá»¥ng app Ä‘á»ƒ gia háº¡n license.\n\nVÃ o Menu â†’ TÃ i khoáº£n â†’ Xem Báº£ng GiÃ¡ Ä‘á»ƒ gia háº¡n."
            )
        )

class MarketTab(QWidget):
    symbols_changed = pyqtSignal()  # Signal when symbols change
    
    def __init__(self, account_tab):
        super().__init__()

        self.account_tab = account_tab
        self.indicator_tab = None  # Will be set later
        self.mt5_conn = None
        self.all_symbols = []
        self.checked_symbols = set()

        self.threadpool = QThreadPool()
        self.user_config = load_user_config()
        self.init_ui()
        self.restore_user_config()

        # Connect to account tab signals
        self.account_tab.connection_changed.connect(self.on_connection_changed)

        # Disable auto fetch timer - not needed
        # self.fetch_timer = QTimer(self)
        # self.fetch_timer.timeout.connect(self.auto_fetch)
        # self.fetch_timer.start(15 * 60 * 1000)

    def init_ui(self):
        layout = QVBoxLayout()

        # Remove login UI from Market tab since it's now in Account tab
        layout.addWidget(QLabel("Search Symbol:"))
        self.search_input = QLineEdit()
        self.search_input.textChanged.connect(self.filter_and_sort_symbols)
        layout.addWidget(self.search_input)

        layout.addWidget(QLabel("Select Symbols (checkbox multi-select):"))
        self.symbol_list = QListWidget()
        self.symbol_list.itemChanged.connect(self.on_symbol_check_changed)
        layout.addWidget(self.symbol_list)

        layout.addWidget(QLabel("Select Timeframes and Candle Counts:"))
        tf_grid = QGridLayout()
        self.tf_spinboxes = {}
        self.tf_checkboxes = {}
        row = 0
        for tf in TIMEFRAME_MAP:
            cb = QCheckBox(tf)
            spin = QSpinBox()
            spin.setMinimum(100)
            spin.setMaximum(50000)
            spin.setValue(5000)
            tf_grid.addWidget(cb, row, 0)
            tf_grid.addWidget(spin, row, 1)
            self.tf_checkboxes[tf] = cb
            self.tf_spinboxes[tf] = spin
            row += 1
        layout.addLayout(tf_grid)

        self.fetch_button = QPushButton(I18N.t("Fetch Data Now", "Láº¥y dá»¯ liá»‡u ngay"))
        self.fetch_button.clicked.connect(self.fetch_data)
        self.fetch_button.setEnabled(False)
        layout.addWidget(self.fetch_button)

        self.log_output = QTextEdit()
        self.log_output.setReadOnly(True)
        layout.addWidget(self.log_output)

        self.setLayout(layout)

    def on_connection_changed(self, connected):
        """Handle connection status change from Account tab"""
        if connected:
            self.mt5_conn = self.account_tab.get_mt5_connection()
            if self.mt5_conn:
                self.fetch_button.setEnabled(True)
                self.all_symbols = self.mt5_conn.get_all_symbols()
                self.populate_symbol_list()
                self.log_output.append(I18N.t("âœ… Connected to MT5 - Ready to fetch data", "âœ… ÄÃ£ káº¿t ná»‘i MT5 - Sáºµn sÃ ng láº¥y dá»¯ liá»‡u"))
                # Hide connection warning when connected
                self.connection_status.hide()
        else:
            self.mt5_conn = None
            self.fetch_button.setEnabled(False)
            self.symbol_list.clear()
            self.checked_symbols.clear()
            self.all_symbols = []
            self.log_output.append("âŒ Disconnected from MT5")
            # Show connection warning when disconnected
            self.connection_status.show()

    def init_ui(self):
        """Initialize Market tab UI (login moved to Account tab)"""
        layout = QVBoxLayout()

        # Connection status indicator
        self.connection_status = QLabel(I18N.t("âš ï¸ Please connect to MT5 in Account tab first", "âš ï¸ Vui lÃ²ng káº¿t ná»‘i MT5 á»Ÿ tab TÃ i khoáº£n trÆ°á»›c"))
        self.connection_status.setStyleSheet("background-color: #fff3cd; border: 1px solid #ffeaa7; padding: 10px; border-radius: 5px;")
        layout.addWidget(self.connection_status)

        # Search symbols
        layout.addWidget(QLabel(I18N.t("Search Symbol:", "TÃ¬m mÃ£ giao dá»‹ch:")))
        self.search_input = QLineEdit()
        self.search_input.textChanged.connect(self.filter_and_sort_symbols)
        self.search_input.setPlaceholderText(I18N.t("Type to search symbols...", "Nháº­p Ä‘á»ƒ tÃ¬m mÃ£ giao dá»‹ch..."))
        layout.addWidget(self.search_input)

        # Symbol selection
        symbol_info = QLabel(I18N.t("ðŸ“‹ Select symbols for your workspace (not for simultaneous trading):", "ðŸ“‹ Chá»n cÃ¡c mÃ£ cho khÃ´ng gian lÃ m viá»‡c (khÃ´ng pháº£i Ä‘á»ƒ giao dá»‹ch Ä‘á»“ng thá»i):"))
        symbol_info.setStyleSheet("color: #666; font-style: italic; padding: 5px;")
        layout.addWidget(symbol_info)
        
        # Clear All button
        clear_all_layout = QHBoxLayout()
        # Localized Clear All button
        self.clear_all_btn = QPushButton(I18N.t("ðŸ—‘ï¸ Clear All Symbols", "ðŸ—‘ï¸ XÃ³a táº¥t cáº£ mÃ£"))
        self.clear_all_btn.clicked.connect(self.on_clear_all_symbols)
        self.clear_all_btn.setStyleSheet("""
            QPushButton { 
                background-color: #f44336; 
                color: white; 
                font-weight: bold; 
                padding: 8px; 
                border: none; 
                border-radius: 4px; 
            }
            QPushButton:hover {
                background-color: #d32f2f;
            }
        """)
        self.clear_all_btn.setToolTip(I18N.t("Clear all selected symbols from the list", "XÃ³a táº¥t cáº£ mÃ£ Ä‘Ã£ chá»n khá»i danh sÃ¡ch"))
        clear_all_layout.addWidget(self.clear_all_btn)
        clear_all_layout.addStretch()
        layout.addLayout(clear_all_layout)
        
        self.symbol_list = QListWidget()
        self.symbol_list.itemChanged.connect(self.on_symbol_check_changed)
        layout.addWidget(self.symbol_list)

        # Timeframe selection
        layout.addWidget(QLabel(I18N.t("Select Timeframes and Candle Counts:", "Chá»n khung thá»i gian vÃ  sá»‘ náº¿n:")))
        tf_grid = QGridLayout()
        self.tf_spinboxes = {}
        self.tf_checkboxes = {}
        row = 0
        for tf in TIMEFRAME_MAP:
            cb = QCheckBox(tf)
            spin = QSpinBox()
            spin.setMinimum(100)
            spin.setMaximum(50000)
            spin.setValue(5000)
            tf_grid.addWidget(cb, row, 0)
            tf_grid.addWidget(spin, row, 1)
            self.tf_checkboxes[tf] = cb
            self.tf_spinboxes[tf] = spin
            row += 1
        layout.addLayout(tf_grid)

        # Fetch button
        self.fetch_button = QPushButton(I18N.t("Fetch Data Now", "Láº¥y dá»¯ liá»‡u ngay"))
        self.fetch_button.clicked.connect(self.fetch_data)
        self.fetch_button.setEnabled(False)
        layout.addWidget(self.fetch_button)

        # Log output
        self.log_output = QTextEdit()
        self.log_output.setReadOnly(True)
        layout.addWidget(self.log_output)

        # Candlestick chart
        chart_label = QLabel(I18N.t("ðŸ“ˆ Realtime Candlestick Chart", "ðŸ“ˆ Biá»ƒu Ä‘á»“ náº¿n thá»i gian thá»±c"))
        chart_label.setStyleSheet("font-weight: bold; font-size: 14px; color: #2196F3; padding: 5px;")
        layout.addWidget(chart_label)
        
        # Chart controls
        chart_controls = QHBoxLayout()
        
        # Symbol selection for chart
        chart_controls.addWidget(QLabel(I18N.t("Symbol:", "MÃ£:")))
        self.chart_symbol_combo = QComboBox()
        self.chart_symbol_combo.currentTextChanged.connect(self.on_chart_symbol_changed)
        chart_controls.addWidget(self.chart_symbol_combo)
        
        # Timeframe selection for chart
        chart_controls.addWidget(QLabel(I18N.t("Timeframe:", "Khung thá»i gian:")))
        self.chart_timeframe_combo = QComboBox()
        self.chart_timeframe_combo.addItems(list(TIMEFRAME_MAP.keys()))
        # Default timeframe will be restored from config in restore_user_config()
        self.chart_timeframe_combo.currentTextChanged.connect(self.on_chart_timeframe_changed)
        chart_controls.addWidget(self.chart_timeframe_combo)
        
        # Chart control buttons
        self.start_chart_btn = QPushButton(I18N.t("â–¶ï¸ Start Chart", "â–¶ï¸ Báº¯t Ä‘áº§u biá»ƒu Ä‘á»“"))
        self.start_chart_btn.clicked.connect(self.start_chart)
        self.start_chart_btn.setEnabled(False)
        chart_controls.addWidget(self.start_chart_btn)
        
        self.stop_chart_btn = QPushButton(I18N.t("â¹ï¸ Stop Chart", "â¹ï¸ Dá»«ng biá»ƒu Ä‘á»“"))
        self.stop_chart_btn.clicked.connect(self.stop_chart)
        self.stop_chart_btn.setEnabled(False)
        chart_controls.addWidget(self.stop_chart_btn)
        
        # Add chart customization controls
        chart_controls.addWidget(QLabel(" | "))
        
        # Current price line toggle
        self.price_line_checkbox = QCheckBox(I18N.t("Price Line", "ÄÆ°á»ng giÃ¡"))
        self.price_line_checkbox.setChecked(True)
        self.price_line_checkbox.toggled.connect(self.toggle_price_line)
        chart_controls.addWidget(self.price_line_checkbox)
        
        # Update interval
        chart_controls.addWidget(QLabel(I18N.t("Update:", "Cáº­p nháº­t:")))
        self.update_combo = QComboBox()
        self.update_combo.addItems(["5s", "10s", "30s", "1m"])
        self.update_combo.setCurrentText("5s")
        self.update_combo.currentTextChanged.connect(self.change_update_interval)
        chart_controls.addWidget(self.update_combo)
        
        chart_controls.addStretch()
        layout.addLayout(chart_controls)
        
        # Add candlestick chart widget (initially without indicator_tab)
        self.candlestick_chart = CandlestickChart(None)
        layout.addWidget(self.candlestick_chart)

        self.setLayout(layout)

    def set_indicator_tab(self, indicator_tab):
        """Set indicator tab reference after it's created"""
        self.indicator_tab = indicator_tab
        # Update candlestick chart with indicator tab
        if hasattr(self, 'candlestick_chart'):
            self.candlestick_chart.indicator_tab = indicator_tab
            print(f"âœ… DEBUG: CandlestickChart.indicator_tab set to {type(indicator_tab)}")
        else:
            print("âŒ DEBUG: candlestick_chart not found when setting indicator_tab")

    # Remove old methods - moved to AccountTab
    def populate_symbol_list(self):
        self.symbol_list.clear()
        
        # Debug: Print current state
        print(f"ðŸ” DEBUG populate_symbol_list:")
        print(f"  - All symbols count: {len(self.all_symbols)}")
        print(f"  - Checked symbols: {list(self.checked_symbols)}")
        
        # Only clean up checked_symbols if we have symbols from MT5
        # Don't clear when MT5 is disconnected (all_symbols is empty)
        if self.all_symbols:  # Only cleanup if we have MT5 symbols
            original_checked = self.checked_symbols.copy()
            self.checked_symbols = {sym for sym in self.checked_symbols if sym in self.all_symbols}
            
            if original_checked != self.checked_symbols:
                removed = original_checked - self.checked_symbols
                print(f"ðŸ§¹ Cleaned up checked_symbols, removed: {removed}")
        else:
            print("â³ MT5 not connected - preserving checked symbols")
        
        # Populate list with available symbols (from MT5 if connected, or from config if not)
        if self.all_symbols:
            checked = sorted([sym for sym in self.all_symbols if sym in self.checked_symbols])
            unchecked = sorted([sym for sym in self.all_symbols if sym not in self.checked_symbols])
            for sym in checked + unchecked:
                item = QListWidgetItem(sym)
                item.setFlags(item.flags() | Qt.ItemIsUserCheckable)
                if sym in self.checked_symbols:
                    item.setCheckState(Qt.Checked)
                else:
                    item.setCheckState(Qt.Unchecked)
                self.symbol_list.addItem(item)
        else:
            # MT5 not connected - show symbols from config
            for sym in sorted(self.checked_symbols):
                item = QListWidgetItem(f"{sym} (offline)")
                item.setFlags(item.flags() | Qt.ItemIsUserCheckable)
                item.setCheckState(Qt.Checked)
                self.symbol_list.addItem(item)

    def on_clear_all_symbols(self):
        """Clear all selected symbols"""
        if not self.checked_symbols:
            QMessageBox.information(
                self,
                I18N.t("Info", "ThÃ´ng bÃ¡o"),
                I18N.t("No symbols are currently selected.", "ChÆ°a cÃ³ mÃ£ nÃ o Ä‘Æ°á»£c chá»n.")
            )
            return
            
        # Ask for confirmation
        reply = QMessageBox.question(
            self,
            I18N.t("Clear All Symbols", "XÃ³a táº¥t cáº£ mÃ£"),
            I18N.t(
                "Are you sure you want to clear all {n} selected symbols?",
                "Báº¡n cÃ³ cháº¯c muá»‘n xÃ³a táº¥t cáº£ {n} mÃ£ Ä‘Ã£ chá»n?",
                n=len(self.checked_symbols)
            ),
            QMessageBox.Yes | QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            # Clear all selected symbols
            print("ï¿½ï¸ Clearing all selected symbols")
            self.checked_symbols.clear()
            
            # Update UI - uncheck all items
            for i in range(self.symbol_list.count()):
                item = self.symbol_list.item(i)
                item.setCheckState(Qt.Unchecked)
            
            # Save user config and emit signal
            self.save_current_user_config()
            self.update_chart_symbols()
            self.symbols_changed.emit()
            print("âœ… All symbols cleared from selection")

    def filter_and_sort_symbols(self):
        filter_text = self.search_input.text().upper()
        filtered = [sym for sym in self.all_symbols if filter_text in sym.upper()]
        checked = sorted([sym for sym in filtered if sym in self.checked_symbols])
        unchecked = sorted([sym for sym in filtered if sym not in self.checked_symbols])
        self.symbol_list.clear()
        for sym in checked + unchecked:
            item = QListWidgetItem(sym)
            item.setFlags(item.flags() | Qt.ItemIsUserCheckable)
            if sym in self.checked_symbols:
                item.setCheckState(Qt.Checked)
            else:
                item.setCheckState(Qt.Unchecked)
            self.symbol_list.addItem(item)
        self.save_current_user_config()

    def fetch_data(self):
        if not self.checked_symbols:
            QMessageBox.warning(
                self,
                I18N.t("Warning", "Cáº£nh bÃ¡o"),
                I18N.t("Please select at least one symbol", "Vui lÃ²ng chá»n Ã­t nháº¥t má»™t mÃ£")
            )
            return

        # Debug: Print checked symbols
        print(f"ðŸ” DEBUG: Fetching data for symbols: {list(self.checked_symbols)}")

        selected_tfs = [(tf, self.tf_spinboxes[tf].value()) for tf in self.tf_checkboxes if self.tf_checkboxes[tf].isChecked()]
        if not selected_tfs:
            QMessageBox.warning(
                self,
                I18N.t("Warning", "Cáº£nh bÃ¡o"),
                I18N.t("Please select at least one timeframe", "Vui lÃ²ng chá»n Ã­t nháº¥t má»™t khung thá»i gian")
            )
            return

        # Filter out invalid symbols (ones that don't exist in all_symbols)
        valid_symbols = [sym for sym in self.checked_symbols if sym in self.all_symbols]
        invalid_symbols = [sym for sym in self.checked_symbols if sym not in self.all_symbols]
        
        if invalid_symbols:
            print(f"âš ï¸ WARNING: Invalid symbols found: {invalid_symbols}")
            self.log_output.append(f"âš ï¸ Skipping invalid symbols: {', '.join(invalid_symbols)}")
            # Remove invalid symbols from checked_symbols
            self.checked_symbols = set(valid_symbols)
            self.save_current_user_config()
            self.populate_symbol_list()  # Refresh UI

        if not valid_symbols:
            QMessageBox.warning(
                self,
                I18N.t("Warning", "Cáº£nh bÃ¡o"),
                I18N.t(
                    "No valid symbols selected. Please check your symbol selection.",
                    "KhÃ´ng cÃ³ mÃ£ há»£p lá»‡ Ä‘Æ°á»£c chá»n. Vui lÃ²ng kiá»ƒm tra láº¡i danh sÃ¡ch mÃ£."
                )
            )
            return

        self.log_output.append(f"Starting fetch for symbols: {', '.join(valid_symbols)}")
        
        # Add progress tracking
        total_tasks = len(valid_symbols) * len(selected_tfs)
        current_task = 0
        
        for sym in valid_symbols:
            for tf, count in selected_tfs:
                current_task += 1
                try:
                    self.log_output.append(f"ðŸ“Š Fetching {sym} @ {tf} ({current_task}/{total_tasks})")
                    
                    # Add timeout mechanism using threading
                    import threading
                    import time
                    
                    candles = None
                    fetch_error = None
                    
                    def fetch_with_timeout():
                        nonlocal candles, fetch_error
                        try:
                            candles = fetch_and_save_candles(sym, tf, count, folder="data")
                        except Exception as e:
                            fetch_error = str(e)
                    
                    # Create and start thread with timeout
                    fetch_thread = threading.Thread(target=fetch_with_timeout)
                    fetch_thread.daemon = True
                    fetch_thread.start()
                    fetch_thread.join(timeout=30)  # 30 second timeout
                    
                    if fetch_thread.is_alive():
                        msg = f"â° Timeout fetching {sym} @ {tf} (>30s)"
                        self.log_output.append(msg)
                        continue
                    
                    if fetch_error:
                        msg = f"âŒ Error fetching {sym} @ {tf}: {fetch_error}"
                    elif candles:
                        msg = f"âœ… Saved {len(candles)} candles for {sym} @ {tf}"
                    else:
                        msg = f"âŒ No data for {sym} @ {tf}"
                    
                except Exception as e:
                    msg = f"ðŸ’¥ Exception fetching {sym} @ {tf}: {str(e)}"
                
                self.log_output.append(msg)
        self.save_current_user_config()

    def on_fetch_finished(self, msg):
        self.log_output.append(msg)

    def check_connection(self):
        if self.mt5_conn and self.mt5_conn.connected:
            self.status_label.setText("Status: Connected")
            self.status_label.setStyleSheet("font-weight:bold; color:green")
        else:
            self.status_label.setText("Status: Disconnected")
            self.status_label.setStyleSheet("font-weight:bold; color:red")
            self.login_button.setEnabled(True)
            self.logout_button.setEnabled(False)
            self.fetch_button.setEnabled(False)

    def auto_fetch(self):
        """Auto fetch data - disabled by default to prevent spam"""
        # This method was causing continuous data fetching
        # Now disabled to prevent broker API spam
        print("ðŸ“Š Auto fetch is disabled to prevent API spam")
        return

    def restore_user_config(self):
        config = self.user_config.get("market_tab", {})
        checked = config.get("checked_symbols", [])
        self.checked_symbols = set(checked)
        
        # Get saved chart symbol selection
        saved_chart_symbol = config.get("selected_chart_symbol", "")
        saved_chart_timeframe = config.get("selected_chart_timeframe", "H1")
        
        # If no symbols are configured, auto-detect and set defaults using smart mapping
        if not self.checked_symbols and hasattr(self, 'all_symbols') and self.all_symbols:
            self.checked_symbols = self.auto_detect_default_symbols()
            if self.checked_symbols:
                print(f"âœ… Auto-detected symbols: {self.checked_symbols}")
            else:
                print(f"â„¹ï¸ No suitable symbols found in {len(self.all_symbols)} available symbols")
        
        tf_config = config.get("tf_config", {})
        has_any_tf_checked = False
        for tf, cb in self.tf_checkboxes.items():
            is_checked = tf_config.get(tf, {}).get("checked", False)
            cb.setChecked(is_checked)
            if is_checked:
                has_any_tf_checked = True
        
        # If no timeframes are configured, set some defaults
        if not has_any_tf_checked:
            default_timeframes = ["H1", "H4"]
            for tf in default_timeframes:
                if tf in self.tf_checkboxes:
                    self.tf_checkboxes[tf].setChecked(True)
                    print(f"âœ… Set default timeframe: {tf}")
                    
        for tf, spin in self.tf_spinboxes.items():
            spin.setValue(tf_config.get(tf, {}).get("count", 500))
        
        # Populate symbol list first
        self.populate_symbol_list()
        
        # Restore chart symbol selection after populating the list
        if hasattr(self, 'chart_symbol_combo') and hasattr(self, 'chart_timeframe_combo'):
            self.update_chart_symbols()  # Update chart symbols combo
            
            # Restore saved chart symbol if it exists in checked symbols
            if saved_chart_symbol and saved_chart_symbol in self.checked_symbols:
                index = self.chart_symbol_combo.findText(saved_chart_symbol)
                if index >= 0:
                    self.chart_symbol_combo.setCurrentIndex(index)
                    print(f"âœ… Restored chart symbol: {saved_chart_symbol}")
            
            # Restore saved chart timeframe or set default
            if saved_chart_timeframe and saved_chart_timeframe in TIMEFRAME_MAP:
                index = self.chart_timeframe_combo.findText(saved_chart_timeframe)
                if index >= 0:
                    self.chart_timeframe_combo.setCurrentIndex(index)
                    print(f"âœ… Restored chart timeframe: {saved_chart_timeframe}")
            else:
                # Set default timeframe if none saved
                self.chart_timeframe_combo.setCurrentText("H1")
                print("âœ… Set default chart timeframe: H1")
        
        print(f"ðŸ“Š Restored {len(self.checked_symbols)} symbols from config")

    def auto_detect_default_symbols(self):
        """Tá»± Ä‘á»™ng detect symbols phÃ¹ há»£p vá»›i broker hiá»‡n táº¡i"""
        if not hasattr(self, 'all_symbols') or not self.all_symbols:
            return set()
        
        detected_symbols = set()
        
        # Define base symbols we want to find
        target_bases = {
            # Forex majors
            'EURUSD': ['forex', 'major'],
            'GBPUSD': ['forex', 'major'], 
            'USDJPY': ['forex', 'major'],
            'AUDUSD': ['forex', 'major'],
            'GBPJPY': ['forex', 'cross'],
            'EURJPY': ['forex', 'cross'],
            # Crypto
            'BTCUSD': ['crypto'],
            'ETHUSD': ['crypto'],
            'LTCUSD': ['crypto'],
            # Metals
            'XAUUSD': ['metals'],
            'XAGUSD': ['metals'],
        }
        
        # Find the best matching symbol for each base
        for base_symbol, categories in target_bases.items():
            best_match = self._find_best_symbol_match(base_symbol)
            if best_match:
                detected_symbols.add(best_match)
                print(f"ðŸŽ¯ Auto-detected: {base_symbol} -> {best_match}")
                
                # For demo, limit to 7 symbols to avoid clutter
                if len(detected_symbols) >= 7:
                    break
        
        return detected_symbols
    
    def _find_best_symbol_match(self, base_symbol: str):
        """TÃ¬m symbol phÃ¹ há»£p nháº¥t cho base symbol"""
        if not self.all_symbols:
            return None
            
        # Possible variations that brokers use
        variations = [
            base_symbol,                    # EURUSD
            base_symbol + '.',              # EURUSD.  
            base_symbol + '_m',             # EURUSD_m
            base_symbol + 'm',              # EURUSDm
            base_symbol + '_',              # EURUSD_
            base_symbol.lower(),            # eurusd
            base_symbol.lower() + '.',      # eurusd.
            f"#{base_symbol}",              # #EURUSD
            f"{base_symbol}pro",            # EURUSDpro
            f"{base_symbol}c",              # EURUSDc
            f"{base_symbol}i",              # EURUSDi (for crypto)
        ]
        
        # Check exact matches first (preferred)
        for variation in variations:
            if variation in self.all_symbols:
                return variation
        
        # If no exact match, try fuzzy matching with regex
        import re
        pattern = re.compile(f"^{re.escape(base_symbol)}[._#-]?[a-z0-9]*$", re.IGNORECASE)
        
        for symbol in self.all_symbols:
            if pattern.match(symbol):
                return symbol
        
        return None

    def save_current_user_config(self):
        config = {}
        config["checked_symbols"] = list(self.checked_symbols)
        
        # Save currently selected chart symbol and timeframe
        if hasattr(self, 'chart_symbol_combo') and hasattr(self, 'chart_timeframe_combo'):
            config["selected_chart_symbol"] = self.chart_symbol_combo.currentText()
            config["selected_chart_timeframe"] = self.chart_timeframe_combo.currentText()
        
        tf_config = {}
        for tf in self.tf_checkboxes:
            tf_config[tf] = {
                "checked": self.tf_checkboxes[tf].isChecked(),
                "count": self.tf_spinboxes[tf].value()
            }
        config["tf_config"] = tf_config
        
        user_config = load_user_config()
        user_config["market_tab"] = config
        save_user_config(user_config)
        
        # Debug log for symbol save
        if len(self.checked_symbols) <= 5:
            print(f"ðŸ’¾ Saved symbols: {list(self.checked_symbols)}")
        else:
            print(f"ðŸ’¾ Saved {len(self.checked_symbols)} symbols to config")

    def on_connection_changed(self, connected):
        """Handle connection status change from Account tab"""
        if connected:
            self.mt5_conn = self.account_tab.get_mt5_connection()
            if self.mt5_conn:
                self.fetch_button.setEnabled(True)
                self.start_chart_btn.setEnabled(True)
                
                # Get all available symbols from MT5
                self.all_symbols = self.mt5_conn.get_all_symbols()
                print(f"ðŸ“Š Loaded {len(self.all_symbols)} symbols from MT5")
                
                # Restore saved symbol selections and populate list
                self.restore_user_config()
                
                self.log_output.append(I18N.t("âœ… Connected to MT5 - Ready to fetch data", "âœ… ÄÃ£ káº¿t ná»‘i MT5 - Sáºµn sÃ ng láº¥y dá»¯ liá»‡u"))
                # Hide connection warning when connected
                if hasattr(self, 'connection_status'):
                    self.connection_status.hide()
        else:
            self.mt5_conn = None
            self.fetch_button.setEnabled(False)
            self.start_chart_btn.setEnabled(False)
            self.stop_chart_btn.setEnabled(False)
            
            # Save current selections before clearing
            self.save_current_user_config()
            
            # Clear UI but keep checked_symbols in memory for when reconnecting
            self.symbol_list.clear()
            self.all_symbols = []
            self.chart_symbol_combo.clear()
            self.candlestick_chart.stop_realtime_update()
            self.log_output.append("âŒ Disconnected from MT5")
            # Show connection warning when disconnected
            if hasattr(self, 'connection_status'):
                self.connection_status.show()

    def update_chart_symbols(self):
        """Update chart symbol combo with available symbols"""
        self.chart_symbol_combo.clear()
        if self.checked_symbols:
            symbols = sorted(list(self.checked_symbols))
            self.chart_symbol_combo.addItems(symbols)

    def on_symbol_check_changed(self, item):
        sym = item.text()
        old_symbols = self.checked_symbols.copy()
        
        if item.checkState() == Qt.Checked:
            self.checked_symbols.add(sym)
        else:
            self.checked_symbols.discard(sym)
        
        self.save_current_user_config()
        self.update_chart_symbols()
        
        # Trigger smart cleanup if symbols actually changed
        if old_symbols != self.checked_symbols:
            try:
                # Import and trigger smart cleanup
                from smart_cleanup_trigger import trigger_smart_cleanup_on_symbol_change
                cleanup_result = trigger_smart_cleanup_on_symbol_change(self.checked_symbols)
                
                if cleanup_result.get('files_deleted', 0) > 0:
                    print(f"ðŸ§¹ Smart cleanup: Removed {cleanup_result['files_deleted']} files, "
                          f"freed {cleanup_result['space_freed_mb']:.2f} MB")
                
            except Exception as e:
                print(f"âš ï¸ Smart cleanup warning: {e}")
        
        # Emit signal to notify Risk Management tab
        self.symbols_changed.emit()
        # Reduced logging to avoid spam
        if len(self.checked_symbols) <= 10:
            print(f"ðŸ”„ Chart symbols updated: {len(self.checked_symbols)} symbols available")
        else:
            print(f"ðŸ”„ Chart symbols: {len(self.checked_symbols)} symbols available for selection")

    def on_chart_symbol_changed(self, symbol):
        """Handle chart symbol change"""
        # Save the selected chart symbol to config
        self.save_current_user_config()
        
        if self.candlestick_chart and symbol and hasattr(self.candlestick_chart, 'update_timer'):
            if self.candlestick_chart.update_timer.isActive():
                # Restart chart with new symbol
                self.start_chart()
                
        print(f"ðŸ“ˆ Chart symbol changed to: {symbol}")

    def on_chart_timeframe_changed(self, timeframe):
        """Handle chart timeframe change"""
        # Save the selected chart timeframe to config
        self.save_current_user_config()
        
        if self.candlestick_chart and hasattr(self.candlestick_chart, 'update_timer'):
            if self.candlestick_chart.update_timer.isActive():
                # Restart chart with new timeframe
                self.start_chart()
                
        print(f"â° Chart timeframe changed to: {timeframe}")

    def start_chart(self):
        """Start realtime chart"""
        symbol = self.chart_symbol_combo.currentText()
        timeframe_str = self.chart_timeframe_combo.currentText()
        
        if not symbol:
            QMessageBox.warning(
                self,
                I18N.t("Warning", "Cáº£nh bÃ¡o"),
                I18N.t("Please select a symbol for the chart", "Vui lÃ²ng chá»n má»™t mÃ£ Ä‘á»ƒ váº½ biá»ƒu Ä‘á»“")
            )
            return
        
        if not self.mt5_conn:
            QMessageBox.warning(
                self,
                I18N.t("Warning", "Cáº£nh bÃ¡o"),
                I18N.t("Please connect to MT5 first", "Vui lÃ²ng káº¿t ná»‘i MT5 trÆ°á»›c")
            )
            return
        
        # Convert timeframe string to MT5 constant
        timeframe = TIMEFRAME_MAP.get(timeframe_str)
        if not timeframe:
            QMessageBox.warning(
                self,
                I18N.t("Warning", "Cáº£nh bÃ¡o"),
                I18N.t("Invalid timeframe: {t}", "Khung thá»i gian khÃ´ng há»£p lá»‡: {t}", t=timeframe_str)
            )
            return
        
        # Start the chart
        self.candlestick_chart.start_realtime_update(symbol, timeframe, self.mt5_conn)
        self.start_chart_btn.setEnabled(False)
        self.stop_chart_btn.setEnabled(True)
        self.log_output.append(f"ðŸ“ˆ Started realtime chart for {symbol} ({timeframe_str})")

    def stop_chart(self):
        """Stop realtime chart"""
        self.candlestick_chart.stop_realtime_update()
        self.start_chart_btn.setEnabled(True)
        self.stop_chart_btn.setEnabled(False)
        self.log_output.append("â¹ï¸ Stopped realtime chart")

    def toggle_price_line(self, checked):
        """Toggle current price line display"""
        if self.candlestick_chart:
            self.candlestick_chart.show_price_line = checked
            # Refresh chart if running
            if hasattr(self.candlestick_chart, 'update_timer') and self.candlestick_chart.update_timer.isActive():
                self.candlestick_chart.draw_candlesticks()

    def change_update_interval(self, interval_text):
        """Change chart update interval"""
        interval_map = {"5s": 5000, "10s": 10000, "30s": 30000, "1m": 60000}
        interval_ms = interval_map.get(interval_text, 5000)
        
        if self.candlestick_chart and hasattr(self.candlestick_chart, 'update_timer'):
            was_active = self.candlestick_chart.update_timer.isActive()
            if was_active:
                self.candlestick_chart.update_timer.stop()
                self.candlestick_chart.update_timer.start(interval_ms)
                self.log_output.append(f"â±ï¸ Changed update interval to {interval_text}")

class NewsTab(QWidget):
    def refresh_impact_labels(self):
        """Refresh impact checkbox labels when language changes"""
        try:
            for cb in self.impact_checkboxes:
                if hasattr(cb, 'impact_value'):
                    cb.setText(self.get_impact_label(cb.impact_value))
        except Exception as e:
            print(f"[NewsTab] Impact label refresh error: {e}")
    
    def refresh_all_labels(self):
        """Refresh all UI labels when language changes"""
        try:
            # Refresh impact labels
            self.refresh_impact_labels()
            
            # Refresh group box titles
            if hasattr(self, 'filters_group'):
                self.filters_group.setTitle(I18N.t("Filters", "Bá»™ lá»c"))
            
            if hasattr(self, 'auto_trading_group'):
                self.auto_trading_group.setTitle(I18N.t("Auto Trading Integration", "TÃ­ch há»£p giao dá»‹ch tá»± Ä‘á»™ng"))
                
            if hasattr(self, 'auto_schedule_status_group'):
                self.auto_schedule_status_group.setTitle(I18N.t("Auto News Schedule Status", "Tráº¡ng thÃ¡i lá»‹ch tin tá»©c tá»± Ä‘á»™ng"))
            
            # Refresh static labels
            if hasattr(self, 'currency_label'):
                self.currency_label.setText(I18N.t("Currency:", "Tiá»n tá»‡:"))
                
            # Refresh checkbox text
            if hasattr(self, 'use_economic_calendar_checkbox'):
                self.use_economic_calendar_checkbox.setText(I18N.t("âœ… Enable News detection", "âœ… Báº­t phÃ¡t hiá»‡n tin tá»©c"))
                
            if hasattr(self, 'auto_schedule_checkbox'):
                self.auto_schedule_checkbox.setText(I18N.t("âœ… Enable Auto Schedule", "âœ… Báº­t lá»‹ch tá»± Ä‘á»™ng"))
            
            # Refresh fetch button text
            if hasattr(self, 'fetch_button'):
                self.fetch_button.setText(I18N.t("Fetch News", "Láº¥y tin tá»©c"))
                
            if hasattr(self, 'parse_news_times_btn'):
                self.parse_news_times_btn.setText(I18N.t("ðŸ“Š Parse from News", "ðŸ“Š Láº¥y tá»« tin tá»©c"))
            
            # Refresh placeholders and tooltips
            if hasattr(self, 'schedule_times_text'):
                self.schedule_times_text.setPlaceholderText(I18N.t("e.g., 08:30,15:30,21:30", "VD: 08:30,15:30,21:30"))
                self.schedule_times_text.setToolTip(I18N.t("Enter times in HH:MM format, separated by commas", "Nháº­p giá» theo Ä‘á»‹nh dáº¡ng HH:MM, phÃ¢n cÃ¡ch báº±ng dáº¥u pháº©y"))
                
            if hasattr(self, 'parse_news_times_btn'):
                self.parse_news_times_btn.setToolTip(I18N.t("Parse news release times from latest fetched data", "Láº¥y giá» ra tin tá»« dá»¯ liá»‡u tin tá»©c má»›i nháº¥t"))
            
            # Update auto schedule status if available
            if hasattr(self, 'schedule_status_label'):
                try:
                    self.update_auto_schedule_status("ðŸ¤– System Active", "ðŸ¤– Há»‡ thá»‘ng hoáº¡t Ä‘á»™ng")
                except:
                    pass
                
        except Exception as e:
            print(f"[NewsTab] All labels refresh error: {e}")

    def get_impact_label(self, impact_level):
        """Get localized impact label"""
        impact_labels = {
            1: I18N.t("Low", "Tháº¥p"),
            2: I18N.t("Medium", "Trung bÃ¬nh"), 
            3: I18N.t("High", "Cao")
        }
        return impact_labels.get(impact_level, "Unknown")

    def __init__(self):
        super().__init__()
        self.settings = {}  # Initialize settings dict for save_news_settings
        self.init_ui()
        self.last_loaded_file = None

    def load_latest_news_file(self, silent: bool = True):
        """Load most recent news_output/news_forexfactory_*.json and display."""
        try:
            pattern = os.path.join('news_output', 'news_forexfactory_*.json')
            files = sorted(glob.glob(pattern), reverse=True)
            if not files:
                if not silent:
                    self.news_text.append("âš ï¸ No news files found.")
                return False
            latest = files[0]
            if self.last_loaded_file == latest:
                return False  # unchanged
            with open(latest,'r',encoding='utf-8') as f:
                data = json.load(f)
            # data may already be list; ensure correct type
            if isinstance(data, dict) and 'events' in data:
                events = data['events']
            elif isinstance(data, list):
                events = data
            else:
                events = []
            self.display_news(events)
            self.last_loaded_file = latest
            if not silent:
                self.news_text.append(f"\nâœ… Loaded latest file: {os.path.basename(latest)}")
            return True
        except Exception as e:
            if not silent:
                self.news_text.append(f"âŒ Error loading latest news: {e}")
            return False

    # Slot wrapper to safely call from timers
    def load_latest_news_file_slot(self):  # no decorator needed; used in QTimer.singleShot
        self.load_latest_news_file(silent=True)

    def init_ui(self):
        layout = QVBoxLayout()

        self.filters_group = QGroupBox(I18N.t("Filters", "Bá»™ lá»c"))
        filters_layout = QHBoxLayout()

        currency_layout = QVBoxLayout()
        self.currency_label = QLabel(I18N.t("Currency:", "Tiá»n tá»‡:"))
        currency_layout.addWidget(self.currency_label)
        self.currency_checkboxes = []
        for curr in ALL_CURRENCY:
            cb = QCheckBox(curr)
            cb.setChecked(True)
            cb.stateChanged.connect(self.on_filter_changed)  # Auto-save on change
            self.currency_checkboxes.append(cb)
            currency_layout.addWidget(cb)
        filters_layout.addLayout(currency_layout)

        impact_layout = QVBoxLayout()
        impact_layout.addWidget(QLabel(I18N.t("Impact:", "TÃ¡c Ä‘á»™ng:")))
        self.impact_checkboxes = []
        for imp in ALL_IMPACT:
            label = self.get_impact_label(imp)
            cb = QCheckBox(label)
            cb.setChecked(True)
            cb.impact_value = imp
            cb.stateChanged.connect(self.on_filter_changed)  # Auto-save on change
            self.impact_checkboxes.append(cb)
            impact_layout.addWidget(cb)
        filters_layout.addLayout(impact_layout)

        self.filters_group.setLayout(filters_layout)
        layout.addWidget(self.filters_group)

        # Auto trading integration group
        self.auto_trading_group = QGroupBox(I18N.t("Auto Trading Integration", "TÃ­ch há»£p giao dá»‹ch tá»± Ä‘á»™ng"))
        auto_trading_layout = QVBoxLayout()
        
        self.use_economic_calendar_checkbox = QCheckBox(I18N.t("âœ… Enable News detection", "âœ… Báº­t phÃ¡t hiá»‡n tin tá»©c"))
        
        # Load saved setting from user config
        try:
            user_config = load_user_config()
            saved_state = user_config.get("use_economic_calendar", True)
            self.use_economic_calendar_checkbox.setChecked(saved_state)
            print(f"[NewsTab] Loaded news detection setting: {saved_state}")
        except Exception as e:
            print(f"[NewsTab] Error loading setting, using default: {e}")
            self.use_economic_calendar_checkbox.setChecked(True)  # Fallback default
        
        self.use_economic_calendar_checkbox.setToolTip(
            "When enabled, auto trading will consider economic news events.\n"
            "High impact news may pause or modify trading decisions."
        )
        self.use_economic_calendar_checkbox.stateChanged.connect(self.on_economic_calendar_toggle)
        auto_trading_layout.addWidget(self.use_economic_calendar_checkbox)
        
        self.auto_trading_group.setLayout(auto_trading_layout)
        layout.addWidget(self.auto_trading_group)

        # Auto Schedule Status Display (Read-only)
        self.auto_schedule_status_group = QGroupBox(I18N.t("Auto News Schedule Status", "Tráº¡ng thÃ¡i lá»‹ch tin tá»©c tá»± Ä‘á»™ng"))
        status_layout = QVBoxLayout()
        
        # Status display
        self.schedule_status_label = QLabel(I18N.t("ðŸ¤– Auto-schedule: Initializing...", "ðŸ¤– Lá»‹ch tá»± Ä‘á»™ng: Äang khá»Ÿi táº¡o..."))
        self.schedule_status_label.setStyleSheet("color: #4CAF50; font-weight: bold;")
        status_layout.addWidget(self.schedule_status_label)
        
        # Current scheduled times display
        self.scheduled_times_label = QLabel(I18N.t("ðŸ“… Scheduled Times: None", "ðŸ“… Giá» Ä‘Ã£ lÃªn lá»‹ch: ChÆ°a cÃ³"))
        self.scheduled_times_label.setStyleSheet("color: #2196F3; font-size: 11px;")
        status_layout.addWidget(self.scheduled_times_label)
        
        # Next schedule display
        self.next_schedule_label = QLabel(I18N.t("â° Next Auto-Fetch: Calculating...", "â° QuÃ©t tin tiáº¿p theo: Äang tÃ­nh..."))
        self.next_schedule_label.setStyleSheet("color: #FF9800; font-size: 11px;")
        status_layout.addWidget(self.next_schedule_label)
        
        self.auto_schedule_status_group.setLayout(status_layout)
        layout.addWidget(self.auto_schedule_status_group)

        self.fetch_button = QPushButton(I18N.t("Fetch News", "Láº¥y tin tá»©c"))
        self.fetch_button.clicked.connect(self.fetch_news)
        layout.addWidget(self.fetch_button)

        self.news_text = QTextEdit()
        self.news_text.setReadOnly(True)
        layout.addWidget(self.news_text)

        self.setLayout(layout)
        
        # Initialize auto schedule system
        self.schedule_timers = []  # List to store QTimer objects
        self.schedule_times = []   # List of schedule times in HH:MM format
        self.auto_schedule_enabled = True  # Always enabled in auto mode
        
        # Initialize auto schedule manager thread
        self.auto_schedule_manager = None
        
        # Load saved settings after initialization
        self.load_news_settings()
        
        # Start auto schedule system automatically in separate thread
        self.start_auto_news_system_threaded()

    def fetch_news(self):
        print("ðŸ”„ Fetch News button clicked!")  # Debug log
        
        # Dá»«ng worker cÅ© náº¿u cÃ²n cháº¡y
        if hasattr(self, "worker") and self.worker is not None and self.worker.isRunning():
            self.worker.quit()
            self.worker.wait()
        
        selected_currencies = [cb.text() for cb in self.currency_checkboxes if cb.isChecked()]
        selected_impacts = [cb.impact_value for cb in self.impact_checkboxes if cb.isChecked()]

        print(f"ðŸ” Selected currencies: {selected_currencies}")  # Debug log
        print(f"ðŸ” Selected impacts: {selected_impacts}")  # Debug log

        if not selected_currencies or not selected_impacts:
            QMessageBox.warning(
                self,
                I18N.t("Warning", "Cáº£nh bÃ¡o"),
                I18N.t("Please select at least one currency and impact level", "Vui lÃ²ng chá»n Ã­t nháº¥t má»™t Ä‘á»“ng tiá»n vÃ  má»©c Ä‘á»™ áº£nh hÆ°á»Ÿng")
            )
            return

        self.news_text.clear()
        self.news_text.append("ðŸ”„ Loading economic calendar data...")

        print("ðŸš€ Starting NewsWorker...")  # Debug log
        self.worker = NewsWorker(selected_currencies, selected_impacts)
        self.worker.finished.connect(self.display_news)
        self.worker.error.connect(self.on_news_error)
        self.worker.start()
        print("âœ… NewsWorker started!")  # Debug log

    def on_news_error(self, msg):
        print(f"ðŸ“° News error received: {msg}")  # Debug log
        QMessageBox.critical(self, I18N.t("Error", "Lá»—i"), msg)
        self.news_text.setText(I18N.t("âŒ Error fetching news: {msg}", "âŒ Lá»—i láº¥y tin tá»©c: {msg}", msg=msg))

    def display_news(self, news_list):
        print(f"ðŸ“° Display news called with {len(news_list)} events")  # Debug log
        
        self.news_text.clear()
        if not news_list:
            self.news_text.append("ðŸ“… No economic events found for today.")
            self.news_text.append("")
            self.news_text.append("ðŸ” Source used:")
            self.news_text.append("   â€¢ âœ… ForexFactory.com (Selenium scraping)")
            self.news_text.append("")
            self.news_text.append("ðŸ“‹ This could be because:")
            self.news_text.append("   â€¢ Today is a weekend or holiday")
            self.news_text.append("   â€¢ No major economic events are scheduled")
            self.news_text.append("   â€¢ All economic data sources are temporarily unavailable")
            self.news_text.append("")
            self.news_text.append("ðŸ’¡ Solutions:")
            self.news_text.append("   â€¢ Try again tomorrow for weekday economic calendar events")
            self.news_text.append("   â€¢ Check ForexFactory.com manually if needed")
            self.news_text.append("   â€¢ Consider using alternative news sources")
            return
        
        # Get status information from news items
        status_message = news_list[0].get('_status_message', 'â“ Status unknown') if news_list else 'â“ Status unknown'
        is_real_data = news_list[0].get('_is_real_data', False) if news_list else False
        
        impact_colors = {
            "High": "#d64541",
            "Medium": "#f5a623", 
            "Low": "#f7ca18",
            "None": "#b2b2b2"
        }
        
        # Display header with status information
        first_news = news_list[0]
        date_field = first_news.get("date", "")
        if not date_field:
            dt = first_news.get("datetime", "")
            parts = dt.split()
            if len(parts) >= 3:
                date_field = f"{parts[1]} {parts[2]}"
            else:
                date_field = dt
        
        # Display status banner for real data
        try:
            # Determine data source based on event properties
            data_source = "Unknown source"
            if news_list and len(news_list) > 0:
                # We currently use Selenium-only from ForexFactory
                data_source = "ðŸ“¡ ForexFactory.com (Selenium)"
            
            self.news_text.append(
                f"<div style='background-color:#d4edda; border:1px solid #c3e6cb; padding:12px; border-radius:8px; margin-bottom:15px;'>"
                f"<b>ðŸ“¡ {I18N.t('Data Source:', 'Nguá»“n dá»¯ liá»‡u:')}</b> {data_source}<br>"
                f"<b>ðŸ”„ {I18N.t('System:', 'Há»‡ thá»‘ng:')}</b> ForexFactory (Selenium-only)"
                f"</div>"
            )
        except:
            pass
        
        # Add timezone information header
        self.news_text.append(
            f"<div style='background-color:#e3f2fd; border:1px solid #bbdefb; padding:10px; border-radius:6px; margin-bottom:10px;'>"
            f"<b>ðŸ• {I18N.t('Timezone:', 'MÃºi giá»:')}</b> {I18N.t('All times displayed in', 'Táº¥t cáº£ thá»i gian hiá»ƒn thá»‹ theo')} <b>{I18N.t('Vietnam Time (UTC+7)', 'Giá» Viá»‡t Nam (UTC+7)')}</b>"
            f"</div>"
        )
        
        self.news_text.append(f"<b>ðŸ“… {I18N.t('Date:', 'NgÃ y:')} {date_field}</b> | <b>ðŸ“Š {I18N.t('Found', 'TÃ¬m tháº¥y')} {len(news_list)} {I18N.t('events', 'sá»± kiá»‡n')}</b><br><hr>")

        for news in news_list:
            impact = news.get("impact", 0)
            # Handle both numeric and string impact values
            if isinstance(impact, str):
                impact_map = {"Low": 1, "Medium": 2, "High": 3}
                impact = impact_map.get(impact, 1)
            impact = int(impact)
            
            if impact == 0:
                continue
                
            time = news.get("time", "")
            timezone_info = news.get("timezone", "")
            currency = news.get("currency", "N/A")
            
            # Handle both string and numeric impact values
            raw_impact = news.get("impact", "None")
            if isinstance(raw_impact, str):
                # If impact is string like "High", "Medium", "Low", use directly
                impact_label = raw_impact.title() if raw_impact else "None"
            else:
                # If impact is numeric, use mapping
                impact_label = self.get_impact_label(raw_impact)
            
            impact_color = impact_colors.get(impact_label, "#b2b2b2")
            title = news.get("title", news.get("event", "No Title"))
            
            # Format time without additional timezone info since header already shows it
            time_display = time  # Don't add timezone_info here since header already shows Vietnam Time
            
            # Better parsing of actual value
            actual_value = news.get("actual", "TBA")
            
            # Check if this is a real economic event with potential actual data
            if actual_value == "TBA" and news.get("_is_real_data", False):
                # For real events, check if it's past the release time
                try:
                    from datetime import datetime
                    import pytz
                    now_vn = datetime.now(pytz.timezone('Asia/Ho_Chi_Minh'))
                    
                    # If we have time info, try to determine if event has passed
                    event_time = news.get("time", "")
                    if event_time and ":" in event_time:
                        # Parse time like "08:30 (UTC+7)" or "08:30"
                        clean_time = event_time.replace("(UTC+7)", "").strip()
                        try:
                            event_hour, event_min = map(int, clean_time.split(":"))
                            today = now_vn.replace(hour=event_hour, minute=event_min, second=0, microsecond=0)
                            
                            if now_vn > today:
                                actual_value = "Released (Check Source)"
                            else:
                                actual_value = "Pending"
                        except:
                            actual_value = "TBA"
                except:
                    actual_value = "TBA"
            
            description = news.get("description", "")
            if "|" in description:
                parts = description.split("|")
                description_actual = parts[0].replace("Actual:", "").strip()
            else:
                description_actual = news.get("actual", "TBA")
            
            # Use the improved actual_value we calculated above, fallback to description if needed
            final_actual = actual_value if actual_value != "TBA" else description_actual
            
            status = "Released" if final_actual and final_actual not in ["TBA", "Pending", ""] else "Forecast"
            forecast = news.get("forecast", "N/A")
            previous = news.get("previous", "N/A")
            
            # Use event field if title is empty
            if not title or title == "No Title":
                title = news.get("event", "Economic Event")
            
            self.news_text.append(
                f"<b>ðŸ• {I18N.t('Time', 'Thá»i gian')}:</b> <span style='color:#007acc'><b>{time_display}</b></span> | "
                f"<b>ðŸ’± {currency}</b> | <b>ðŸ“ˆ {I18N.t('Impact', 'TÃ¡c Ä‘á»™ng')}:</b> <span style='color:{impact_color}'><b>{impact_label}</b></span><br>"
                f"<b>ðŸ“° {I18N.t('Event', 'Sá»± kiá»‡n')}:</b> {title}<br>"
                f"<b>âœ… {I18N.t('Actual', 'Thá»±c táº¿')}:</b> <span style='color:#27ae60'><b>{final_actual}</b></span> | "
                f"<b>ðŸŽ¯ {I18N.t('Forecast', 'Dá»± bÃ¡o')}:</b> <span style='color:#e67e22'><b>{forecast}</b></span> | "
                f"<b>ðŸ“Š {I18N.t('Previous', 'TrÆ°á»›c Ä‘Ã³')}:</b> <span style='color:#e74c3c'><b>{previous}</b></span> | "
                f"<b>ðŸ”– {I18N.t('Status', 'Tráº¡ng thÃ¡i')}:</b> <span style='color:#007acc'><b>{status}</b></span><br>"
                "<hr>"
            )
        
        # ðŸ¤– Auto-parse and auto-schedule news times after displaying
        self.auto_parse_and_schedule_news_times()

    def on_economic_calendar_toggle(self, state):
        """Xá»­ lÃ½ khi checkbox economic calendar Ä‘Æ°á»£c toggle"""
        is_enabled = state == 2  # Qt.Checked = 2
        
        # LÆ°u setting vÃ o user config
        user_config = load_user_config()
        user_config["use_economic_calendar"] = is_enabled
        save_user_config(user_config)
        
        # Log thÃ´ng bÃ¡o
        status_text = "enabled" if is_enabled else "disabled"
        print(f"ðŸ“° News detection in Auto Trading: {status_text}")
        
        # Hiá»ƒn thá»‹ thÃ´ng bÃ¡o cho user
        status_msg = "âœ… Enabled" if is_enabled else "âŒ Disabled"
        self.news_text.append(
            f"<div style='background-color:{'#d4edda' if is_enabled else '#f8d7da'}; "
            f"border:1px solid {'#c3e6cb' if is_enabled else '#f5c6cb'}; "
            f"padding:8px; border-radius:4px; margin:5px 0;'>"
            f"<b>ï¿½ News Detection: {status_msg}</b><br>"
            f"Economic news will {'be detected and considered' if is_enabled else 'be ignored'} during auto trading."
            f"</div>"
        )

    def get_economic_calendar_setting(self):
        """Láº¥y setting hiá»‡n táº¡i cá»§a economic calendar"""
        return self.use_economic_calendar_checkbox.isChecked()

    def save_news_settings(self):
        """Save NewsTab settings to file"""
        try:
            import os
            os.makedirs("news_output", exist_ok=True)
            
            # Get selected currencies
            selected_currencies = [cb.text() for cb in self.currency_checkboxes if cb.isChecked()]
            # Get selected impact levels
            selected_impacts = [cb.impact_value for cb in self.impact_checkboxes if cb.isChecked()]
            
            # Save into instance settings for consistency
            self.settings['selected_currencies'] = selected_currencies
            self.settings['selected_impacts'] = selected_impacts
            self.settings['use_economic_calendar'] = self.use_economic_calendar_checkbox.isChecked()
            
            settings_file = "news_output/news_settings.json"
            import json
            with open(settings_file, 'w', encoding='utf-8') as f:
                json.dump(self.settings, f, indent=2, ensure_ascii=False)
            
            print(f"âœ… News settings saved: {len(selected_currencies)} currencies, {len(selected_impacts)} impact levels")
            
            # Also update user_config for economic calendar
            user_config = load_user_config()
            user_config["use_economic_calendar"] = self.settings.get('use_economic_calendar', True)
            save_user_config(user_config)
            
        except Exception as e:
            print(f"âŒ Error saving news settings: {e}")

    def load_news_settings(self):
        """Load NewsTab settings from file"""
        try:
            settings_file = "news_output/news_settings.json"
            if not os.path.exists(settings_file):
                print("[NewsTab] No saved settings found, using defaults")
                return
            
            import json
            with open(settings_file, 'r', encoding='utf-8') as f:
                settings = json.load(f)
            
            # Restore currency selections
            selected_currencies = settings.get('selected_currencies', [])
            for cb in self.currency_checkboxes:
                cb.setChecked(cb.text() in selected_currencies)
            
            # Restore impact level selections
            selected_impacts = settings.get('selected_impacts', [3])  # Default to High
            for cb in self.impact_checkboxes:
                cb.setChecked(cb.impact_value in selected_impacts)
            
            # Restore economic calendar setting
            use_calendar = settings.get('use_economic_calendar', True)
            self.use_economic_calendar_checkbox.setChecked(use_calendar)
            
            print(f"âœ… News settings loaded: {len(selected_currencies)} currencies, {len(selected_impacts)} impact levels")
            
        except Exception as e:
            print(f"âŒ Error loading news settings: {e}")

    def get_user_news_filters(self):
        """Get current user-selected filters for auto news fetch"""
        selected_currencies = [cb.text() for cb in self.currency_checkboxes if cb.isChecked()]
        selected_impacts = [cb.impact_value for cb in self.impact_checkboxes if cb.isChecked()]
        
        # If nothing selected, use defaults
        if not selected_currencies:
            selected_currencies = ['USD', 'EUR', 'GBP', 'JPY']
        if not selected_impacts:
            selected_impacts = [2, 3]  # Medium + High
            
        return selected_currencies, selected_impacts

    def on_filter_changed(self):
        """Auto-save when filter selections change"""
        try:
            # Small delay to avoid rapid saves during multiple changes
            from PyQt5.QtCore import QTimer
            if hasattr(self, '_save_timer'):
                self._save_timer.stop()
            
            self._save_timer = QTimer()
            self._save_timer.setSingleShot(True)
            self._save_timer.timeout.connect(self.save_news_settings)
            self._save_timer.start(1000)  # Save after 1 second of no changes
        except Exception as e:
            print(f"âŒ Error in filter change handler: {e}")
    
    def start_auto_news_system_threaded(self):
        """ðŸ¤– Start threaded auto news system (non-blocking)"""
        try:
            print("ðŸ¤– [AutoNews] Starting threaded auto news system...")
            
            # Create and start auto schedule manager thread
            self.auto_schedule_manager = NewsAutoScheduleManager(self)
            
            # Connect signals for UI updates
            self.auto_schedule_manager.status_updated.connect(self.update_auto_schedule_status)
            self.auto_schedule_manager.times_updated.connect(self.update_scheduled_times_display)
            self.auto_schedule_manager.next_schedule_updated.connect(self.update_next_schedule_display)
            self.auto_schedule_manager.news_fetched.connect(self.display_news)
            
            # Start thread
            self.auto_schedule_manager.start()
            
            # Update initial status
            self.update_auto_schedule_status("ðŸ¤– Starting Thread...", "ðŸ¤– Khá»Ÿi Ä‘á»™ng luá»“ng...")
            
            print("âœ… [AutoNews] Threaded auto news system started")
            
        except Exception as e:
            print(f"âŒ [AutoNews] Error starting threaded system: {e}")
            self.update_auto_schedule_status("âŒ Thread Error", "âŒ Lá»—i luá»“ng")
    
    # Old methods removed - now handled by NewsAutoScheduleManager thread
    
    def update_auto_schedule_status(self, en_text, vi_text):
        """ðŸ“± Update auto schedule status display"""
        try:
            status_text = I18N.t(en_text, vi_text)
            self.schedule_status_label.setText(status_text)
        except Exception as e:
            print(f"âŒ Error updating status: {e}")
    
    def update_scheduled_times_display(self, text):
        """ðŸ“… Update scheduled times display"""
        try:
            self.scheduled_times_label.setText(text)
        except Exception as e:
            print(f"âŒ Error updating times display: {e}")
    
    def update_next_schedule_display(self, text):
        """â° Update next schedule display"""
        try:
            self.next_schedule_label.setText(text)
        except Exception as e:
            print(f"âŒ Error updating next schedule: {e}")
    
    def auto_parse_and_schedule_news_times(self):
        """ðŸ¤– Show auto-parsing notification (actual parsing done in thread)"""
        try:
            print("ðŸ¤– [AutoNews] News displayed - background thread handling auto-parse...")
            
            # Just show notification that background system is handling this
            # Background system handles everything automatically - no UI notification needed


            # Fixed problematic auto-schedule notification line
                
            pass
                
        except Exception as e:
            print(f"âŒ [AutoNews] Error in auto-parse notification: {e}")
    
    def cleanup_resources(self):
        """ðŸ§¹ Cleanup resources when closing"""
        try:
            print("ðŸ§¹ [NewsTab] Cleaning up threaded auto news system...")
            
            # Stop auto schedule manager thread
            if hasattr(self, 'auto_schedule_manager') and self.auto_schedule_manager is not None:
                self.auto_schedule_manager.stop()
                self.auto_schedule_manager = None
            
            # Stop all legacy timers
            for timer in self.schedule_timers:
                timer.stop()
                timer.deleteLater()
            self.schedule_timers.clear()
            
            # Stop any running news workers
            if hasattr(self, "worker") and self.worker is not None and self.worker.isRunning():
                self.worker.quit()
                self.worker.wait()
                
            if hasattr(self, "auto_worker") and self.auto_worker is not None and self.auto_worker.isRunning():
                self.auto_worker.quit()
                self.auto_worker.wait()
            
            print("âœ… [NewsTab] Threaded auto news system cleanup complete")
            
        except Exception as e:
            print(f"âŒ Error during NewsTab cleanup: {e}")

def format_time(time_val):
    if isinstance(time_val, (int, float)):
        try:
            dt = datetime.datetime.fromtimestamp(time_val)
            return dt.strftime("%d/%m %H:%M")
        except Exception:
            return str(time_val)
    if isinstance(time_val, str):
        for fmt in ("%Y-%m-%d %H:%M:%S", "%Y-%m-%dT%H:%M:%S", "%Y/%m/%d %H:%M:%S"):
            try:
                dt = datetime.datetime.strptime(time_val, fmt)
                return dt.strftime("%d/%m %H:%M")
            except Exception:
                continue
    return str(time_val)

class NewsAutoScheduleManager(QThread):
    """ðŸ¤– Thread quáº£n lÃ½ auto-schedule tin tá»©c Ä‘á»™c láº­p"""
    
    # Signals Ä‘á»ƒ giao tiáº¿p vá»›i main thread
    status_updated = pyqtSignal(str, str)  # (en_text, vi_text)
    times_updated = pyqtSignal(str)        # times_display
    next_schedule_updated = pyqtSignal(str)  # next_schedule_info
    news_fetched = pyqtSignal(list)        # news_events
    
    def __init__(self, parent_tab):
        super().__init__()
        self.parent_tab = parent_tab
        self.running = True
        self.schedule_times = []
        self.schedule_timers = []
        self.monitor_timer = None  # Initialize in run() method
        
    def run(self):
        """ðŸš€ Main thread loop for auto schedule system"""
        try:
            print("ðŸ¤– [AutoScheduleManager] Thread started")
            
            # Initialize monitor timer in this thread
            self.monitor_timer = QTimer()
            self.monitor_timer.timeout.connect(self.monitor_and_update_schedule)
            
            # Check if news detection is enabled before starting
            if self.is_news_detection_enabled():
                print("âœ… [AutoScheduleManager] News detection enabled - starting auto system")
                
                # Initial news fetch
                self.fetch_and_parse_news()
                
                # Start monitoring timer (every 5 minutes)
                self.monitor_timer.start(5 * 60 * 1000)  # 5 minutes
                
                # Update status
                self.status_updated.emit("ðŸ¤– Thread Active", "ðŸ¤– Luá»“ng hoáº¡t Ä‘á»™ng")
            else:
                print("âš ï¸ [AutoScheduleManager] News detection disabled - waiting for enable")
                # Start monitoring timer to check periodically
                self.monitor_timer.start(30 * 1000)  # Check every 30 seconds
                self.status_updated.emit("â¸ï¸ Waiting for News Detection", "â¸ï¸ Äang chá» báº­t phÃ¡t hiá»‡n tin")
            
            # Keep thread alive
            self.exec_()  # Start event loop
            
        except Exception as e:
            print(f"âŒ [AutoScheduleManager] Thread error: {e}")
    
    def is_news_detection_enabled(self):
        """ðŸ” Check if news detection checkbox is enabled"""
        try:
            return (hasattr(self.parent_tab, 'use_economic_calendar_checkbox') and 
                    self.parent_tab.use_economic_calendar_checkbox.isChecked())
        except:
            return False
            
    def fetch_and_parse_news(self):
        """ðŸ“° Fetch news and parse times in background"""
        try:
            # Check if news detection is enabled before fetching
            if not self.is_news_detection_enabled():
                print("âš ï¸ [AutoScheduleManager] News detection disabled - skipping fetch")
                self.status_updated.emit("â¸ï¸ News Detection OFF", "â¸ï¸ PhÃ¡t hiá»‡n tin Táº®T")
                return
                
            print("ðŸ¤– [AutoScheduleManager] Fetching news in background...")
            
            # Get current filters from parent tab
            selected_currencies = []
            selected_impacts = []
            
            try:
                # Safely get filters from main thread
                if hasattr(self.parent_tab, 'currency_checkboxes'):
                    selected_currencies = [cb.text() for cb in self.parent_tab.currency_checkboxes if cb.isChecked()]
                if hasattr(self.parent_tab, 'impact_checkboxes'):
                    selected_impacts = [cb.impact_value for cb in self.parent_tab.impact_checkboxes if cb.isChecked()]
            except:
                pass
                
            # Use defaults if no filters
            if not selected_currencies:
                selected_currencies = ['USD', 'EUR', 'JPY', 'GBP']
            if not selected_impacts:
                selected_impacts = [2, 3]
                
            # Fetch news in background thread
            from news_scraper import get_today_news
            news_events = get_today_news(selected_currencies, selected_impacts, headless=True, auto_cleanup=False)
            
            if news_events:
                # Parse times
                from news_scraper import parse_news_release_times
                news_times = parse_news_release_times()
                
                if news_times:
                    self.schedule_times = news_times.copy()
                    self.schedule_auto_updates()
                    
                    # Emit signals to update UI
                    times_display = f"ðŸ“… Auto-parsed {len(news_times)} times: {', '.join(news_times[:3])}" + (f" (+{len(news_times)-3} more)" if len(news_times) > 3 else "")
                    self.times_updated.emit(times_display)
                    
                    print(f"âœ… [AutoScheduleManager] Parsed {len(news_times)} times in background")
                else:
                    print("âš ï¸ [AutoScheduleManager] No times found, using fallback")
                    self.schedule_fallback_updates()
                    
                # Emit news to main thread for display
                self.news_fetched.emit(news_events)
                
        except Exception as e:
            print(f"âŒ [AutoScheduleManager] Error in background fetch: {e}")
            
    def schedule_auto_updates(self):
        """â° Schedule automatic updates in background thread"""
        try:
            # Clear existing timers
            for timer in self.schedule_timers:
                timer.stop()
                timer.deleteLater()
            self.schedule_timers.clear()
            
            from datetime import datetime, timedelta
            import pytz
            vn_tz = pytz.timezone('Asia/Ho_Chi_Minh')
            now = datetime.now(vn_tz)
            
            scheduled_count = 0
            next_schedule = None
            
            for time_str in self.schedule_times:
                try:
                    hour, minute = map(int, time_str.split(':'))
                    if 0 <= hour <= 23 and 0 <= minute <= 59:
                        target_time = now.replace(hour=hour, minute=minute, second=0, microsecond=0)
                        if target_time <= now:
                            target_time += timedelta(days=1)
                            
                        delay_ms = int((target_time - now).total_seconds() * 1000)
                        
                        # Create timer in this thread
                        timer = QTimer()
                        timer.moveToThread(self)
                        timer.setSingleShot(True)
                        timer.timeout.connect(lambda ts=time_str: self.execute_scheduled_fetch(ts))
                        timer.start(delay_ms)
                        
                        self.schedule_timers.append(timer)
                        scheduled_count += 1
                        
                        if next_schedule is None or target_time < next_schedule:
                            next_schedule = target_time
                            
                except ValueError:
                    continue
                    
            if scheduled_count > 0 and next_schedule:
                time_until = next_schedule - now
                hours_until = time_until.total_seconds() / 3600
                next_str = f"â° Next: {next_schedule.strftime('%H:%M')} ({hours_until:.1f}h)"
                self.next_schedule_updated.emit(next_str)
                
                self.status_updated.emit(f"âœ… Active ({scheduled_count} schedules)", f"âœ… Hoáº¡t Ä‘á»™ng ({scheduled_count} lá»‹ch)")
                print(f"â° [AutoScheduleManager] Scheduled {scheduled_count} background updates")
                
        except Exception as e:
            print(f"âŒ [AutoScheduleManager] Error scheduling: {e}")
            
    def schedule_fallback_updates(self):
        """ðŸ”„ Fallback schedule when no news times available"""
        fallback_times = ['08:30', '15:30', '21:30']
        self.schedule_times = fallback_times
        self.schedule_auto_updates()
        self.times_updated.emit(f"ðŸ“… Fallback: {', '.join(fallback_times)}")
        self.status_updated.emit("ðŸ”„ Fallback Mode", "ðŸ”„ Cháº¿ Ä‘á»™ dá»± phÃ²ng")
        
    def execute_scheduled_fetch(self, time_str):
        """ðŸ• Execute scheduled fetch in background"""
        try:
            print(f"ðŸ• [AutoScheduleManager] Background fetch at {time_str}")
            self.fetch_and_parse_news()
            
            # Reschedule for tomorrow
            timer = QTimer()
            timer.moveToThread(self)
            timer.setSingleShot(True)
            timer.timeout.connect(lambda: self.execute_scheduled_fetch(time_str))
            timer.start(24 * 60 * 60 * 1000)  # 24 hours
            
        except Exception as e:
            print(f"âŒ [AutoScheduleManager] Error in scheduled fetch: {e}")
            
    def monitor_and_update_schedule(self):
        """ðŸ” Monitor and update schedule periodically"""
        try:
            # Check if news detection is enabled
            if not self.is_news_detection_enabled():
                print("âš ï¸ [AutoScheduleManager] News detection disabled - monitoring paused")
                self.status_updated.emit("â¸ï¸ News Detection OFF", "â¸ï¸ PhÃ¡t hiá»‡n tin Táº®T")
                
                # Clear any existing timers when disabled
                for timer in self.schedule_timers:
                    timer.stop()
                    timer.deleteLater()
                self.schedule_timers.clear()
                return
            
            # If news detection is enabled, continue monitoring
            if not hasattr(self, '_detection_was_enabled') or not self._detection_was_enabled:
                print("âœ… [AutoScheduleManager] News detection re-enabled - resuming auto system")
                self.fetch_and_parse_news()
                self._detection_was_enabled = True
                return
                
            from news_scraper import parse_news_release_times
            new_times = parse_news_release_times()
            
            if new_times and new_times != self.schedule_times:
                print(f"ðŸ”„ [AutoScheduleManager] Updated schedule detected: {len(new_times)} times")
                self.schedule_times = new_times.copy()
                self.schedule_auto_updates()
                
            self._detection_was_enabled = True
                
        except Exception as e:
            print(f"âŒ [AutoScheduleManager] Monitor error: {e}")
            
    def stop(self):
        """ðŸ›‘ Stop the auto schedule manager"""
        try:
            self.running = False
            
            # Stop monitor timer
            if self.monitor_timer:
                self.monitor_timer.stop()
                
            # Stop all schedule timers
            for timer in self.schedule_timers:
                timer.stop()
                timer.deleteLater()
            self.schedule_timers.clear()
            
            # Quit thread
            self.quit()
            self.wait(3000)  # Wait max 3 seconds
            
            print("âœ… [AutoScheduleManager] Thread stopped")
            
        except Exception as e:
            print(f"âŒ [AutoScheduleManager] Error stopping: {e}")

class NewsWorker(QThread):
    finished = pyqtSignal(list)
    error = pyqtSignal(str)
    news_ready = pyqtSignal(list)  # New signal for auto system
    error_occurred = pyqtSignal(str)  # Alternative error signal

    def __init__(self, selected_currencies, selected_impacts):
        super().__init__()
        self.selected_currencies = selected_currencies
        self.selected_impacts = selected_impacts
        self.timeout_seconds = 60
    
    def run(self):
        """Run news fetching using NewsScraperSelenium"""
        try:
            print(f"ðŸ” NewsWorker: Starting news fetch...")
            print(f"ðŸ” Selected currencies: {self.selected_currencies}")
            print(f"ðŸ” Selected impacts: {self.selected_impacts}")
            
            # Use the globally imported functions instead of importing again
            try:
                # Get news data using the already imported function
                news_data = get_today_news(self.selected_currencies, self.selected_impacts)
                
                if news_data and len(news_data) > 0:
                    print(f"âœ… NewsWorker: Got {len(news_data)} events")
                    
                    # Save news to JSON file
                    try:
                        save_recent_news_to_json(news_data)
                        print(f"ðŸ’¾ Saved {len(news_data)} events to news output")
                    except Exception as save_e:
                        print(f"âŒ Error saving news: {save_e}")
                    
                    # Emit the data
                    self.finished.emit(news_data)
                    self.news_ready.emit(news_data)  # Also emit for auto system
                else:
                    print("âš ï¸ No news data received")
                    self.finished.emit([])
                    self.news_ready.emit([])
                    
            except Exception as e:
                print(f"âŒ Error fetching news: {e}")
                self.error.emit(f"News fetch error: {e}")
                self.error_occurred.emit(f"News fetch error: {e}")
                self.finished.emit([])
                
        except Exception as e:
            print(f"âŒ Error in NewsWorker.run: {e}")
            self.error.emit(f"NewsWorker error: {e}")
            self.error_occurred.emit(f"NewsWorker error: {e}")
            self.finished.emit([])
    
    def stop(self):
        """Stop the news worker"""
        self.quit()
        self.wait()

class NewsAutoTradingManager:
    def __init__(self, filter_currencies, filter_impact, symbol, timeframe):
        self.filter_currencies = filter_currencies
        self.filter_impact = filter_impact
        self.symbol = symbol
        self.timeframe = timeframe
        self.running = False
        self.thread = None

    def start(self):
        if self.thread and self.thread.is_alive():
            return
        self.running = True
        self.thread = threading.Thread(target=self.run, daemon=True)
        self.thread.start()

    def stop(self):
        self.running = False

    def run(self):
        # 1. Láº¥y danh sÃ¡ch giá» ra tin trong ngÃ y (Vietnam timezone)
        news_list = get_today_news(self.filter_currencies, self.filter_impact)
        today = datetime.now().strftime("%Y-%m-%d")
        event_times = []
        for news in news_list:
            t = news.get("time", "")
            if t:
                try:
                    # Handle 24-hour format (HH:MM) used by Vietnam timezone
                    if ":" in t and len(t.split(":")) == 2:
                        dt = datetime.strptime(f"{today} {t}", "%Y-%m-%d %H:%M")
                        event_times.append(dt)
                    else:
                        # Fallback to 12-hour format if needed
                        dt = datetime.strptime(f"{today} {t}", "%Y-%m-%d %I:%M%p")
                        event_times.append(dt)
                except Exception as e:
                    print(f"Error parsing time '{t}': {e}")
                    continue
        event_times = sorted(set(event_times))
        
        print(f"Found {len(event_times)} news events today (Vietnam timezone)")
        
        for event_dt in event_times:
            if not self.running:
                break
            # Äá»£i Ä‘áº¿n khi cÃ²n 5 phÃºt trÆ°á»›c giá» ra tin
            while self.running:
                now = datetime.now()
                seconds_to_event = (event_dt - now).total_seconds()
                if seconds_to_event <= 300:
                    break
                time.sleep(10)
            # QuÃ©t má»—i phÃºt cho Ä‘áº¿n khi láº¥y Ä‘Æ°á»£c actual
            got_actual = False
            while self.running and not got_actual:
                news_list = get_today_news(self.filter_currencies, self.filter_impact)
                for news in news_list:
                    t = news.get("time", "")
                    try:
                        # Handle 24-hour format (HH:MM) used by Vietnam timezone
                        if ":" in t and len(t.split(":")) == 2:
                            dt = datetime.strptime(f"{today} {t}", "%Y-%m-%d %H:%M")
                        else:
                            # Fallback to 12-hour format if needed
                            dt = datetime.strptime(f"{today} {t}", "%Y-%m-%d %I:%M%p")
                    except Exception as e:
                        print(f"Error parsing time '{t}': {e}")
                        continue
                    if abs((dt - event_dt).total_seconds()) < 60:
                        actual = news.get("description", "")
                        if actual and "Dá»± bÃ¡o" not in actual and actual.strip() not in ["", "-", "â€“"]:
                            got_actual = True
                            print(f"Fetched news announced at {t} (Vietnam time): {news.get('title', news.get('event', 'Unknown event'))}")
                            # === TÃ­ch há»£p cÃ¡c module khi cÃ³ actual ===
                            # 1. Láº¥y náº¿n má»›i, tÃ­nh indicator                            update_data_with_new_candle(self.symbol, self.timeframe, ...)  # truyá»n Ä‘Ãºng tf_code
                            # 2. PhÃ¡t hiá»‡n mÃ´ hÃ¬nh náº¿n
                            analyze_patterns(self.symbol, self.timeframe)
                            # 3. PhÃ¡t hiá»‡n mÃ´ hÃ¬nh giÃ¡
                            analyze_price_patterns()  # hoáº·c truyá»n symbol/timeframe náº¿u cáº§n
                            # 4. PhÃ¢n tÃ­ch AI
                            analyze_symbol(self.symbol, self.timeframe)
                            # 5. Quáº£n lÃ½ rá»§i ro & gá»­i lá»‡nh náº¿u Ä‘á»§ Ä‘iá»u kiá»‡n
                            # (giáº£ sá»­ báº¡n Ä‘Ã£ cÃ³ RiskManagementSystem vÃ  OrderHandler)
                            # risk = RiskManagementSystem(...)
                            # if risk.validate_trade(...):
                            #     order = OrderHandler(...)
                            #     order.send_order(...)
                            break
                if not got_actual:
                    time.sleep(60)  # Äá»£i 1 phÃºt rá»“i quÃ©t láº¡i
        print("Auto trading completed or stopped (Vietnam timezone).")

class RiskManagementTab(QWidget):
    """Risk Management Tab with comprehensive trading controls"""
    
    def __init__(self, market_tab=None):
        super().__init__()
        self.market_tab = market_tab  # Reference to market tab for symbol synchronization
        self.risk_manager = None
        self.settings = {}
        self.available_symbols = []
        
        # ðŸš« PREVENT AUTO-SAVE during initialization
        self._is_initializing = True
        
        self.init_ui()
        print("ðŸ” DEBUG calling load_risk_settings()")
        self.load_risk_settings()  # Load settings after UI is created - this calls _apply_risk_settings_to_gui() internally
        print("ðŸ” DEBUG finished load_risk_settings()")
        
        # ðŸš« ALLOW AUTO-SAVE after initialization complete
        self._is_initializing = False
        
        self.init_risk_manager()
        # NEW: Ensure symbol synchronization wiring occurs (previous logic was unreachable after return)
        self.setup_market_symbol_sync()

    # === Localization Refresh Helpers ===
    def refresh_translations(self):
        """Refresh visible texts for Risk Management sub-tabs and group boxes after a language change."""
        try:
            # Update main header
            if hasattr(self, 'header_label'):
                self.header_label.setText(I18N.t("ðŸ›¡ï¸ RISK MANAGEMENT CENTER", "ðŸ›¡ï¸ TRUNG TÃ‚M QUáº¢N LÃ Rá»¦I RO"))
            
            # Update sub tab widget titles
            if hasattr(self, 'risk_tabs'):
                self.risk_tabs.setTabText(0, I18N.t("âš™ï¸ Basic Settings", "âš™ï¸ CÃ i Ä‘áº·t cÆ¡ báº£n"))
                self.risk_tabs.setTabText(1, I18N.t("ðŸ“Š Position Management", "ðŸ“Š Quáº£n lÃ½ vá»‹ tháº¿"))
                self.risk_tabs.setTabText(2, I18N.t("ðŸ”§ Advanced Controls", "ðŸ”§ Äiá»u khiá»ƒn nÃ¢ng cao"))
                self.risk_tabs.setTabText(3, I18N.t("ðŸ“ˆ DCA Strategy", "ðŸ“ˆ Chiáº¿n lÆ°á»£c DCA"))
            
            # Update groupboxes by stored reference
            if hasattr(self, 'risk_limits_group'):
                self.risk_limits_group.setTitle(I18N.t("ðŸŽ¯ Risk Limits", "ðŸŽ¯ Giá»›i háº¡n rá»§i ro"))
            if hasattr(self, 'position_sizing_group'):
                self.position_sizing_group.setTitle(I18N.t("ðŸ“ Position Sizing", "ðŸ“ KÃ­ch thÆ°á»›c vá»‹ tháº¿"))
            if hasattr(self, 'sltp_group'):
                self.sltp_group.setTitle(I18N.t("ðŸŽ¯ Stop Loss / Take Profit", "ðŸŽ¯ Cáº¯t lá»— / Chá»‘t lá»i"))
            if hasattr(self, 'trailing_group'):
                self.trailing_group.setTitle(I18N.t("ðŸŽ¯ Breakeven & Trailing Stop", "ðŸŽ¯ Äiá»ƒm HÃ²a Vá»‘n - Dá»«ng Lá»— KÃ©o Theo"))
            if hasattr(self, 'position_limits_group'):
                self.position_limits_group.setTitle(I18N.t("ðŸ“Š Position Limits", "ðŸ“Š Giá»›i háº¡n vá»‹ tháº¿"))
            if hasattr(self, 'exposure_group'):
                self.exposure_group.setTitle(I18N.t("ðŸ’¼ Symbol Exposure Limits", "ðŸ’¼ Giá»›i háº¡n má»©c Ä‘á»™ theo mÃ£"))
            if hasattr(self, 'hours_group'):
                self.hours_group.setTitle(I18N.t("ðŸ• Trading Hours (UTC)", "ðŸ• Giá» giao dá»‹ch (UTC)"))
            if hasattr(self, 'market_conditions_group'):
                self.market_conditions_group.setTitle(I18N.t("ðŸ“Š Market Conditions", "ðŸ“Š Äiá»u kiá»‡n thá»‹ trÆ°á»ng"))
            if hasattr(self, 'emergency_group'):
                self.emergency_group.setTitle(I18N.t("ðŸš¨ Emergency Controls", "ðŸš¨ Äiá»u khiá»ƒn kháº©n cáº¥p"))
            if hasattr(self, 'news_group'):
                self.news_group.setTitle(I18N.t("ðŸ“° News & Event Avoidance", "ðŸ“° TrÃ¡nh tin tá»©c & sá»± kiá»‡n"))
            if hasattr(self, 'advanced_options_group'):
                self.advanced_options_group.setTitle(I18N.t("âš™ï¸ Advanced Options", "âš™ï¸ TÃ¹y chá»n nÃ¢ng cao"))
            if hasattr(self, 'dca_group'):
                self.dca_group.setTitle(I18N.t("ðŸ“ˆ DCA Strategy Settings", "ðŸ“ˆ CÃ i Ä‘áº·t chiáº¿n lÆ°á»£c DCA"))
            if hasattr(self, 'conditions_group'):
                self.conditions_group.setTitle(I18N.t("âš™ï¸ DCA Activation Conditions", "âš™ï¸ Äiá»u kiá»‡n kÃ­ch hoáº¡t DCA"))
            if hasattr(self, 'fib_group'):
                self.fib_group.setTitle(I18N.t("ðŸŽ¯ Fibonacci Levels", "ðŸŽ¯ CÃ¡c má»©c Fibonacci"))
            if hasattr(self, 'dca_status_group'):
                self.dca_status_group.setTitle(I18N.t("ðŸ“Š DCA Status", "ðŸ“Š Tráº¡ng thÃ¡i DCA"))
                
            # Update exposure table headers
            if hasattr(self, 'exposure_table'):
                self.exposure_table.setHorizontalHeaderLabels([
                    I18N.t("Symbol", "MÃ£"),
                    I18N.t("Max Exposure (lots)", "Khá»‘i lÆ°á»£ng tá»‘i Ä‘a (lot)"),
                    I18N.t("Risk Multiplier", "Há»‡ sá»‘ rá»§i ro")
                ])
            
            # Update exposure info label
            if hasattr(self, 'exposure_info_label'):
                if self.available_symbols:
                    self.exposure_info_label.setText(I18N.t(
                        f"âœ… Synced {len(self.available_symbols)} symbols from Market Tab",
                        f"âœ… ÄÃ£ Ä‘á»“ng bá»™ {len(self.available_symbols)} mÃ£ tá»« tab Thá»‹ trÆ°á»ng"
                    ))
                else:
                    self.exposure_info_label.setText(I18N.t(
                        "ðŸ“Š Symbols will sync automatically from Market Tab selections",
                        "ðŸ“Š CÃ¡c mÃ£ sáº½ tá»± Ä‘á»“ng bá»™ theo lá»±a chá»n á»Ÿ tab Thá»‹ trÆ°á»ng"
                    ))
            
            # === Update Labels in Basic Settings Tab ===
            if hasattr(self, 'max_risk_label'):
                self.max_risk_label.setText(I18N.t("Max Risk per Trade (%):", "Rá»§i ro tá»‘i Ä‘a má»—i lá»‡nh (%):"))
            if hasattr(self, 'fixed_volume_label'):
                self.fixed_volume_label.setText(I18N.t("Fixed Volume (lots):", "Khá»‘i lÆ°á»£ng cá»‘ Ä‘á»‹nh (lots):"))
            if hasattr(self, 'default_volume_label'):
                self.default_volume_label.setText(I18N.t("Default Volume (lots):", "Khá»‘i lÆ°á»£ng máº·c Ä‘á»‹nh (lots):"))
            if hasattr(self, 'sl_label'):
                self.sl_label.setText(I18N.t("Default SL (pips):", "SL máº·c Ä‘á»‹nh (pips):"))
            if hasattr(self, 'tp_label'):
                self.tp_label.setText(I18N.t("Default TP (pips):", "TP máº·c Ä‘á»‹nh (pips):"))
            
            # Update checkboxes
            if hasattr(self, 'trailing_volatility_cb'):
                self.trailing_volatility_cb.setText(I18N.t("Use volatility-adaptive trailing", "Sá»­ dá»¥ng trailing thÃ­ch á»©ng biáº¿n Ä‘á»™ng"))
            if hasattr(self, 'auto_reduce_check'):
                self.auto_reduce_check.setText(I18N.t("Auto Reduce Position Size on Losses", "Tá»± Ä‘á»™ng giáº£m khá»‘i lÆ°á»£ng khi thua lá»—"))
            if hasattr(self, 'enable_dca_check'):
                self.enable_dca_check.setText(I18N.t("Enable DCA Strategy", "Báº­t chiáº¿n lÆ°á»£c DCA"))
            
            # Update DCA labels
            if hasattr(self, 'dca_multiplier_label'):
                self.dca_multiplier_label.setText(I18N.t("DCA Volume Multiplier:", "Há»‡ sá»‘ khá»‘i lÆ°á»£ng DCA:"))
            if hasattr(self, 'dca_mode_label'):
                self.dca_mode_label.setText(I18N.t("DCA Mode:", "Cháº¿ Äá»™ DCA:"))
            if hasattr(self, 'dca_atr_period_label'):
                self.dca_atr_period_label.setText(I18N.t("ATR Period:", "Chu ká»³ ATR:"))
            if hasattr(self, 'dca_atr_mult_label'):
                self.dca_atr_mult_label.setText(I18N.t("ATR Multiplier:", "Há»‡ sá»‘ ATR:"))
            if hasattr(self, 'dca_base_distance_label'):
                self.dca_base_distance_label.setText(I18N.t("DCA Distance (pips):", "Khoáº£ng CÃ¡ch DCA (Pips):"))
            if hasattr(self, 'dca_fibo_levels_label'):
                self.dca_fibo_levels_label.setText(I18N.t("Start Fibonacci Retracement (%):", "Báº¯t Ä‘áº§u tá»« má»©c Fibonacci (%):"))
            if hasattr(self, 'dca_fibo_exec_label'):
                self.dca_fibo_exec_label.setText(I18N.t("Fibonacci Exec Mode:", "Cháº¿ Ä‘á»™ thá»±c thi Fibonacci:"))
            if hasattr(self, 'dca_avg_sl_profit_label'):
                self.dca_avg_sl_profit_label.setText(I18N.t("Average SL Profit % (Per Symbol):", "% Lá»£i nhuáº­n SL trung bÃ¬nh (Theo Symbol):"))
            if hasattr(self, 'max_dca_levels_label'):
                self.max_dca_levels_label.setText(I18N.t("Max DCA Levels:", "Sá»‘ táº§ng DCA tá»‘i Ä‘a:"))
            if hasattr(self, 'dca_min_drawdown_label'):
                self.dca_min_drawdown_label.setText(I18N.t("Min Drawdown for DCA (%):", "Sá»¥t giáº£m tá»‘i thiá»ƒu Ä‘á»ƒ DCA (%):"))
            if hasattr(self, 'dca_sl_mode_label'):
                self.dca_sl_mode_label.setText(I18N.t("DCA SL Mode:", "Cháº¿ Ä‘á»™ SL cho DCA:"))
            if hasattr(self, 'dca_fibo_note'):
                self.dca_fibo_note.setText(I18N.t("Fibonacci expansion sequence used for spacing & volume", "DÃ¹ng chuá»—i Fibonacci Ä‘á»ƒ giÃ£n cÃ¡ch & khá»‘i lÆ°á»£ng"))
            
            # === Update Labels in Basic Settings Tab (additional) ===
            if hasattr(self, 'max_drawdown_label'):
                self.max_drawdown_label.setText(I18N.t("Max Drawdown (%):", "Sá»¥t giáº£m tá»‘i Ä‘a (%):"))
            if hasattr(self, 'daily_loss_label'):
                self.daily_loss_label.setText(I18N.t("Daily Loss Limit (%):", "Giá»›i háº¡n lá»— ngÃ y (%):"))
            if hasattr(self, 'volume_settings_label'):
                self.volume_settings_label.setText(I18N.t("Volume Settings:", "CÃ i Ä‘áº·t khá»‘i lÆ°á»£ng:"))
            if hasattr(self, 'min_lot_label'):
                self.min_lot_label.setText(I18N.t("Min Lot Size:", "Khá»‘i lÆ°á»£ng nhá» nháº¥t (tá»± Ä‘á»™ng):"))
            if hasattr(self, 'max_lot_label'):
                self.max_lot_label.setText(I18N.t("Max Lot Size:", "Tá»•ng khá»‘i lÆ°á»£ng tá»‘i Ä‘a:"))
            if hasattr(self, 'min_rr_label'):
                self.min_rr_label.setText(I18N.t("Min R:R Ratio:", "Tá»· lá»‡ R:R tá»‘i thiá»ƒu:"))
            if hasattr(self, 'sltp_mode_label'):
                self.sltp_mode_label.setText(I18N.t("SL/TP Mode:", "Cháº¿ Ä‘á»™ SL/TP:"))
            if hasattr(self, 'breakeven_label'):
                self.breakeven_label.setText(I18N.t("Move to BE at (pips):", "Äiá»ƒm hÃ²a vá»‘n (pips):"))
            if hasattr(self, 'trailing_activation_label'):
                self.trailing_activation_label.setText(I18N.t("Trailing Stop at (pips):", "Dá»«ng Lá»— KÃ©o Theo (pips):"))
            if hasattr(self, 'trail_distance_label'):
                self.trail_distance_label.setText(I18N.t("Trail Distance (pips):", "Khoáº£ng cÃ¡ch trail (pips):"))
            
            # === Update Labels in Position Management Tab ===
            if hasattr(self, 'max_positions_label'):
                self.max_positions_label.setText(I18N.t("Max Total Positions:", "Tá»‘i Ä‘a tá»•ng vá»‹ tháº¿:"))
            if hasattr(self, 'max_positions_per_symbol_label'):
                self.max_positions_per_symbol_label.setText(I18N.t("Max Positions per Symbol:", "Tá»‘i Ä‘a vá»‹ tháº¿ má»—i mÃ£:"))
            if hasattr(self, 'max_correlation_label'):
                self.max_correlation_label.setText(I18N.t("Max Correlation:", "TÆ°Æ¡ng quan tá»‘i Ä‘a:"))
            
            # === Update Labels in Advanced Controls Tab ===
            if hasattr(self, 'start_time_label'):
                self.start_time_label.setText(I18N.t("Start Time:", "Giá» báº¯t Ä‘áº§u:"))
            if hasattr(self, 'end_time_label'):
                self.end_time_label.setText(I18N.t("End Time:", "Giá» káº¿t thÃºc:"))
            if hasattr(self, 'avoid_news_label'):
                self.avoid_news_label.setText(I18N.t("Avoid News (minutes):", "TrÃ¡nh tin tá»©c (phÃºt):"))
            if hasattr(self, 'spread_multiplier_label'):
                self.spread_multiplier_label.setText(I18N.t("Max Spread Multiplier:", "Há»‡ sá»‘ spread tá»‘i Ä‘a:"))
            if hasattr(self, 'max_slippage_label'):
                self.max_slippage_label.setText(I18N.t("Max Slippage:", "Äá»™ trÆ°á»£t giÃ¡ tá»‘i Ä‘a:"))
            if hasattr(self, 'emergency_dd_label'):
                self.emergency_dd_label.setText(I18N.t("Emergency Stop DD (%):", "Dá»«ng kháº©n cáº¥p DD (%):"))
            if hasattr(self, 'emergency_info_label'):
                self.emergency_info_label.setText(I18N.t("â„¹ï¸ Use Account Tab for position management and closing orders", "â„¹ï¸ DÃ¹ng tab TÃ i khoáº£n Ä‘á»ƒ quáº£n lÃ½ vÃ  Ä‘Ã³ng lá»‡nh"))
            
            # === Update Labels in Trailing Stop Group ===
            if hasattr(self, 'breakeven_to_label'):
                self.breakeven_to_label.setText(I18N.t("to", "Ä‘áº¿n"))
            if hasattr(self, 'trailing_to_label'):
                self.trailing_to_label.setText(I18N.t("to", "Ä‘áº¿n"))
            if hasattr(self, 'trailing_info_label'):
                self.trailing_info_label.setText(I18N.t(
                    "â„¹ï¸ Breakeven: 20-50 pips | Trailing: â‰¥70 pips | Distance adjusts with volatility",
                    "â„¹ï¸ HÃ²a vá»‘n: 20-50 pips | Trailing: â‰¥70 pips | Khoáº£ng cÃ¡ch tá»± Ä‘á»™ng theo biáº¿n Ä‘á»™ng"
                ))
            
            # Update ComboBox items for Volume Mode
            if hasattr(self, 'volume_mode_combo'):
                current_idx = self.volume_mode_combo.currentIndex()
                self.volume_mode_combo.clear()
                self.volume_mode_combo.addItems([
                    I18N.t("Risk-Based (Auto)", "Theo rá»§i ro (Tá»± Ä‘á»™ng)"),
                    I18N.t("Fixed Volume", "Khá»‘i lÆ°á»£ng cá»‘ Ä‘á»‹nh"),
                    I18N.t("Default Volume", "Khá»‘i lÆ°á»£ng máº·c Ä‘á»‹nh")
                ])
                if 0 <= current_idx < self.volume_mode_combo.count():
                    self.volume_mode_combo.setCurrentIndex(current_idx)
                self.update_volume_mode_explanation()
            
            # Update ComboBox items for SL/TP Mode  
            if hasattr(self, 'sltp_mode_combo'):
                current_idx = self.sltp_mode_combo.currentIndex()
                self.sltp_mode_combo.clear()
                self.sltp_mode_combo.addItems([
                    I18N.t("Fixed Pips", "Pips cá»‘ Ä‘á»‹nh"), 
                    I18N.t("ATR Multiple", "Bá»™i sá»‘ ATR"), 
                    I18N.t("Support/Resistance", "Há»— trá»£/KhÃ¡ng cá»±"), 
                    I18N.t("Percentage", "Pháº§n trÄƒm"),
                    I18N.t("Signal Based", "Theo Signal")
                ])
                if 0 <= current_idx < self.sltp_mode_combo.count():
                    self.sltp_mode_combo.setCurrentIndex(current_idx)
            
            # Update DCA Mode ComboBox
            if hasattr(self, 'dca_mode_combo') and hasattr(self, '_dca_mode_items'):
                current_idx = self.dca_mode_combo.currentIndex()
                self.dca_mode_combo.clear()
                self._dca_mode_items = [
                    ("atr_multiple", I18N.t("ATR Multiple", "Bá»™i sá»‘ ATR")),
                    ("fixed_pips", I18N.t("Fixed Pips", "Pips cá»‘ Ä‘á»‹nh")),
                    ("fibo_levels", I18N.t("Fibonacci Levels", "Má»©c Fibonacci")),
                ]
                for key, label in self._dca_mode_items:
                    self.dca_mode_combo.addItem(label, userData=key)
                if 0 <= current_idx < self.dca_mode_combo.count():
                    self.dca_mode_combo.setCurrentIndex(current_idx)
            
            # Update DCA SL Mode ComboBox
            if hasattr(self, 'dca_sl_mode_combo'):
                current_idx = self.dca_sl_mode_combo.currentIndex()
                self.dca_sl_mode_combo.clear()
                self.dca_sl_mode_combo.addItems([
                    I18N.t("Individual SL", "SL riÃªng láº»"), 
                    I18N.t("Average SL", "SL trung bÃ¬nh")
                ])
                if 0 <= current_idx < self.dca_sl_mode_combo.count():
                    self.dca_sl_mode_combo.setCurrentIndex(current_idx)
            
            # Update Fibo Exec Mode ComboBox
            if hasattr(self, 'dca_fibo_exec_combo'):
                current_idx = self.dca_fibo_exec_combo.currentIndex()
                self.dca_fibo_exec_combo.clear()
                self.dca_fibo_exec_combo.addItems([
                    I18N.t("On Touch (Market)", "Cháº¡m Má»©c (Market)"),
                    I18N.t("Pending Limit at Level", "Äáº·t Lá»‡nh Chá» táº¡i Má»©c")
                ])
                if 0 <= current_idx < self.dca_fibo_exec_combo.count():
                    self.dca_fibo_exec_combo.setCurrentIndex(current_idx)
                    
        except Exception as e:
            print(f"[LangSwitch] Risk tab refresh_translations error: {e}")

    # === Helpers ===
    def get_current_dca_mode_key(self):
        if hasattr(self, 'dca_mode_combo'):
            idx = self.dca_mode_combo.currentIndex()
            if idx >= 0:
                return self.dca_mode_combo.itemData(idx) or 'atr_multiple'
        return 'atr_multiple'

    def setup_market_symbol_sync(self):
        """Wire signals from MarketTab for symbol synchronization (idempotent)."""
        if not self.market_tab:
            return
        try:
            # Avoid duplicate connections by disconnecting first (safe try/except)
            try:
                self.market_tab.symbols_changed.disconnect(self.sync_symbols_with_current_market_selection)  # type: ignore
            except Exception:
                pass
            self.market_tab.symbols_changed.connect(self.sync_symbols_with_current_market_selection)
            if hasattr(self.market_tab, 'account_tab') and hasattr(self.market_tab.account_tab, 'connection_changed'):
                try:
                    self.market_tab.account_tab.connection_changed.disconnect(self.sync_symbols_from_market)  # type: ignore
                except Exception:
                    pass
                self.market_tab.account_tab.connection_changed.connect(self.sync_symbols_from_market)
            # Initial sync (both when symbols already chosen and when empty)
            self.sync_symbols_with_current_market_selection()
            print("âœ… Risk tab symbol sync initialized")
        except Exception as e:
            print(f"âš ï¸ Symbol sync setup error: {e}")
    
    def get_combo_value(self, combo, default_value):
        """Helper function to get numeric value from combo (with OFF support)"""
        try:
            if combo is None:
                return default_value
            text = combo.currentText()
            if not text:  # Empty text
                return default_value
            if text.upper() == "OFF" or text == "Táº®T":
                return "OFF"  # Return string "OFF" instead of 0
            return float(text)
        except (ValueError, AttributeError, TypeError):
            return default_value
    
    def set_combo_value(self, combo, value):
        """Helper function to set combo value (with OFF support)"""
        try:
            if str(value).upper() == "OFF":
                # Find OFF option in combo
                for i in range(combo.count()):
                    text = combo.itemText(i)
                    if text.upper() == "OFF" or text == "Táº®T":
                        combo.setCurrentIndex(i)
                        return
                # If no OFF option found, set to first item
                combo.setCurrentIndex(0)
            else:
                # Find matching numeric value
                for i in range(combo.count()):
                    text = combo.itemText(i)
                    try:
                        if text.upper() != "OFF" and text != "Táº®T" and float(text) == float(value):
                            combo.setCurrentIndex(i)
                            return
                    except ValueError:
                        continue
                # If not found, set to first item
                combo.setCurrentIndex(0)
        except AttributeError:
            pass
        
    def sync_symbols_with_current_market_selection(self):
        """Sync with current market tab selection without waiting for connection change"""
        try:
            if self.market_tab and hasattr(self.market_tab, 'checked_symbols'):
                self.available_symbols = list(self.market_tab.checked_symbols)
                
                if self.available_symbols:
                    # Update symbol exposure settings
                    for symbol in self.available_symbols:
                        if symbol not in self.settings.get('symbol_exposure', {}):
                            self.settings.setdefault('symbol_exposure', {})[symbol] = 2.0
                        if symbol not in self.settings.get('symbol_multipliers', {}):
                            self.settings.setdefault('symbol_multipliers', {})[symbol] = 1.0
                    
                    # Update the exposure table
                    self.populate_exposure_table()
                    
                    # Update info label
                    if hasattr(self, 'exposure_info_label'):
                        self.exposure_info_label.setText(f"âœ… Synced {len(self.available_symbols)} symbols from Market Tab")
                    
                    print(f"ðŸ”„ Initial sync: {len(self.available_symbols)} symbols from Market Tab")
                    
        except Exception as e:
            print(f"âŒ Error in initial symbol sync: {e}")
        
    def load_risk_settings(self):
        """ðŸ†• Load risk settings from file - Simple and reliable"""
        try:
            settings_file = "risk_management/risk_settings.json"
            if os.path.exists(settings_file):
                with open(settings_file, 'r', encoding='utf-8') as f:
                    self.settings = json.load(f)
                print(f"âœ… Loaded {len(self.settings)} settings from file")
            else:
                self.settings = self._get_default_risk_settings()
                print("âœ… Using default settings - file not found")
                
            # Apply settings to GUI
            self._apply_risk_settings_to_gui()
            return True
            
        except Exception as e:
            print(f"âŒ Error loading risk settings: {e}")
            self.settings = self._get_default_risk_settings()
            self._apply_risk_settings_to_gui()
            return False
    
    def _get_default_risk_settings(self):
        """ðŸ†• Get clean default settings"""
        return {
            'volume_mode': 'Khá»‘i lÆ°á»£ng máº·c Ä‘á»‹nh',
            'default_volume_lots': 0.15,
            'sltp_mode': 'Bá»™i sá»‘ ATR',
            'default_sl_atr_multiplier': 2.0,
            'default_tp_atr_multiplier': 1.5,
            'breakeven_min_pips': 20.0,
            'breakeven_max_pips': 50.0,
            'trailing_activation_pips': 70.0,
            'trailing_min_pips': 20.0,
            'trailing_max_pips': 50.0,
            'trailing_use_volatility': True,
            'max_positions': 40,
            'max_positions_per_symbol': 4,
            'max_correlation': 0.8,
            'trading_hours_start': 0,
            'trading_minutes_start': 0,
            'trading_hours_end': 23,
            'trading_minutes_end': 59,
            'max_spread_multiplier': 3.0,
            'max_slippage': 5,
            'auto_reduce_on_losses': False,
            'enable_dca': False,
            'saved_timestamp': datetime.now().isoformat(),
            'version': '3.0'
        }
        
    def init_ui(self):
        """Initialize the user interface"""
        main_layout = QVBoxLayout()
        
        # === HEADER SECTION ===
        self.header_label = QLabel(I18N.t("ðŸ›¡ï¸ RISK MANAGEMENT CENTER", "ðŸ›¡ï¸ TRUNG TÃ‚M QUáº¢N LÃ Rá»¦I RO"))
        self.header_label.setStyleSheet("font-size: 16px; font-weight: bold; color: #2E86C1; padding: 10px;")
        self.header_label.setAlignment(Qt.AlignCenter)
        main_layout.addWidget(self.header_label)
        
        # === TABS FOR DIFFERENT SECTIONS ===
        self.risk_tabs = QTabWidget()
        
        # Tab 1: Basic Risk Settings
        basic_tab = self.create_basic_settings_tab()
        self.risk_tabs.addTab(basic_tab, I18N.t("âš™ï¸ Basic Settings", "âš™ï¸ CÃ i Ä‘áº·t cÆ¡ báº£n"))
        
        # Tab 2: Position Management
        position_tab = self.create_position_management_tab()
        self.risk_tabs.addTab(position_tab, I18N.t("ðŸ“Š Position Management", "ðŸ“Š Quáº£n lÃ½ vá»‹ tháº¿"))
        
        # Tab 3: Advanced Controls
        advanced_tab = self.create_advanced_controls_tab()
        self.risk_tabs.addTab(advanced_tab, I18N.t("ðŸ”§ Advanced Controls", "ðŸ”§ Äiá»u khiá»ƒn nÃ¢ng cao"))
        
        # Tab 4: DCA Settings
        dca_tab = self.create_dca_settings_tab()
        self.risk_tabs.addTab(dca_tab, I18N.t("ðŸ“ˆ DCA Strategy", "ðŸ“ˆ Chiáº¿n lÆ°á»£c DCA"))
        
        main_layout.addWidget(self.risk_tabs)
        
        # === BOTTOM CONTROL PANEL ===
        control_panel = self.create_control_panel()
        main_layout.addWidget(control_panel)
        
        self.setLayout(main_layout)
        
    def create_basic_settings_tab(self):
        """Create basic risk settings tab"""
        tab = QWidget()
        layout = QVBoxLayout()
        
        # === RISK LIMITS GROUP ===
        self.risk_limits_group = QGroupBox(I18N.t("ðŸŽ¯ Risk Limits", "ðŸŽ¯ Giá»›i háº¡n rá»§i ro"))
        risk_layout = QGridLayout()
        
        # Max Risk per Trade with OFF option
        self.max_risk_label = QLabel(I18N.t("Max Risk per Trade (%):", "Rá»§i ro tá»‘i Ä‘a má»—i lá»‡nh (%):"))
        risk_layout.addWidget(self.max_risk_label, 0, 0)
        self.max_risk_combo = QComboBox()
        self.max_risk_combo.setEditable(True)
        risk_options = ["OFF", "0.5", "1.0", "1.5", "2.0", "2.5", "3.0", "5.0", "10.0"]
        self.max_risk_combo.addItems(risk_options)
        # Set current value based on settings
        current_max_risk = self.settings.get('max_risk_percent', 2.0)
        if isinstance(current_max_risk, str) and current_max_risk.upper() == "OFF":
            self.max_risk_combo.setCurrentText("OFF")
        else:
            self.max_risk_combo.setCurrentText(str(current_max_risk))
        self.max_risk_combo.setToolTip(I18N.t("Maximum percentage of account balance to risk per trade (use OFF to disable)", "Tá»· lá»‡ pháº§n trÄƒm tá»‘i Ä‘a cá»§a sá»‘ dÆ° tÃ i khoáº£n Ä‘á»ƒ cháº¥p nháº­n rá»§i ro má»—i lá»‡nh (dÃ¹ng OFF Ä‘á»ƒ táº¯t)"))
        risk_layout.addWidget(self.max_risk_combo, 0, 1)
        
        # Max Drawdown with OFF option
        self.max_drawdown_label = QLabel(I18N.t("Max Drawdown (%):", "Sá»¥t giáº£m tá»‘i Ä‘a (%):"))
        risk_layout.addWidget(self.max_drawdown_label, 1, 0)
        self.max_drawdown_combo = QComboBox()
        self.max_drawdown_combo.setEditable(True)
        dd_options = ["OFF", "1.0", "2.0", "3.0", "5.0", "8.0", "10.0", "15.0", "20.0"]
        self.max_drawdown_combo.addItems(dd_options)
        # Set current value based on settings
        if self.settings.get('disable_max_dd_close', False):
            self.max_drawdown_combo.setCurrentText("OFF")
        else:
            current_dd = self.settings.get('max_drawdown_percent', 5.0)
            self.max_drawdown_combo.setCurrentText(str(current_dd))
        self.max_drawdown_combo.setToolTip(I18N.t("Maximum allowable drawdown before emergency stop (use OFF to disable)", "Má»©c sá»¥t giáº£m tá»‘i Ä‘a cho phÃ©p trÆ°á»›c khi dá»«ng kháº©n cáº¥p (dÃ¹ng OFF Ä‘á»ƒ táº¯t)"))
        risk_layout.addWidget(self.max_drawdown_combo, 1, 1)
        
        # Daily Loss Limit with OFF option
        self.daily_loss_label = QLabel(I18N.t("Daily Loss Limit (%):", "Giá»›i háº¡n lá»— ngÃ y (%):"))
        risk_layout.addWidget(self.daily_loss_label, 2, 0)
        self.daily_loss_combo = QComboBox()
        self.daily_loss_combo.setEditable(True)
        daily_loss_options = ["OFF", "1.0", "2.0", "3.0", "5.0", "7.0", "10.0", "15.0", "20.0"]
        self.daily_loss_combo.addItems(daily_loss_options)
        # Set current value based on settings
        current_daily_loss = self.settings.get('max_daily_loss_percent', 3.0)
        if isinstance(current_daily_loss, str) and current_daily_loss.upper() == "OFF":
            self.daily_loss_combo.setCurrentText("OFF")
        else:
            self.daily_loss_combo.setCurrentText(str(current_daily_loss))
        self.daily_loss_combo.setToolTip(I18N.t("Maximum daily loss before stopping trading (use OFF to disable)", "Lá»— tá»‘i Ä‘a hÃ ng ngÃ y trÆ°á»›c khi dá»«ng giao dá»‹ch (dÃ¹ng OFF Ä‘á»ƒ táº¯t)"))
        risk_layout.addWidget(self.daily_loss_combo, 2, 1)
        
        self.risk_limits_group.setLayout(risk_layout)
        layout.addWidget(self.risk_limits_group)
        
        # === POSITION SIZE GROUP ===
        self.position_sizing_group = QGroupBox(I18N.t("ðŸ“ Position Sizing", "ðŸ“ KÃ­ch thÆ°á»›c vá»‹ tháº¿"))
        position_layout = QGridLayout()
        
        # Volume mode selection
        self.volume_settings_label = QLabel(I18N.t("Volume Settings:", "CÃ i Ä‘áº·t khá»‘i lÆ°á»£ng:"))
        position_layout.addWidget(self.volume_settings_label, 0, 0)
        self.volume_mode_combo = QComboBox()
        self.volume_mode_combo.addItems([
            I18N.t("Risk-Based (Auto)", "Theo rá»§i ro (Tá»± Ä‘á»™ng)"),
            I18N.t("Fixed Volume", "Khá»‘i lÆ°á»£ng cá»‘ Ä‘á»‹nh"),
            I18N.t("Default Volume", "Khá»‘i lÆ°á»£ng máº·c Ä‘á»‹nh")
        ])
        self.volume_mode_combo.setCurrentText(self.settings.get('volume_mode', I18N.t('Risk-Based (Auto)', 'Theo rá»§i ro (Tá»± Ä‘á»™ng)')))
        self.volume_mode_combo.currentTextChanged.connect(self.on_volume_mode_changed)
        self.volume_mode_combo.currentTextChanged.connect(self.auto_save_risk_settings)
        position_layout.addWidget(self.volume_mode_combo, 0, 1, 1, 3)
        
        # Lot Size Settings - Dynamic based on mode
        self.min_lot_label = QLabel(I18N.t("Min Lot Size:", "Khá»‘i lÆ°á»£ng nhá» nháº¥t (tá»± Ä‘á»™ng):"))
        position_layout.addWidget(self.min_lot_label, 1, 0)
        self.min_lot_spin = QDoubleSpinBox()
        self.min_lot_spin.setRange(0.0, 10.0)
        self.min_lot_spin.setSingleStep(0.01)
        self.min_lot_spin.setValue(self.settings.get('min_volume_auto', 0.01))
        self.min_lot_spin.setToolTip(I18N.t("Minimum lot size for auto mode only", "Khá»‘i lÆ°á»£ng tá»‘i thiá»ƒu chá»‰ cho cháº¿ Ä‘á»™ tá»± Ä‘á»™ng"))
        position_layout.addWidget(self.min_lot_spin, 1, 1)
        
        self.max_lot_label = QLabel(I18N.t("Max Lot Size:", "Tá»•ng khá»‘i lÆ°á»£ng tá»‘i Ä‘a:"))
        position_layout.addWidget(self.max_lot_label, 1, 2)
        self.max_lot_combo = QComboBox()
        self.max_lot_combo.setEditable(True)
        lot_options = ["OFF", "0.5", "1.0", "2.0", "5.0", "10.0", "20.0", "50.0", "100.0"]
        self.max_lot_combo.addItems(lot_options)
        print(f"ðŸ” DEBUG max_lot_combo items: {[self.max_lot_combo.itemText(i) for i in range(self.max_lot_combo.count())]}")
        # Set current value based on settings
        current_max_lot = self.settings.get('max_total_volume', 10.0)
        print(f"ðŸ” DEBUG current_max_lot from settings: {current_max_lot} (type: {type(current_max_lot)})")
        if isinstance(current_max_lot, str) and current_max_lot.upper() == "OFF":
            self.max_lot_combo.setCurrentText("OFF")
        else:
            self.max_lot_combo.setCurrentText(str(current_max_lot))
        self.max_lot_combo.setToolTip(I18N.t("Maximum total volume across all positions (use OFF to disable)", "Tá»•ng khá»‘i lÆ°á»£ng tá»‘i Ä‘a trÃªn táº¥t cáº£ vá»‹ tháº¿ (dÃ¹ng OFF Ä‘á»ƒ táº¯t)"))
        position_layout.addWidget(self.max_lot_combo, 1, 3)
        
        # Fixed volume setting (dynamic label based on mode)
        self.fixed_volume_label = QLabel(I18N.t("Fixed Volume (lots):", "Khá»‘i lÆ°á»£ng cá»‘ Ä‘á»‹nh (lots):"))
        position_layout.addWidget(self.fixed_volume_label, 2, 0)
        self.fixed_volume_spin = QDoubleSpinBox()
        self.fixed_volume_spin.setRange(0.0, 100.0)
        self.fixed_volume_spin.setSingleStep(0.01)
        self.fixed_volume_spin.setValue(self.settings.get('fixed_volume_lots', 0.10))
        self.fixed_volume_spin.setToolTip(I18N.t("Fixed lot size when using Fixed Volume mode", "KÃ­ch thÆ°á»›c lot cá»‘ Ä‘á»‹nh khi dÃ¹ng cháº¿ Ä‘á»™ Khá»‘i lÆ°á»£ng cá»‘ Ä‘á»‹nh"))
        position_layout.addWidget(self.fixed_volume_spin, 2, 1)
        
        # Default volume setting (same position as fixed volume - will be shown/hidden based on mode)
        self.default_volume_label = QLabel(I18N.t("Default Volume (lots):", "Khá»‘i lÆ°á»£ng máº·c Ä‘á»‹nh (lots):"))
        position_layout.addWidget(self.default_volume_label, 2, 0)  # Same position as fixed_volume_label
        self.default_volume_spin = QDoubleSpinBox()
        self.default_volume_spin.setRange(0.0, 100.0)
        self.default_volume_spin.setSingleStep(0.01)
        self.default_volume_spin.setValue(self.settings.get('default_volume_lots', 0.10))
        self.default_volume_spin.setToolTip(I18N.t("Default lot size when using Default Volume mode", "KÃ­ch thÆ°á»›c lot máº·c Ä‘á»‹nh khi dÃ¹ng cháº¿ Ä‘á»™ Khá»‘i lÆ°á»£ng máº·c Ä‘á»‹nh"))
        position_layout.addWidget(self.default_volume_spin, 2, 1)  # Same position as fixed_volume_spin
        
        # Volume mode explanation
        self.volume_mode_label = QLabel()
        self.update_volume_mode_explanation()
        self.volume_mode_label.setStyleSheet("color: #3498DB; font-style: italic; padding: 5px; background-color: #EBF5FB; border-radius: 5px;")
        position_layout.addWidget(self.volume_mode_label, 3, 0, 1, 4)
        
        # Initialize volume fields visibility based on current mode
        self.update_volume_fields_visibility()
        
        # Risk/Reward Ratio with OFF option
        self.min_rr_label = QLabel(I18N.t("Min R:R Ratio:", "Tá»· lá»‡ R:R tá»‘i thiá»ƒu:"))
        position_layout.addWidget(self.min_rr_label, 4, 0)
        self.min_rr_combo = QComboBox()
        self.min_rr_combo.setEditable(True)
        rr_options = ["OFF", "0.5", "1.0", "1.2", "1.5", "2.0", "2.5", "3.0", "5.0"]
        self.min_rr_combo.addItems(rr_options)
        print(f"ðŸ” DEBUG min_rr_combo items: {[self.min_rr_combo.itemText(i) for i in range(self.min_rr_combo.count())]}")
        # Set current value based on settings
        current_rr = self.settings.get('min_risk_reward_ratio', 1.5)
        print(f"ðŸ” DEBUG current_rr from settings: {current_rr} (type: {type(current_rr)})")
        if isinstance(current_rr, str) and current_rr.upper() == "OFF":
            self.min_rr_combo.setCurrentText("OFF")
        else:
            self.min_rr_combo.setCurrentText(str(current_rr))
        self.min_rr_combo.setToolTip(I18N.t("Minimum risk-to-reward ratio required for trades (use OFF to disable)", "Tá»· lá»‡ rá»§i ro/lá»£i nhuáº­n tá»‘i thiá»ƒu yÃªu cáº§u cho giao dá»‹ch (dÃ¹ng OFF Ä‘á»ƒ táº¯t)"))
        position_layout.addWidget(self.min_rr_combo, 4, 1)
        
        self.position_sizing_group.setLayout(position_layout)
        layout.addWidget(self.position_sizing_group)
        
        # === STOP LOSS / TAKE PROFIT GROUP ===
        self.sltp_group = QGroupBox(I18N.t("ðŸŽ¯ Stop Loss / Take Profit", "ðŸŽ¯ Cáº¯t lá»— / Chá»‘t lá»i"))
        sltp_layout = QGridLayout()
        
        # Dynamic SL/TP labels and controls (will update based on mode)
        self.sl_label = QLabel(I18N.t("Default SL (pips):", "SL máº·c Ä‘á»‹nh (pips):"))
        sltp_layout.addWidget(self.sl_label, 0, 0)
        self.default_sl_spin = QDoubleSpinBox()  # ðŸ”§ Changed to QDoubleSpinBox for decimal support
        self.default_sl_spin.setRange(0.0, 10000.0)
        self.default_sl_spin.setDecimals(1)  # Allow 1 decimal place
        self.default_sl_spin.setSingleStep(0.1)  # Step by 0.1
        self.default_sl_spin.setValue(float(self.settings.get('default_sl_pips', 50)))
        sltp_layout.addWidget(self.default_sl_spin, 0, 1)
        
        self.tp_label = QLabel(I18N.t("Default TP (pips):", "TP máº·c Ä‘á»‹nh (pips):"))
        sltp_layout.addWidget(self.tp_label, 0, 2)
        self.default_tp_spin = QDoubleSpinBox()  # ðŸ”§ Changed to QDoubleSpinBox for decimal support
        self.default_tp_spin.setRange(0.0, 50000.0)
        self.default_tp_spin.setDecimals(1)  # Allow 1 decimal place
        self.default_tp_spin.setSingleStep(0.1)  # Step by 0.1
        self.default_tp_spin.setValue(float(self.settings.get('default_tp_pips', 100)))
        sltp_layout.addWidget(self.default_tp_spin, 0, 3)
        
        # SL/TP Mode
        self.sltp_mode_label = QLabel(I18N.t("SL/TP Mode:", "Cháº¿ Ä‘á»™ SL/TP:"))
        sltp_layout.addWidget(self.sltp_mode_label, 1, 0)
        self.sltp_mode_combo = QComboBox()
        self.sltp_mode_combo.addItems([
            I18N.t("Fixed Pips", "Pips cá»‘ Ä‘á»‹nh"), 
            I18N.t("ATR Multiple", "Bá»™i sá»‘ ATR"), 
            I18N.t("Support/Resistance", "Há»— trá»£/KhÃ¡ng cá»±"), 
            I18N.t("Percentage", "Pháº§n trÄƒm"),
            I18N.t("Signal Based", "Theo Signal")
        ])
        # Load sltp_mode with proper conversion
        sltp_mode_key = self.settings.get('sltp_mode', 'Bá»™i sá»‘ ATR')
        self.sltp_mode_combo.setCurrentText(self.get_sltp_mode_display_text(sltp_mode_key))
        # Connect mode change to update labels and ranges
        self.sltp_mode_combo.currentTextChanged.connect(self.update_sltp_mode_controls)
        self.sltp_mode_combo.currentTextChanged.connect(self.auto_save_risk_settings)
        self.default_sl_spin.valueChanged.connect(self.auto_save_risk_settings)
        self.default_tp_spin.valueChanged.connect(self.auto_save_risk_settings)
        sltp_layout.addWidget(self.sltp_mode_combo, 1, 1, 1, 2)
        
        # Initialize controls based on current mode
        self.update_sltp_mode_controls()
        
        self.sltp_group.setLayout(sltp_layout)
        layout.addWidget(self.sltp_group)
        
        # === BREAKEVEN & TRAILING STOP GROUP ===
        self.trailing_group = QGroupBox(I18N.t("ðŸŽ¯ Breakeven & Trailing Stop", "ðŸŽ¯ Äiá»ƒm HÃ²a Vá»‘n - Dá»«ng Lá»— KÃ©o Theo"))
        trailing_layout = QGridLayout()
        
        # Breakeven Settings
        self.breakeven_label = QLabel(I18N.t("Move to BE at (pips):", "Äiá»ƒm hÃ²a vá»‘n (pips):"))
        trailing_layout.addWidget(self.breakeven_label, 0, 0)
        self.breakeven_min_spin = QDoubleSpinBox()
        self.breakeven_min_spin.setRange(0.0, 500.0)
        self.breakeven_min_spin.setDecimals(1)
        self.breakeven_min_spin.setSingleStep(1.0)
        self.breakeven_min_spin.setValue(float(self.settings.get('breakeven_min_pips', 20)))
        self.breakeven_min_spin.setToolTip(I18N.t("Minimum profit in pips to move S/L to breakeven (20-50 pips recommended)", "LÃ£i tá»‘i thiá»ƒu Ä‘á»ƒ dá»‹ch S/L vá» Ä‘iá»ƒm hÃ²a vá»‘n (khuyáº¿n nghá»‹ 20-50 pips)"))
        self.breakeven_min_spin.valueChanged.connect(self.auto_save_risk_settings)
        trailing_layout.addWidget(self.breakeven_min_spin, 0, 1)
        
        self.breakeven_to_label = QLabel(I18N.t("to", "Ä‘áº¿n"))
        trailing_layout.addWidget(self.breakeven_to_label, 0, 2, Qt.AlignCenter)
        
        self.breakeven_max_spin = QDoubleSpinBox()
        self.breakeven_max_spin.setRange(0.0, 500.0)
        self.breakeven_max_spin.setDecimals(1)
        self.breakeven_max_spin.setSingleStep(1.0)
        self.breakeven_max_spin.setValue(float(self.settings.get('breakeven_max_pips', 50)))
        self.breakeven_max_spin.setToolTip(I18N.t("Maximum profit range for breakeven (above this, trailing stop activates)", "Pháº¡m vi lÃ£i tá»‘i Ä‘a cho hÃ²a vá»‘n (trÃªn má»©c nÃ y sáº½ kÃ­ch hoáº¡t trailing stop)"))
        self.breakeven_max_spin.valueChanged.connect(self.auto_save_risk_settings)
        trailing_layout.addWidget(self.breakeven_max_spin, 0, 3)
        
        # Trailing Stop Settings
        self.trailing_activation_label = QLabel(I18N.t("Trailing Stop at (pips):", "Dá»«ng Lá»— KÃ©o Theo (pips):"))
        trailing_layout.addWidget(self.trailing_activation_label, 1, 0)
        self.trailing_activation_spin = QDoubleSpinBox()
        self.trailing_activation_spin.setRange(0.0, 1000.0)
        self.trailing_activation_spin.setDecimals(1)
        self.trailing_activation_spin.setSingleStep(1.0)
        self.trailing_activation_spin.setValue(float(self.settings.get('trailing_activation_pips', 70)))
        self.trailing_activation_spin.setToolTip(I18N.t("Minimum profit to activate trailing stop (â‰¥70 pips recommended)", "LÃ£i tá»‘i thiá»ƒu Ä‘á»ƒ kÃ­ch hoáº¡t trailing stop (khuyáº¿n nghá»‹ â‰¥70 pips)"))
        self.trailing_activation_spin.valueChanged.connect(self.auto_save_risk_settings)
        trailing_layout.addWidget(self.trailing_activation_spin, 1, 1)
        
        # Trailing Distance Range
        self.trail_distance_label = QLabel(I18N.t("Trail Distance (pips):", "Khoáº£ng cÃ¡ch trail (pips):"))
        trailing_layout.addWidget(self.trail_distance_label, 2, 0)
        self.trailing_min_spin = QDoubleSpinBox()
        self.trailing_min_spin.setRange(0.0, 500.0)
        self.trailing_min_spin.setDecimals(1)
        self.trailing_min_spin.setSingleStep(1.0)
        self.trailing_min_spin.setValue(float(self.settings.get('trailing_min_pips', 20)))
        self.trailing_min_spin.setToolTip(I18N.t("Minimum trailing distance (for low volatility)", "Khoáº£ng cÃ¡ch trailing tá»‘i thiá»ƒu (cho biáº¿n Ä‘á»™ng tháº¥p)"))
        self.trailing_min_spin.valueChanged.connect(self.auto_save_risk_settings)
        trailing_layout.addWidget(self.trailing_min_spin, 2, 1)
        
        self.trailing_to_label = QLabel(I18N.t("to", "Ä‘áº¿n"))
        trailing_layout.addWidget(self.trailing_to_label, 2, 2, Qt.AlignCenter)
        
        self.trailing_max_spin = QDoubleSpinBox()
        self.trailing_max_spin.setRange(0.0, 500.0)
        self.trailing_max_spin.setDecimals(1)
        self.trailing_max_spin.setSingleStep(1.0)
        self.trailing_max_spin.setValue(float(self.settings.get('trailing_max_pips', 50)))
        self.trailing_max_spin.setToolTip(I18N.t("Maximum trailing distance (for high volatility)", "Khoáº£ng cÃ¡ch trailing tá»‘i Ä‘a (cho biáº¿n Ä‘á»™ng cao)"))
        self.trailing_max_spin.valueChanged.connect(self.auto_save_risk_settings)
        trailing_layout.addWidget(self.trailing_max_spin, 2, 3)
        
        # Use Volatility Adaptive
        self.trailing_volatility_cb = QCheckBox(I18N.t("Use volatility-adaptive trailing", "Sá»­ dá»¥ng trailing thÃ­ch á»©ng biáº¿n Ä‘á»™ng"))
        self.trailing_volatility_cb.setChecked(self.settings.get('trailing_use_volatility', True))
        self.trailing_volatility_cb.setToolTip(I18N.t("Adjust trailing distance based on market volatility from trendline_sr", "Äiá»u chá»‰nh khoáº£ng cÃ¡ch trailing dá»±a trÃªn biáº¿n Ä‘á»™ng thá»‹ trÆ°á»ng tá»« trendline_sr"))
        self.trailing_volatility_cb.stateChanged.connect(self.auto_save_risk_settings)
        trailing_layout.addWidget(self.trailing_volatility_cb, 3, 0, 1, 4)
        
        # Info label
        self.trailing_info_label = QLabel(I18N.t(
            "â„¹ï¸ Breakeven: 20-50 pips | Trailing: â‰¥70 pips | Distance adjusts with volatility",
            "â„¹ï¸ HÃ²a vá»‘n: 20-50 pips | Trailing: â‰¥70 pips | Khoáº£ng cÃ¡ch tá»± Ä‘á»™ng theo biáº¿n Ä‘á»™ng"
        ))
        self.trailing_info_label.setStyleSheet("color: #3498DB; font-style: italic; padding: 5px; background-color: #EBF5FB; border-radius: 5px;")
        trailing_layout.addWidget(self.trailing_info_label, 4, 0, 1, 4)
        
        self.trailing_group.setLayout(trailing_layout)
        layout.addWidget(self.trailing_group)
        
        # ðŸ”§ CONNECT: Auto-save for Basic Settings that were missing
        self.max_risk_combo.currentTextChanged.connect(self.auto_save_risk_settings)
        self.max_drawdown_combo.currentTextChanged.connect(self.auto_save_risk_settings)
        self.daily_loss_combo.currentTextChanged.connect(self.auto_save_risk_settings)
        self.min_lot_spin.valueChanged.connect(self.auto_save_risk_settings)
        self.max_lot_combo.currentTextChanged.connect(self.auto_save_risk_settings)
        self.fixed_volume_spin.valueChanged.connect(self.auto_save_risk_settings)
        self.default_volume_spin.valueChanged.connect(self.auto_save_risk_settings)
        self.min_rr_combo.currentTextChanged.connect(self.auto_save_risk_settings)
        
        layout.addStretch()
        tab.setLayout(layout)
        return tab
        
    def create_position_management_tab(self):
        """Create position management tab"""
        tab = QWidget()
        layout = QVBoxLayout()

        # === POSITION LIMITS GROUP ===
        self.position_limits_group = QGroupBox(I18N.t("ðŸ“Š Position Limits", "ðŸ“Š Giá»›i háº¡n vá»‹ tháº¿"))
        limits_layout = QGridLayout()

        # Max Positions
        self.max_positions_label = QLabel(I18N.t("Max Total Positions:", "Tá»‘i Ä‘a tá»•ng vá»‹ tháº¿:"))
        limits_layout.addWidget(self.max_positions_label, 0, 0)
        self.max_positions_spin = QSpinBox()
        self.max_positions_spin.setRange(0, 1000)
        self.max_positions_spin.setValue(int(self.settings.get('max_positions', 5)))
        self.max_positions_spin.valueChanged.connect(self.auto_save_risk_settings)  # ðŸ”§ FIX: Auto save
        limits_layout.addWidget(self.max_positions_spin, 0, 1)

        # Max Positions per Symbol
        self.max_positions_per_symbol_label = QLabel(I18N.t("Max Positions per Symbol:", "Tá»‘i Ä‘a vá»‹ tháº¿ má»—i mÃ£:"))
        limits_layout.addWidget(self.max_positions_per_symbol_label, 0, 2)
        self.max_positions_per_symbol_spin = QSpinBox()
        self.max_positions_per_symbol_spin.setRange(0, 100)
        self.max_positions_per_symbol_spin.setValue(int(self.settings.get('max_positions_per_symbol', 2)))
        self.max_positions_per_symbol_spin.valueChanged.connect(self.auto_save_risk_settings)  # ðŸ”§ FIX: Auto save
        limits_layout.addWidget(self.max_positions_per_symbol_spin, 0, 3)

        # Max Correlation
        self.max_correlation_label = QLabel(I18N.t("Max Correlation:", "TÆ°Æ¡ng quan tá»‘i Ä‘a:"))
        limits_layout.addWidget(self.max_correlation_label, 1, 0)
        self.max_correlation_spin = QDoubleSpinBox()
        self.max_correlation_spin.setRange(0.0, 1.0)
        self.max_correlation_spin.setSingleStep(0.1)
        self.max_correlation_spin.setValue(self.settings.get('max_correlation', 0.7))
        self.max_correlation_spin.valueChanged.connect(self.auto_save_risk_settings)  # ðŸ”§ FIX: Auto save
        limits_layout.addWidget(self.max_correlation_spin, 1, 1)

        self.position_limits_group.setLayout(limits_layout)
        layout.addWidget(self.position_limits_group)

        # === SYMBOL EXPOSURE GROUP ===
        self.exposure_group = QGroupBox(I18N.t("ðŸ’¼ Symbol Exposure Limits", "ðŸ’¼ Giá»›i háº¡n má»©c Ä‘á»™ theo mÃ£"))
        exposure_layout = QVBoxLayout()

        # Info label (localized)
        self.exposure_info_label = QLabel(I18N.t(
            "ðŸ“Š Symbols will sync automatically from Market Tab selections",
            "ðŸ“Š CÃ¡c mÃ£ sáº½ tá»± Ä‘á»“ng bá»™ theo lá»±a chá»n á»Ÿ tab Thá»‹ trÆ°á»ng"
        ))
        self.exposure_info_label.setStyleSheet("color: #3498DB; font-style: italic; padding: 5px;")
        exposure_layout.addWidget(self.exposure_info_label)

        # Symbol exposure table
        self.exposure_table = QTableWidget()
        self.exposure_table.setColumnCount(3)
        self.exposure_table.setHorizontalHeaderLabels([
            I18N.t("Symbol", "MÃ£"),
            I18N.t("Max Exposure (lots)", "Khá»‘i lÆ°á»£ng tá»‘i Ä‘a (lot)"),
            I18N.t("Risk Multiplier", "Há»‡ sá»‘ rá»§i ro")
        ])
        # Widen the Exposure column to avoid clipping in Vietnamese
        self.exposure_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeToContents)
        self.exposure_table.setColumnWidth(1, 240)
        self.exposure_table.horizontalHeader().setStretchLastSection(True)

        # Initialize with empty table - will be populated when symbols are synced
        self.populate_exposure_table()

        exposure_layout.addWidget(self.exposure_table)
        self.exposure_group.setLayout(exposure_layout)
        layout.addWidget(self.exposure_group)

        # ðŸ”§ CONNECT: Auto-save for exposure table changes
        self.exposure_table.cellChanged.connect(self.on_exposure_table_changed)

        layout.addStretch()
        tab.setLayout(layout)
        return tab
        
    def create_advanced_controls_tab(self):
        """Create advanced controls tab"""
        tab = QWidget()
        layout = QVBoxLayout()
        
        # === TRADING HOURS GROUP ===
        self.hours_group = QGroupBox(I18N.t("ðŸ• Trading Hours (UTC)", "ðŸ• Giá» giao dá»‹ch (UTC)"))
        hours_layout = QGridLayout()
        
        # Start Time: Hour : Minute
        self.start_time_label = QLabel(I18N.t("Start Time:", "Giá» báº¯t Ä‘áº§u:"))
        hours_layout.addWidget(self.start_time_label, 0, 0)
        start_time_widget = QWidget()
        start_time_layout = QHBoxLayout(start_time_widget)
        start_time_layout.setContentsMargins(0, 0, 0, 0)
        start_time_layout.setSpacing(2)
        
        self.start_hour_spin = QSpinBox()
        self.start_hour_spin.setRange(0, 23)
        self.start_hour_spin.setValue(int(self.settings.get('trading_hours_start', 0)))
        self.start_hour_spin.setFixedWidth(50)
        start_time_layout.addWidget(self.start_hour_spin)
        
        start_time_layout.addWidget(QLabel(":"))
        
        self.start_minute_spin = QSpinBox()
        self.start_minute_spin.setRange(0, 59)
        self.start_minute_spin.setValue(int(self.settings.get('trading_minutes_start', 0)))
        self.start_minute_spin.setFixedWidth(50)
        start_time_layout.addWidget(self.start_minute_spin)
        start_time_layout.addStretch()
        
        hours_layout.addWidget(start_time_widget, 0, 1)
        
        # End Time: Hour : Minute
        self.end_time_label = QLabel(I18N.t("End Time:", "Giá» káº¿t thÃºc:"))
        hours_layout.addWidget(self.end_time_label, 0, 2)
        end_time_widget = QWidget()
        end_time_layout = QHBoxLayout(end_time_widget)
        end_time_layout.setContentsMargins(0, 0, 0, 0)
        end_time_layout.setSpacing(2)
        
        self.end_hour_spin = QSpinBox()
        self.end_hour_spin.setRange(0, 23)
        self.end_hour_spin.setValue(int(self.settings.get('trading_hours_end', 23)))
        self.end_hour_spin.setFixedWidth(50)
        end_time_layout.addWidget(self.end_hour_spin)
        
        end_time_layout.addWidget(QLabel(":"))
        
        self.end_minute_spin = QSpinBox()
        self.end_minute_spin.setRange(0, 59)
        self.end_minute_spin.setValue(int(self.settings.get('trading_minutes_end', 59)))
        self.end_minute_spin.setFixedWidth(50)
        end_time_layout.addWidget(self.end_minute_spin)
        end_time_layout.addStretch()
        
        hours_layout.addWidget(end_time_widget, 0, 3)
        
        # News avoidance with OFF option
        self.avoid_news_label = QLabel(I18N.t("Avoid News (minutes):", "TrÃ¡nh tin tá»©c (phÃºt):"))
        hours_layout.addWidget(self.avoid_news_label, 1, 0)
        self.avoid_news_combo = QComboBox()
        self.avoid_news_combo.setEditable(True)
        news_options = ["OFF", "5", "10", "15", "30", "45", "60", "90", "120"]
        self.avoid_news_combo.addItems(news_options)
        # Set current value based on settings
        current_avoid = self.settings.get('avoid_news_minutes', 30)
        if self.settings.get('disable_news_avoidance', False):
            self.avoid_news_combo.setCurrentText("OFF")
        else:
            self.avoid_news_combo.setCurrentText(str(current_avoid))
        hours_layout.addWidget(self.avoid_news_combo, 1, 1)
        
        self.hours_group.setLayout(hours_layout)
        layout.addWidget(self.hours_group)
        
        # === MARKET CONDITIONS GROUP ===
        self.market_conditions_group = QGroupBox(I18N.t("ðŸ“Š Market Conditions", "ðŸ“Š Äiá»u kiá»‡n thá»‹ trÆ°á»ng"))
        market_layout = QGridLayout()
        
        # Spread limits
        self.spread_multiplier_label = QLabel(I18N.t("Max Spread Multiplier:", "Há»‡ sá»‘ spread tá»‘i Ä‘a:"))
        market_layout.addWidget(self.spread_multiplier_label, 0, 0)
        self.spread_multiplier_spin = QDoubleSpinBox()
        self.spread_multiplier_spin.setRange(0.0, 100.0)
        self.spread_multiplier_spin.setSingleStep(0.5)
        self.spread_multiplier_spin.setValue(self.settings.get('max_spread_multiplier', 3.0))
        market_layout.addWidget(self.spread_multiplier_spin, 0, 1)
        
        # Slippage
        self.max_slippage_label = QLabel(I18N.t("Max Slippage:", "Äá»™ trÆ°á»£t giÃ¡ tá»‘i Ä‘a:"))
        market_layout.addWidget(self.max_slippage_label, 0, 2)
        self.max_slippage_spin = QSpinBox()
        self.max_slippage_spin.setRange(0, 1000)
        self.max_slippage_spin.setValue(self.settings.get('max_slippage', 10))
        market_layout.addWidget(self.max_slippage_spin, 0, 3)
        
        self.market_conditions_group.setLayout(market_layout)
        layout.addWidget(self.market_conditions_group)
        
        # === EMERGENCY CONTROLS GROUP ===
        self.emergency_group = QGroupBox(I18N.t("ðŸš¨ Emergency Controls", "ðŸš¨ Äiá»u khiá»ƒn kháº©n cáº¥p"))
        emergency_layout = QGridLayout()
        
        # Emergency stop drawdown with OFF option
        self.emergency_dd_label = QLabel(I18N.t("Emergency Stop DD (%):", "Dá»«ng kháº©n cáº¥p DD (%):"))
        emergency_layout.addWidget(self.emergency_dd_label, 0, 0)
        self.emergency_dd_combo = QComboBox()
        self.emergency_dd_combo.setEditable(True)
        emergency_options = ["OFF", "5.0", "8.0", "10.0", "15.0", "20.0", "25.0", "30.0"]
        self.emergency_dd_combo.addItems(emergency_options)
        # Set current value based on settings
        if self.settings.get('disable_emergency_stop', False):
            self.emergency_dd_combo.setCurrentText("OFF")
        else:
            current_emergency = self.settings.get('emergency_stop_drawdown', 10.0)
            self.emergency_dd_combo.setCurrentText(str(current_emergency))
        emergency_layout.addWidget(self.emergency_dd_combo, 0, 1)
        
        # Emergency mode selector (simplified to AUTO/ENABLED)
        # Auto reduce on losses
        self.auto_reduce_check = QCheckBox(I18N.t("Auto Reduce Position Size on Losses", "Tá»± Ä‘á»™ng giáº£m khá»‘i lÆ°á»£ng khi thua lá»—"))
        self.auto_reduce_check.setChecked(self.settings.get('auto_reduce_on_losses', True))
        emergency_layout.addWidget(self.auto_reduce_check, 1, 0, 1, 4)
        
        # Note about position management
        self.emergency_info_label = QLabel(I18N.t("â„¹ï¸ Use Account Tab for position management and closing orders", "â„¹ï¸ DÃ¹ng tab TÃ i khoáº£n Ä‘á»ƒ quáº£n lÃ½ vÃ  Ä‘Ã³ng lá»‡nh"))
        self.emergency_info_label.setStyleSheet("color: #3498DB; font-style: italic; padding: 10px; background-color: #EBF5FB; border-radius: 5px;")
        emergency_layout.addWidget(self.emergency_info_label, 2, 0, 1, 4)
        
        self.emergency_group.setLayout(emergency_layout)
        layout.addWidget(self.emergency_group)
        
        # ðŸ”§ CONNECT: Auto-save for Advanced Controls
        self.start_hour_spin.valueChanged.connect(self.auto_save_risk_settings)
        self.start_minute_spin.valueChanged.connect(self.auto_save_risk_settings)
        self.end_hour_spin.valueChanged.connect(self.auto_save_risk_settings)
        self.end_minute_spin.valueChanged.connect(self.auto_save_risk_settings)
        self.avoid_news_combo.currentTextChanged.connect(self.auto_save_risk_settings)
        self.spread_multiplier_spin.valueChanged.connect(self.auto_save_risk_settings)
        self.max_slippage_spin.valueChanged.connect(self.auto_save_risk_settings)
        self.emergency_dd_combo.currentTextChanged.connect(self.auto_save_risk_settings)
        self.auto_reduce_check.stateChanged.connect(self.auto_save_risk_settings)
        
        layout.addStretch()
        tab.setLayout(layout)
        return tab
        
    def create_dca_settings_tab(self):
        """Create DCA (Dollar Cost Averaging) settings tab"""
        tab = QWidget()
        layout = QVBoxLayout()
        
        # === DCA STRATEGY GROUP ===
        self.dca_group = QGroupBox(I18N.t("ðŸ“ˆ DCA Strategy Settings", "ðŸ“ˆ CÃ i Ä‘áº·t chiáº¿n lÆ°á»£c DCA"))
        dca_layout = QGridLayout()
        
        # Enable DCA
        self.enable_dca_check = QCheckBox(I18N.t("Enable DCA Strategy", "Báº­t chiáº¿n lÆ°á»£c DCA"))
        self.enable_dca_check.setChecked(self.settings.get('enable_dca', False))
        dca_layout.addWidget(self.enable_dca_check, 0, 0, 1, 2)
        
        # Max DCA levels
        self.max_dca_levels_label = QLabel(I18N.t("Max DCA Levels:", "Sá»‘ táº§ng DCA tá»‘i Ä‘a:"))
        dca_layout.addWidget(self.max_dca_levels_label, 1, 0)
        self.max_dca_levels_spin = QSpinBox()
        self.max_dca_levels_spin.setRange(1, 50)
        self.max_dca_levels_spin.setValue(self.settings.get('max_dca_levels', 3))
        self.max_dca_levels_spin.setToolTip(I18N.t("Maximum DCA levels allowed", "Sá»‘ táº§ng DCA tá»‘i Ä‘a cho phÃ©p"))
        dca_layout.addWidget(self.max_dca_levels_spin, 1, 1)
        

        
        # (Removed Fibonacci controls per user request)
        
        # DCA multiplier - moved up to position 3
        self.dca_multiplier_label = QLabel(I18N.t("DCA Volume Multiplier:", "Há»‡ sá»‘ khá»‘i lÆ°á»£ng DCA:"))
        dca_layout.addWidget(self.dca_multiplier_label, 3, 0)
        self.dca_multiplier_spin = QDoubleSpinBox()
        self.dca_multiplier_spin.setRange(0.0, 100.0)
        self.dca_multiplier_spin.setSingleStep(0.1)
        self.dca_multiplier_spin.setValue(self.settings.get('dca_volume_multiplier', 1.5))
        self.dca_multiplier_spin.setToolTip(I18N.t("Volume multiplier for each DCA level", "Há»‡ sá»‘ nhÃ¢n khá»‘i lÆ°á»£ng cho má»—i táº§ng DCA"))
        dca_layout.addWidget(self.dca_multiplier_spin, 3, 1)
        
        # DCA Mode (reintroduced per user request) - row 4
        self.dca_mode_label = QLabel(I18N.t("DCA Mode:", "Cháº¿ Äá»™ DCA:"))
        dca_layout.addWidget(self.dca_mode_label, 4, 0)
        self.dca_mode_combo = QComboBox()
        # Canonical internal keys mapped to localized display strings
        # New standardized modes: ATR multiple, Fixed Pips, Fibonacci Levels
        self._dca_mode_items = [
            ("atr_multiple", I18N.t("ATR Multiple", "Bá»™i sá»‘ ATR")),
            ("fixed_pips", I18N.t("Fixed Pips", "Pips cá»‘ Ä‘á»‹nh")),
            ("fibo_levels", I18N.t("Fibonacci Levels", "Má»©c Fibonacci")),
        ]
        for key, label in self._dca_mode_items:
            self.dca_mode_combo.addItem(label, userData=key)
        # Backward compatibility mapping from legacy label or key to new canonical key
        legacy_mode = self.settings.get('dca_mode', 'fixed_pips')
        legacy_map = {
            'fixed_multiple': 'fixed_pips',
            'adaptive_ratio': 'atr_multiple',  # treat old adaptive as ATR-based approximation
            'fibonacci_levels': 'fibo_levels',
            'fibonacci': 'fibo_levels',  # ðŸ”§ ADD: Map legacy "fibonacci" to "fibo_levels"
            'Bá»™i sá»‘ cá»‘ Ä‘á»‹nh': 'fixed_pips',
            'Tá»± Ä‘á»™ng theo tá»· lá»‡': 'atr_multiple',
            'Má»©c Fibonacci': 'fibo_levels',
            'Má»©c Fibo': 'fibo_levels'
        }
        saved_mode_key = legacy_map.get(legacy_mode, legacy_mode if legacy_mode in [m[0] for m in self._dca_mode_items] else 'fixed_pips')
        # Try to set current index by key
        for idx in range(self.dca_mode_combo.count()):
            if self.dca_mode_combo.itemData(idx) == saved_mode_key:
                self.dca_mode_combo.setCurrentIndex(idx)
                break
        self.dca_mode_combo.setToolTip(I18N.t(
            "Select DCA averaging method (Fixed, Adaptive, Fibonacci)",
            "Chá»n phÆ°Æ¡ng phÃ¡p DCA (Cá»‘ Ä‘á»‹nh, Tá»± Ä‘á»™ng theo tá»· lá»‡, Fibonacci)"
        ))
        dca_layout.addWidget(self.dca_mode_combo, 4, 1)
        
        # Per-mode option widgets container (grid row starts at 5)
        # ATR options
        self.dca_atr_period_label = QLabel(I18N.t("ATR Period:", "Chu ká»³ ATR:"))
        self.dca_atr_period_spin = QSpinBox(); self.dca_atr_period_spin.setRange(1, 500); self.dca_atr_period_spin.setValue(self.settings.get('dca_atr_period', 14))
        self.dca_atr_mult_label = QLabel(I18N.t("ATR Multiplier:", "Há»‡ sá»‘ ATR:"))
        self.dca_atr_mult_spin = QDoubleSpinBox(); self.dca_atr_mult_spin.setRange(0.1, 20.0); self.dca_atr_mult_spin.setSingleStep(0.1); self.dca_atr_mult_spin.setValue(self.settings.get('dca_atr_multiplier', 1.5))
        # Fixed pips base distance
        self.dca_base_distance_label = QLabel(I18N.t("DCA Distance (pips):", "Khoáº£ng CÃ¡ch DCA (Pips):"))
        self.dca_base_distance_spin = QDoubleSpinBox(); self.dca_base_distance_spin.setRange(1, 10000); self.dca_base_distance_spin.setSingleStep(1); self.dca_base_distance_spin.setValue(self.settings.get('dca_distance_pips', 50))
        # Fibonacci note (informational)
        self.dca_fibo_note = QLabel(I18N.t("Fibonacci expansion sequence used for spacing & volume", "DÃ¹ng chuá»—i Fibonacci Ä‘á»ƒ giÃ£n cÃ¡ch & khá»‘i lÆ°á»£ng"))
        self.dca_fibo_note.setStyleSheet("color:#888;font-style:italic;")
        # Simplified Fibonacci settings: one levels field (comma-separated), first value used for first Entry reference, auto scales next
        self.dca_fibo_levels_label = QLabel(I18N.t("Start Fibonacci Retracement (%):", "Báº¯t Ä‘áº§u tá»« má»©c Fibonacci (%):"))
        # Use already imported QComboBox from module scope
        self.dca_fibo_start_combo = QComboBox()
        retracement_levels = [23.6, 38.2, 50.0, 61.8, 78.6, 100.0]
        for idx2, val in enumerate(retracement_levels):
            self.dca_fibo_start_combo.addItem(f"{val:.1f}%", userData=idx2)
        # Migration: if old numeric fibo sequence existed, just anchor at first retracement (index 0)
        start_index = 0
        saved_start_idx = self.settings.get('dca_fibo_start_level', start_index)
        if 0 <= saved_start_idx < self.dca_fibo_start_combo.count():
            self.dca_fibo_start_combo.setCurrentIndex(saved_start_idx)
        self.dca_fibo_start_combo.setToolTip(I18N.t(
            "Select starting Fibonacci retracement %; subsequent entries use the following levels.",
            "Chá»n má»©c Fibonacci % báº¯t Ä‘áº§u; cÃ¡c táº§ng tiáº¿p theo dÃ¹ng cÃ¡c má»©c phÃ­a sau."))

        # New: Fibo execution mode (two auto market modes)
        self.dca_fibo_exec_label = QLabel(I18N.t("Fibonacci Exec Mode:", "Cháº¿ Ä‘á»™ thá»±c thi Fibonacci:"))
        self.dca_fibo_exec_combo = QComboBox()
        self.dca_fibo_exec_combo.addItems([
            I18N.t("On Touch (Market)", "Cháº¡m Má»©c (Market)"),
            I18N.t("Pending Limit at Level", "Äáº·t Lá»‡nh Chá» táº¡i Má»©c")
        ])
        self.dca_fibo_exec_combo.setCurrentText(self.settings.get('dca_fibo_exec_mode', I18N.t("On Touch (Market)", "Cháº¡m Má»©c (Market)")))
        self.dca_fibo_exec_combo.setToolTip(I18N.t(
            "Choose how Fibonacci DCA orders are executed: Market entry immediately when price touches level, or place a pending limit order at the level.",
            "Chá»n cÃ¡ch vÃ o lá»‡nh DCA theo Fibonacci: Khá»›p Market khi giÃ¡ cháº¡m má»©c, hoáº·c Ä‘áº·t lá»‡nh chá» Limit táº¡i má»©c."))

        # Add placeholders (we'll control visibility dynamically)
        row = 5
        dca_layout.addWidget(self.dca_atr_period_label, row, 0); dca_layout.addWidget(self.dca_atr_period_spin, row, 1)
        dca_layout.addWidget(self.dca_atr_mult_label, row, 2); dca_layout.addWidget(self.dca_atr_mult_spin, row, 3)
        row += 1
        dca_layout.addWidget(self.dca_base_distance_label, row, 0); dca_layout.addWidget(self.dca_base_distance_spin, row, 1)
        row += 1
        # Fibonacci simplified input
        dca_layout.addWidget(self.dca_fibo_levels_label, row, 0); dca_layout.addWidget(self.dca_fibo_start_combo, row, 1)
        dca_layout.addWidget(self.dca_fibo_exec_label, row, 2); dca_layout.addWidget(self.dca_fibo_exec_combo, row, 3)
        row += 1
        dca_layout.addWidget(self.dca_fibo_note, row, 0, 1, 4)

        def _refresh_dca_mode_widgets():
            key = self.get_current_dca_mode_key()
            atr_visible = (key == 'atr_multiple')
            fixed_visible = (key == 'fixed_pips')
            fibo_visible = (key == 'fibo_levels')
            for w in [self.dca_atr_period_label, self.dca_atr_period_spin, self.dca_atr_mult_label, self.dca_atr_mult_spin]:
                w.setVisible(atr_visible)
            for w in [self.dca_base_distance_label, self.dca_base_distance_spin]:
                w.setVisible(fixed_visible)
            for w in [self.dca_fibo_levels_label, self.dca_fibo_start_combo, self.dca_fibo_exec_label, self.dca_fibo_exec_combo, self.dca_fibo_note]:
                w.setVisible(fibo_visible)

        def _on_dca_mode_changed(index: int):
            _refresh_dca_mode_widgets()
            print(f"[DCA] Mode changed -> {self.get_current_dca_mode_key()}")
        self.dca_mode_combo.currentIndexChanged.connect(_on_dca_mode_changed)
        _refresh_dca_mode_widgets()
        
        self.dca_group.setLayout(dca_layout)
        layout.addWidget(self.dca_group)
        
        # Connect DCA Strategy controls to auto-save (no popup message)
        self.enable_dca_check.stateChanged.connect(self.auto_save_risk_settings)
        self.max_dca_levels_spin.valueChanged.connect(self.auto_save_risk_settings)
        # ðŸ”§ FIX: Connect DCA mode-specific widgets to auto-save
        self.dca_multiplier_spin.valueChanged.connect(self.auto_save_risk_settings)
        self.dca_mode_combo.currentTextChanged.connect(self.auto_save_risk_settings)
        self.dca_atr_period_spin.valueChanged.connect(self.auto_save_risk_settings)
        self.dca_atr_mult_spin.valueChanged.connect(self.auto_save_risk_settings)
        self.dca_base_distance_spin.valueChanged.connect(self.auto_save_risk_settings)
        self.dca_fibo_start_combo.currentTextChanged.connect(self.auto_save_risk_settings)
        self.dca_fibo_exec_combo.currentTextChanged.connect(self.auto_save_risk_settings)
        
        # === DCA CONDITIONS GROUP ===
        self.conditions_group = QGroupBox(I18N.t("âš™ï¸ DCA Activation Conditions", "âš™ï¸ Äiá»u kiá»‡n kÃ­ch hoáº¡t DCA"))
        conditions_layout = QGridLayout()
        
        # Minimum drawdown to activate DCA
        self.dca_min_drawdown_label = QLabel(I18N.t("Min Drawdown for DCA (%):", "Sá»¥t giáº£m tá»‘i thiá»ƒu Ä‘á»ƒ DCA (%):"))
        conditions_layout.addWidget(self.dca_min_drawdown_label, 0, 0)
        self.dca_min_drawdown_spin = QDoubleSpinBox()
        self.dca_min_drawdown_spin.setRange(0.0, 100.0)
        self.dca_min_drawdown_spin.setSingleStep(0.1)
        self.dca_min_drawdown_spin.setValue(self.settings.get('dca_min_drawdown', 1.0))
        self.dca_min_drawdown_spin.setToolTip(I18N.t("Minimum unrealized loss percentage to trigger DCA", "Pháº§n trÄƒm lá»— chÆ°a thá»±c hiá»‡n tá»‘i thiá»ƒu Ä‘á»ƒ kÃ­ch hoáº¡t DCA"))
        conditions_layout.addWidget(self.dca_min_drawdown_spin, 0, 1)
        
        # (Removed checkbox: Only DCA on High Confidence Signals (>4.0))
        # Row 1 now left intentionally empty or can be repurposed later.
        
        # DCA stop loss mode
        self.dca_sl_mode_label = QLabel(I18N.t("DCA SL Mode:", "Cháº¿ Ä‘á»™ SL cho DCA:"))
        conditions_layout.addWidget(self.dca_sl_mode_label, 2, 0)
        self.dca_sl_mode_combo = QComboBox()
        # ðŸ”§ FORCE CLEAR: Ensure no cached items remain
        self.dca_sl_mode_combo.clear()
        self.dca_sl_mode_combo.addItems([
            I18N.t("Individual SL", "SL riÃªng láº»"), 
            I18N.t("Average SL", "SL trung bÃ¬nh")
        ])
        # Handle backward compatibility - map old values to valid options
        saved_dca_sl_mode = self.settings.get('dca_sl_mode', I18N.t('Average SL', 'SL trung bÃ¬nh'))
        valid_modes = [I18N.t("Individual SL", "SL riÃªng láº»"), I18N.t("Average SL", "SL trung bÃ¬nh")]
        
        # Map legacy values to new valid options
        if saved_dca_sl_mode not in valid_modes:
            if saved_dca_sl_mode in ["adaptive", "Chá»‰ hÃ²a vá»‘n", "Breakeven Only", "breakeven"]:
                saved_dca_sl_mode = I18N.t('Average SL', 'SL trung bÃ¬nh')  # Default to Average SL for legacy modes
        
        self.dca_sl_mode_combo.setCurrentText(saved_dca_sl_mode)
        self.dca_sl_mode_combo.setToolTip(I18N.t("How to handle stop loss for DCA entries", "CÃ¡ch xá»­ lÃ½ stop loss cho cÃ¡c lá»‡nh DCA"))
        conditions_layout.addWidget(self.dca_sl_mode_combo, 2, 1)
        
        # ðŸ†• NEW: Profit percentage adjustment for Average SL mode
        self.dca_avg_sl_profit_label = QLabel(I18N.t("Average SL Profit % (Per Symbol):", "% Lá»£i nhuáº­n SL trung bÃ¬nh (Theo Symbol):"))
        conditions_layout.addWidget(self.dca_avg_sl_profit_label, 3, 0)
        self.dca_avg_sl_profit_spin = QDoubleSpinBox()
        self.dca_avg_sl_profit_spin.setRange(-50.0, 100.0)  # Allow negative for partial loss, up to 100% profit
        self.dca_avg_sl_profit_spin.setSingleStep(1.0)
        self.dca_avg_sl_profit_spin.setSuffix("%")
        self.dca_avg_sl_profit_spin.setValue(self.settings.get('dca_avg_sl_profit_percent', 10.0))
        self.dca_avg_sl_profit_spin.setToolTip(I18N.t(
            "Profit percentage target when using Average SL mode. Calculated PER SYMBOL, not all positions. 0% = breakeven, 10% = 10% profit target for that symbol",
            "Má»¥c tiÃªu % lá»£i nhuáº­n theo Tá»ªNG SYMBOL khi dÃ¹ng cháº¿ Ä‘á»™ SL trung bÃ¬nh. VD: 10% = Ä‘Ã³ng táº¥t cáº£ lá»‡nh XAUUSD khi lá»£i nhuáº­n XAUUSD Ä‘áº¡t 10%, khÃ´ng áº£nh hÆ°á»Ÿng Symbol khÃ¡c"
        ))
        conditions_layout.addWidget(self.dca_avg_sl_profit_spin, 3, 1)
        
        self.conditions_group.setLayout(conditions_layout)
        layout.addWidget(self.conditions_group)
        
        # Connect DCA Conditions controls to auto-save (no popup message)
        self.dca_min_drawdown_spin.valueChanged.connect(self.auto_save_risk_settings)
        self.dca_sl_mode_combo.currentTextChanged.connect(self.auto_save_risk_settings)
        self.dca_sl_mode_combo.currentTextChanged.connect(self.toggle_dca_profit_controls)  # ðŸ†• NEW: Show/hide profit controls
        self.dca_avg_sl_profit_spin.valueChanged.connect(self.auto_save_risk_settings)  # ðŸ†• NEW: Auto save profit %
        
        # Initial state of profit controls
        self.toggle_dca_profit_controls()
        
        layout.addStretch()
        tab.setLayout(layout)
        return tab
        
    # (DCA mode change logic removed â€“ fixed simple distance UI)
        
    def on_volume_mode_changed(self):
        """Update volume mode explanation when mode changes"""
        self.update_volume_mode_explanation()
        self.update_volume_fields_visibility()
        
    def update_volume_fields_visibility(self):
        """ðŸ”§ FIX: Simplified volume fields visibility logic"""
        try:
            current_mode = self.volume_mode_combo.currentText()
            
            # ðŸ”§ SIMPLIFIED: Four clear modes
            is_auto_mode = "auto" in current_mode.lower() or "tá»± Ä‘á»™ng" in current_mode.lower()
            is_fixed_mode = "fixed" in current_mode.lower() or "cá»‘ Ä‘á»‹nh" in current_mode.lower()
            is_default_mode = "default" in current_mode.lower() or "máº·c Ä‘á»‹nh" in current_mode.lower()
            
            # Show/hide min lot for auto mode only
            if hasattr(self, 'min_lot_spin'):
                self.min_lot_spin.setVisible(is_auto_mode)
            if hasattr(self, 'min_lot_label'):
                self.min_lot_label.setVisible(is_auto_mode)
            
            # Show/hide fixed volume for fixed mode only  
            if hasattr(self, 'fixed_volume_spin'):
                self.fixed_volume_spin.setVisible(is_fixed_mode)
                self.fixed_volume_label.setVisible(is_fixed_mode)
                
            # Show/hide default volume for default mode only
            if hasattr(self, 'default_volume_spin'):
                self.default_volume_spin.setVisible(is_default_mode)
                self.default_volume_label.setVisible(is_default_mode)
            
        except Exception as e:
            print(f"âš ï¸ Volume fields visibility error: {e}")
        
    def update_volume_mode_explanation(self):
        """Update explanation text based on selected volume mode"""
        try:
            current_mode = self.volume_mode_combo.currentText()
            
            if "tá»± Ä‘á»™ng" in current_mode.lower() or "auto" in current_mode.lower():
                text = I18N.t(
                    "Auto Mode: Min volume for first trades, DCA scales up. Both min and max limits apply.",
                    "Cháº¿ Ä‘á»™ tá»± Ä‘á»™ng: Khá»‘i lÆ°á»£ng tá»‘i thiá»ƒu cho lá»‡nh Ä‘áº§u, DCA scale lÃªn. Ãp dá»¥ng cáº£ min vÃ  max."
                )
            elif "Risk-Based" in current_mode or "Theo rá»§i ro" in current_mode:
                text = I18N.t(
                    "Risk-Based: Volume calculated automatically based on risk percentage, only max limit applies",
                    "Theo rá»§i ro: Khá»‘i lÆ°á»£ng tÃ­nh dá»±a trÃªn tá»· lá»‡ rá»§i ro, chá»‰ Ã¡p dá»¥ng giá»›i háº¡n max"
                )
            elif "cá»‘ Ä‘á»‹nh" in current_mode.lower() or "Fixed Volume" in current_mode:
                text = I18N.t(
                    "Fixed Volume: All trades use the fixed lot size, only max total limit applies",
                    "Khá»‘i lÆ°á»£ng cá»‘ Ä‘á»‹nh: Táº¥t cáº£ lá»‡nh dÃ¹ng kÃ­ch thÆ°á»›c cá»‘ Ä‘á»‹nh, chá»‰ Ã¡p dá»¥ng giá»›i háº¡n tá»•ng max"
                )
            elif "máº·c Ä‘á»‹nh" in current_mode.lower() or "Default Volume" in current_mode:
                text = I18N.t(
                    "Default Volume: Uses default volume setting for all trades, only max total limit applies",
                    "Khá»‘i lÆ°á»£ng máº·c Ä‘á»‹nh: DÃ¹ng cÃ i Ä‘áº·t khá»‘i lÆ°á»£ng máº·c Ä‘á»‹nh cho táº¥t cáº£ lá»‡nh, chá»‰ Ã¡p dá»¥ng giá»›i háº¡n tá»•ng max"
                )
            else:
                text = ""
                
            self.volume_mode_label.setText(text)
        except Exception as e:
            print(f"Error updating volume mode explanation: {e}")
        
    def create_control_panel(self):
        """Create bottom control panel"""
        panel = QGroupBox(I18N.t("ðŸŽ® Control Panel", "ðŸŽ® Báº£ng Ä‘iá»u khiá»ƒn"))
        layout = QHBoxLayout()
        
        # âœ… MANUAL MODE ONLY - No mode selection needed
        # Risk management now operates in manual mode only
        
        layout.addStretch()
        
        # Control buttons
        self.save_btn = QPushButton(I18N.t("ðŸ’¾ Save Settings", "ðŸ’¾ LÆ°u cÃ i Ä‘áº·t"))
        self.save_btn.clicked.connect(self.save_risk_settings)
        self.save_btn.setStyleSheet("background-color: #27AE60; color: white; font-weight: bold;")
        layout.addWidget(self.save_btn)
        
        self.load_btn = QPushButton(I18N.t("ðŸ“ Load Settings", "ðŸ“ Táº£i cÃ i Ä‘áº·t"))
        self.load_btn.clicked.connect(self.load_risk_settings)
        layout.addWidget(self.load_btn)
        
        self.reset_btn = QPushButton(I18N.t("ðŸ”„ Reset to Default", "ðŸ”„ Äáº·t láº¡i máº·c Ä‘á»‹nh"))
        self.reset_btn.clicked.connect(self.reset_to_default)
        layout.addWidget(self.reset_btn)
        
        self.generate_report_btn = QPushButton(I18N.t("ðŸ“Š Generate Report", "ðŸ“Š Táº¡o bÃ¡o cÃ¡o"))
        self.generate_report_btn.clicked.connect(self.generate_report)
        self.generate_report_btn.setStyleSheet("background-color: #3498DB; color: white; font-weight: bold;")
        layout.addWidget(self.generate_report_btn)
        
        panel.setLayout(layout)
        return panel
    
    def update_existing_risk_manager_params(self):
        """Update existing risk manager parameters without recreating instance"""
        try:
            if not self.risk_manager:
                return
                
            # Get current values from UI
            avoid_news_value = self.get_combo_value(self.avoid_news_combo, 30) if hasattr(self, 'avoid_news_combo') else 30
            emergency_dd_value = self.get_combo_value(self.emergency_dd_combo, 10.0) if hasattr(self, 'emergency_dd_combo') else 10.0
            max_dd_value = self.get_combo_value(self.max_drawdown_combo, 5.0) if hasattr(self, 'max_drawdown_combo') else 5.0
            max_risk_value = self.get_combo_value(self.max_risk_combo, 2.0) if hasattr(self, 'max_risk_combo') else 2.0
            daily_loss_value = self.get_combo_value(self.daily_loss_combo, 3.0) if hasattr(self, 'daily_loss_combo') else 3.0
            
            # Update existing risk parameters
            if hasattr(self.risk_manager, 'risk_params') and self.risk_manager.risk_params:
                self.risk_manager.risk_params.max_risk_percent = max_risk_value
                self.risk_manager.risk_params.max_drawdown_percent = max_dd_value  
                self.risk_manager.risk_params.max_daily_loss_percent = daily_loss_value
                self.risk_manager.risk_params.emergency_stop_drawdown = emergency_dd_value
                self.risk_manager.risk_params.avoid_news_minutes = avoid_news_value
                
                # Save updated parameters to file
                self.risk_manager._save_risk_parameters()
                
                print(f"ðŸ”„ Risk Manager parameters updated")
                
        except Exception as e:
            print(f"âŒ Failed to update risk manager params: {e}")
        
    def init_risk_manager(self):
        """Initialize the risk management system (disabled - risk_manager.py removed)"""
        try:
            # Risk manager file was removed - set to disabled state
            self.risk_manager = None
            print("ðŸ›¡ï¸ Risk Management System disabled - risk_manager.py was removed")
            print("ðŸ“ Risk settings are still saved manually through the Save Settings button")
            
        except Exception as e:
            print(f"âŒ Risk manager initialization error: {e}")
            self.risk_manager = None
    
    def validate_signal(self, signal_data):
        """Validate a trading signal (simplified - risk manager removed)"""
        # Risk manager was removed, return basic validation
        return {"valid": True, "message": "Risk manager disabled - manual validation only"}
    
    # âœ… MODE FUNCTIONS REMOVED - Manual mode only
    # No mode selection needed anymore
    
    def get_smallest_timeframe_minutes(self):
        """Get the smallest selected timeframe from MarketTab in minutes"""
        try:
            if not self.market_tab or not hasattr(self.market_tab, 'tf_checkboxes'):
                return 60  # Default to 1 hour if no market tab
            
            # Timeframe mapping to minutes
            timeframe_minutes = {
                'M1': 1, 'M5': 5, 'M15': 15, 'M30': 30, 
                'H1': 60, 'H4': 240, 'D1': 1440, 'W1': 10080, 'MN1': 43200
            }
            
            # Get selected timeframes
            selected_timeframes = []
            for tf, checkbox in self.market_tab.tf_checkboxes.items():
                if checkbox.isChecked():
                    selected_timeframes.append(tf)
            
            if not selected_timeframes:
                return 60  # Default to 1 hour if none selected
            
            # Find smallest timeframe in minutes
            smallest_minutes = min([timeframe_minutes.get(tf, 60) for tf in selected_timeframes])
            print(f"ðŸ“Š Detected smallest timeframe: {smallest_minutes} minutes from {selected_timeframes}")
            return smallest_minutes
            
        except Exception as e:
            print(f"âŒ Error detecting timeframe: {e}")
            return 60  # Default fallback
    
    def get_auto_adjustment_interval_hours(self):
        """Calculate smart auto adjustment interval based on smallest timeframe"""
        smallest_minutes = self.get_smallest_timeframe_minutes()
        
        # Smart interval logic based on timeframe
        if smallest_minutes <= 5:      # M1, M5 -> adjust every 30 minutes 
            return 0.5
        elif smallest_minutes <= 15:   # M15 -> adjust every 1 hour
            return 1
        elif smallest_minutes <= 60:   # M30, H1 -> adjust every 2 hours
            return 2  
        elif smallest_minutes <= 240:  # H4 -> adjust every 4 hours
            return 4
        else:                          # D1, W1, MN1 -> adjust every 24 hours
            return 24
    
    @safe_method
    # OLD SAVE/LOAD FUNCTIONS REMOVED - REPLACED WITH NEW SIMPLE SYSTEM
    
    def save_risk_settings(self, *args):
        """ðŸ†• Save current GUI values to file - Simple and direct (accepts Qt signal args)"""
        try:
            # ðŸš« SET FLAG to prevent infinite auto-save loops
            self._is_saving_settings = True
            
            # Collect current GUI values
            current_settings = self._collect_gui_values()
            
            # Add metadata
            current_settings['saved_timestamp'] = datetime.now().isoformat()
            current_settings['version'] = '3.0'
            
            # Create directory and save
            os.makedirs("risk_management", exist_ok=True)
            settings_file = "risk_management/risk_settings.json"
            
            with open(settings_file, 'w', encoding='utf-8') as f:
                json.dump(current_settings, f, indent=2, ensure_ascii=False)
            
            print(f"âœ… Saved {len(current_settings)} settings to {settings_file}")
            self.settings = current_settings  # Update internal state
            return True
            
        except Exception as e:
            print(f"âŒ Error saving risk settings: {e}")
            return False
        finally:
            # ðŸš« CLEAR FLAG to allow future auto-saves
            self._is_saving_settings = False
    
    def _collect_gui_values(self):
        """ðŸ†• Collect current values from ALL GUI controls - ONLY save what's enabled"""
        settings = {}
        
        try:
            # =====================================
            # BASIC SETTINGS TAB
            # =====================================
                
            # Volume Settings (conditional based on volume_mode)
            if hasattr(self, 'volume_mode_combo') and self.volume_mode_combo:
                volume_mode = self.volume_mode_combo.currentText()
                settings['volume_mode'] = volume_mode
                
                # ðŸŽ¯ CONDITIONAL VOLUME SAVING based on mode
                if 'máº·c Ä‘á»‹nh' in volume_mode or 'Default' in volume_mode:
                    # Default Volume mode - save default_volume_lots
                    if hasattr(self, 'default_volume_spin') and self.default_volume_spin:
                        settings['default_volume_lots'] = self.default_volume_spin.value()
                        
                elif 'Cá»‘ Ä‘á»‹nh' in volume_mode or 'Fixed' in volume_mode:
                    # Fixed Volume mode - save fixed_volume_lots
                    if hasattr(self, 'fixed_volume_spin') and self.fixed_volume_spin:
                        settings['fixed_volume_lots'] = self.fixed_volume_spin.value()
                        
                elif 'rá»§i ro' in volume_mode or 'Tá»± Ä‘á»™ng' in volume_mode or 'Risk' in volume_mode:
                    # Risk-based Auto Volume mode - don't save any volume lots
                    # Volume will be calculated automatically based on risk
                    pass  # âœ… No volume lots saved for auto risk mode
                
            # SL/TP Settings
            if hasattr(self, 'sltp_mode_combo') and self.sltp_mode_combo:
                settings['sltp_mode'] = self.sltp_mode_combo.currentText()
            if hasattr(self, 'default_sl_spin') and self.default_sl_spin:
                settings['default_sl_atr_multiplier'] = self.default_sl_spin.value()
            if hasattr(self, 'default_tp_spin') and self.default_tp_spin:
                settings['default_tp_atr_multiplier'] = self.default_tp_spin.value()
                
            # Breakeven & Trailing Stop Settings
            if hasattr(self, 'breakeven_min_spin') and self.breakeven_min_spin:
                settings['breakeven_min_pips'] = self.breakeven_min_spin.value()
            if hasattr(self, 'breakeven_max_spin') and self.breakeven_max_spin:
                settings['breakeven_max_pips'] = self.breakeven_max_spin.value()
            if hasattr(self, 'trailing_activation_spin') and self.trailing_activation_spin:
                settings['trailing_activation_pips'] = self.trailing_activation_spin.value()
            if hasattr(self, 'trailing_min_spin') and self.trailing_min_spin:
                settings['trailing_min_pips'] = self.trailing_min_spin.value()
            if hasattr(self, 'trailing_max_spin') and self.trailing_max_spin:
                settings['trailing_max_pips'] = self.trailing_max_spin.value()
            if hasattr(self, 'trailing_volatility_cb') and self.trailing_volatility_cb:
                settings['trailing_use_volatility'] = self.trailing_volatility_cb.isChecked()
                
            # =====================================
            # POSITION MANAGEMENT TAB
            # =====================================
            
            # Position Limits
            if hasattr(self, 'max_positions_spin') and self.max_positions_spin:
                settings['max_positions'] = self.max_positions_spin.value()
            if hasattr(self, 'max_positions_per_symbol_spin') and self.max_positions_per_symbol_spin:
                settings['max_positions_per_symbol'] = self.max_positions_per_symbol_spin.value()
            if hasattr(self, 'max_correlation_spin') and self.max_correlation_spin:
                settings['max_correlation'] = self.max_correlation_spin.value()
                
            # Volume Limits - CHá»ˆ LÆ¯U min_volume_auto KHI á»ž AUTO MODE
            if hasattr(self, 'volume_mode_combo') and self.volume_mode_combo:
                volume_mode = self.volume_mode_combo.currentText()
                # Chá»‰ lÆ°u min_volume_auto khi á»Ÿ Auto/Risk-based mode
                if ('rá»§i ro' in volume_mode or 'Tá»± Ä‘á»™ng' in volume_mode or 'Risk' in volume_mode or 'Auto' in volume_mode):
                    if hasattr(self, 'min_lot_spin') and self.min_lot_spin:
                        settings['min_volume_auto'] = self.min_lot_spin.value()
                
            # CHá»ˆ lÆ°u max_total_volume khi khÃ´ng pháº£i OFF
            max_lot_value = self.get_combo_value(self.max_lot_combo, "OFF") if hasattr(self, 'max_lot_combo') else "OFF"
            if max_lot_value != "OFF":
                settings['max_total_volume'] = max_lot_value
                
            # =====================================
            # RISK MANAGEMENT TAB  
            # =====================================
            
            # Core Risk Settings - CHá»ˆ LÆ¯U KHI KHÃ”NG PHáº¢I OFF
            max_risk_value = self.get_combo_value(self.max_risk_combo, "OFF") if hasattr(self, 'max_risk_combo') else "OFF"
            if max_risk_value != "OFF":
                settings['max_risk_percent'] = max_risk_value
                
            max_dd_value = self.get_combo_value(self.max_drawdown_combo, "OFF") if hasattr(self, 'max_drawdown_combo') else "OFF"
            if max_dd_value != "OFF":
                settings['max_drawdown_percent'] = max_dd_value
                
            daily_loss_value = self.get_combo_value(self.daily_loss_combo, "OFF") if hasattr(self, 'daily_loss_combo') else "OFF"
            if daily_loss_value != "OFF":
                settings['max_daily_loss_percent'] = daily_loss_value
                
            # Risk/Reward Ratio - CHá»ˆ LÆ¯U KHI KHÃ”NG PHáº¢I OFF
            min_rr_value = self.get_combo_value(self.min_rr_combo, "OFF") if hasattr(self, 'min_rr_combo') else "OFF"
            if min_rr_value != "OFF":
                settings['min_risk_reward_ratio'] = min_rr_value
                
            # =====================================
            # SYMBOL EXPOSURE/MULTIPLIER TABLE
            # =====================================
            
            # Collect symbol exposure and multiplier settings from table
            if hasattr(self, 'exposure_table') and self.exposure_table:
                symbol_exposure = {}
                symbol_multipliers = {}
                
                for row in range(self.exposure_table.rowCount()):
                    symbol_item = self.exposure_table.item(row, 0)
                    
                    if symbol_item:
                        symbol = symbol_item.text()
                        
                        # Skip placeholder symbols
                        if symbol and symbol != "ChÆ°a chá»n mÃ£" and symbol != "No symbols selected":
                            # Get exposure value from spinbox widget (column 1)
                            exposure_widget = self.exposure_table.cellWidget(row, 1)
                            # Get multiplier value from spinbox widget (column 2) 
                            multiplier_widget = self.exposure_table.cellWidget(row, 2)
                            
                            if exposure_widget and multiplier_widget:
                                try:
                                    exposure_val = exposure_widget.value()
                                    multiplier_val = multiplier_widget.value()
                                    
                                    # Save all non-zero values
                                    if exposure_val > 0 and multiplier_val > 0:
                                        symbol_exposure[symbol] = exposure_val
                                        symbol_multipliers[symbol] = multiplier_val
                                except Exception:
                                    pass  # Skip invalid values
                
                # Only save if we have actual symbol data
                if symbol_exposure:
                    settings['symbol_exposure'] = symbol_exposure
                if symbol_multipliers:
                    settings['symbol_multipliers'] = symbol_multipliers
                
            # =====================================
            # TRADING HOURS TAB
            # =====================================
            
            # Trading Hours (Hour:Minute format)
            if hasattr(self, 'start_hour_spin') and self.start_hour_spin:
                settings['trading_hours_start'] = self.start_hour_spin.value()
            if hasattr(self, 'start_minute_spin') and self.start_minute_spin:
                settings['trading_minutes_start'] = self.start_minute_spin.value()
            if hasattr(self, 'end_hour_spin') and self.end_hour_spin:
                settings['trading_hours_end'] = self.end_hour_spin.value()
            if hasattr(self, 'end_minute_spin') and self.end_minute_spin:
                settings['trading_minutes_end'] = self.end_minute_spin.value()
                
            # News Avoidance - CHá»ˆ LÆ¯U KHI KHÃ”NG PHáº¢I OFF
            avoid_news_value = self.get_combo_value(self.avoid_news_combo, "OFF") if hasattr(self, 'avoid_news_combo') else "OFF"
            if avoid_news_value != "OFF":
                settings['avoid_news_minutes'] = avoid_news_value
                settings['disable_news_avoidance'] = False
            else:
                settings['disable_news_avoidance'] = True
                
            # =====================================
            # MARKET CONDITIONS TAB
            # =====================================
            
            # Market Conditions
            if hasattr(self, 'spread_multiplier_spin') and self.spread_multiplier_spin:
                settings['max_spread_multiplier'] = self.spread_multiplier_spin.value()
            if hasattr(self, 'max_slippage_spin') and self.max_slippage_spin:
                settings['max_slippage'] = self.max_slippage_spin.value()
                
            # =====================================
            # EMERGENCY CONTROLS TAB
            # =====================================
            
            # Emergency Stop - CHá»ˆ LÆ¯U KHI KHÃ”NG PHáº¢I OFF
            emergency_dd_value = self.get_combo_value(self.emergency_dd_combo, "OFF") if hasattr(self, 'emergency_dd_combo') else "OFF"
            if emergency_dd_value != "OFF":
                settings['emergency_stop_drawdown'] = emergency_dd_value
                settings['disable_emergency_stop'] = False
            else:
                settings['disable_emergency_stop'] = True
                
            # Auto Reduce on Losses
            if hasattr(self, 'auto_reduce_check') and self.auto_reduce_check:
                settings['auto_reduce_on_losses'] = self.auto_reduce_check.isChecked()
                
            # =====================================
            # DCA SETTINGS TAB
            # =====================================
            
            # DCA Settings - CHá»ˆ LÆ¯U KHI DCA ÄÆ¯á»¢C Báº¬T
            if hasattr(self, 'enable_dca_check') and self.enable_dca_check:
                enable_dca = self.enable_dca_check.isChecked()
                settings['enable_dca'] = enable_dca
                
                # CHá»ˆ lÆ°u DCA details khi DCA ÄÆ¯á»¢C Báº¬T
                if enable_dca:
                    # âœ… LUÃ”N LÆ¯U: DCA Minimum Drawdown to trigger DCA
                    if hasattr(self, 'dca_min_drawdown_spin') and self.dca_min_drawdown_spin:
                        settings['dca_min_drawdown'] = self.dca_min_drawdown_spin.value()
                    
                    if hasattr(self, 'max_dca_levels_spin') and self.max_dca_levels_spin:
                        settings['max_dca_levels'] = self.max_dca_levels_spin.value()
                        
                    # DCA Volume Multiplier
                    if hasattr(self, 'dca_multiplier_spin') and self.dca_multiplier_spin:
                        settings['dca_volume_multiplier'] = self.dca_multiplier_spin.value()
                        
                    # DCA Mode - CHá»ˆ lÆ°u khi cÃ³ mode Ä‘Æ°á»£c chá»n
                    if hasattr(self, 'dca_mode_combo') and self.dca_mode_combo:
                        dca_mode = self.dca_mode_combo.currentText()
                        settings['dca_mode'] = dca_mode
                        
                        # CHá»ˆ lÆ°u settings tÆ°Æ¡ng á»©ng vá»›i mode Ä‘Æ°á»£c chá»n
                        if 'ATR' in dca_mode or 'Bá»™i sá»‘ ATR' in dca_mode:
                            # Chá»‰ lÆ°u ATR settings khi mode = ATR
                            if hasattr(self, 'dca_atr_period_spin') and self.dca_atr_period_spin:
                                settings['dca_atr_period'] = self.dca_atr_period_spin.value()
                            if hasattr(self, 'dca_atr_mult_spin') and self.dca_atr_mult_spin:
                                settings['dca_atr_multiplier'] = self.dca_atr_mult_spin.value()
                                
                        elif 'Pips' in dca_mode or 'cá»‘ Ä‘á»‹nh' in dca_mode:
                            # Chá»‰ lÆ°u Fixed Pips settings khi mode = Fixed Pips
                            if hasattr(self, 'dca_base_distance_spin') and self.dca_base_distance_spin:
                                settings['dca_distance_pips'] = self.dca_base_distance_spin.value()
                                
                        elif 'Fibonacci' in dca_mode or 'Fibo' in dca_mode:
                            # Chá»‰ lÆ°u Fibonacci settings khi mode = Fibonacci
                            if hasattr(self, 'dca_fibo_start_combo') and self.dca_fibo_start_combo:
                                settings['dca_fibo_start_level'] = self.dca_fibo_start_combo.currentIndex()  # ðŸ”§ FIX: Save index, not text
                            if hasattr(self, 'dca_fibo_exec_combo') and self.dca_fibo_exec_combo:
                                settings['dca_fibo_exec_mode'] = self.dca_fibo_exec_combo.currentText()  # ðŸ”§ ADD: Save exec mode
                            # ðŸ”§ ADD: Always save default Fibonacci levels for dca_service.py
                            settings['dca_fibo_levels'] = '23.6,38.2,50,61.8,78.6'
                    
                    # DCA SL Mode - luÃ´n lÆ°u khi DCA enabled
                    if hasattr(self, 'dca_sl_mode_combo') and self.dca_sl_mode_combo:
                        settings['dca_sl_mode'] = self.dca_sl_mode_combo.currentText()
                        
                        # DCA Average SL Profit Percentage - CHá»ˆ lÆ°u khi mode = "SL trung bÃ¬nh"
                        current_sl_mode = self.dca_sl_mode_combo.currentText()
                        if "SL trung bÃ¬nh" in current_sl_mode or "Average SL" in current_sl_mode:
                            if hasattr(self, 'dca_avg_sl_profit_spin') and self.dca_avg_sl_profit_spin:
                                settings['dca_avg_sl_profit_percent'] = self.dca_avg_sl_profit_spin.value()
                
            # =====================================
            # SIGNAL SETTINGS (from Signal Tab)
            # =====================================
            
            # ðŸ†• Signal Confidence Threshold for Order Placement
            # Láº¥y tá»« GUI náº¿u cÃ³, chuyá»ƒn Ä‘á»•i tá»« % â†’ 0-10 scale
            if hasattr(self, 'signal_tab') and hasattr(self.signal_tab, 'min_conf_spin'):
                try:
                    conf_percentage = float(self.signal_tab.min_conf_spin.value())
                    # Convert: 30% â†’ 3.0, 20% â†’ 2.0, etc.
                    conf_scaled = conf_percentage / 10.0
                    settings['min_confidence_for_entry'] = conf_scaled
                except Exception as e:
                    print(f"âš ï¸ Error reading signal confidence from GUI: {e}")
                        
            print(f"ðŸ” Collected {len(settings)} settings from GUI")
            return settings
            
        except Exception as e:
            print(f"âš ï¸ Error collecting GUI values: {e}")
            return self._get_default_risk_settings()
    
    def set_combo_value(self, combo, value):
        """Helper function to set combo box value, handling both text and numeric values"""
        if not combo:
            return
        
        # Try to find exact text match first
        index = combo.findText(str(value))
        if index >= 0:
            combo.setCurrentIndex(index)
        else:
            # Try to match numeric values for combo with numeric items
            for i in range(combo.count()):
                item_text = combo.itemText(i)
                try:
                    if item_text != "OFF" and float(item_text) == float(value):
                        combo.setCurrentIndex(i)
                        return
                except ValueError:
                    continue
    
    def _apply_risk_settings_to_gui(self):
        """ðŸ†• Apply loaded settings to GUI controls"""
        if not self.settings:
            return
            
        try:
            # Volume Mode
            if hasattr(self, 'volume_mode_combo') and 'volume_mode' in self.settings:
                mode = self.settings['volume_mode']
                index = self.volume_mode_combo.findText(mode)
                if index >= 0:
                    self.volume_mode_combo.setCurrentIndex(index)
                    
            # Volume Values
            if hasattr(self, 'default_volume_spin') and 'default_volume_lots' in self.settings:
                self.default_volume_spin.setValue(self.settings['default_volume_lots'])
            if hasattr(self, 'fixed_volume_spin') and 'fixed_volume_lots' in self.settings:
                self.fixed_volume_spin.setValue(self.settings['fixed_volume_lots'])
                
            # SL/TP Settings
            if hasattr(self, 'sltp_mode_combo') and 'sltp_mode' in self.settings:
                mode = self.settings['sltp_mode']
                index = self.sltp_mode_combo.findText(mode)
                if index >= 0:
                    self.sltp_mode_combo.setCurrentIndex(index)
            if hasattr(self, 'default_sl_spin') and 'default_sl_atr_multiplier' in self.settings:
                self.default_sl_spin.setValue(self.settings['default_sl_atr_multiplier'])
            if hasattr(self, 'default_tp_spin') and 'default_tp_atr_multiplier' in self.settings:
                self.default_tp_spin.setValue(self.settings['default_tp_atr_multiplier'])
                
            # Breakeven & Trailing Stop Settings
            if hasattr(self, 'breakeven_min_spin') and 'breakeven_min_pips' in self.settings:
                self.breakeven_min_spin.setValue(self.settings['breakeven_min_pips'])
            if hasattr(self, 'breakeven_max_spin') and 'breakeven_max_pips' in self.settings:
                self.breakeven_max_spin.setValue(self.settings['breakeven_max_pips'])
            if hasattr(self, 'trailing_activation_spin') and 'trailing_activation_pips' in self.settings:
                self.trailing_activation_spin.setValue(self.settings['trailing_activation_pips'])
            if hasattr(self, 'trailing_min_spin') and 'trailing_min_pips' in self.settings:
                self.trailing_min_spin.setValue(self.settings['trailing_min_pips'])
            if hasattr(self, 'trailing_max_spin') and 'trailing_max_pips' in self.settings:
                self.trailing_max_spin.setValue(self.settings['trailing_max_pips'])
            if hasattr(self, 'trailing_volatility_cb') and 'trailing_use_volatility' in self.settings:
                self.trailing_volatility_cb.setChecked(self.settings['trailing_use_volatility'])
                
            # Position Management
            if hasattr(self, 'max_positions_spin') and 'max_positions' in self.settings:
                self.max_positions_spin.setValue(self.settings['max_positions'])
            if hasattr(self, 'max_positions_per_symbol_spin') and 'max_positions_per_symbol' in self.settings:
                self.max_positions_per_symbol_spin.setValue(self.settings['max_positions_per_symbol'])
            if hasattr(self, 'max_correlation_spin') and 'max_correlation' in self.settings:
                self.max_correlation_spin.setValue(self.settings['max_correlation'])
                
            # Risk Management Settings
            if hasattr(self, 'max_risk_combo') and 'max_risk_percent' in self.settings:
                self.set_combo_value(self.max_risk_combo, self.settings['max_risk_percent'])
            if hasattr(self, 'max_drawdown_combo') and 'max_drawdown_percent' in self.settings:
                self.set_combo_value(self.max_drawdown_combo, self.settings['max_drawdown_percent'])
            if hasattr(self, 'daily_loss_combo') and 'max_daily_loss_percent' in self.settings:
                self.set_combo_value(self.daily_loss_combo, self.settings['max_daily_loss_percent'])
            if hasattr(self, 'min_rr_combo') and 'min_risk_reward_ratio' in self.settings:
                self.set_combo_value(self.min_rr_combo, self.settings['min_risk_reward_ratio'])
            
            # Volume Management
            if hasattr(self, 'min_lot_spin') and 'min_volume_auto' in self.settings:
                self.min_lot_spin.setValue(self.settings['min_volume_auto'])
            if hasattr(self, 'max_lot_combo') and 'max_total_volume' in self.settings:
                self.set_combo_value(self.max_lot_combo, self.settings['max_total_volume'])
                
            # Trading Hours
            if hasattr(self, 'start_hour_spin') and 'trading_hours_start' in self.settings:
                self.start_hour_spin.setValue(self.settings['trading_hours_start'])
            if hasattr(self, 'start_minute_spin') and 'trading_minutes_start' in self.settings:
                self.start_minute_spin.setValue(self.settings['trading_minutes_start'])
            if hasattr(self, 'end_hour_spin') and 'trading_hours_end' in self.settings:
                self.end_hour_spin.setValue(self.settings['trading_hours_end'])
            if hasattr(self, 'end_minute_spin') and 'trading_minutes_end' in self.settings:
                self.end_minute_spin.setValue(self.settings['trading_minutes_end'])
            if hasattr(self, 'avoid_news_combo') and 'avoid_news_minutes' in self.settings:
                self.set_combo_value(self.avoid_news_combo, self.settings['avoid_news_minutes'])
                
            # Market Conditions
            if hasattr(self, 'spread_multiplier_spin') and 'max_spread_multiplier' in self.settings:
                self.spread_multiplier_spin.setValue(self.settings['max_spread_multiplier'])
            if hasattr(self, 'max_slippage_spin') and 'max_slippage' in self.settings:
                self.max_slippage_spin.setValue(self.settings['max_slippage'])
                
            # Emergency Controls
            if hasattr(self, 'emergency_dd_combo') and 'emergency_stop_drawdown' in self.settings:
                self.set_combo_value(self.emergency_dd_combo, self.settings['emergency_stop_drawdown'])
            if hasattr(self, 'auto_reduce_check') and 'auto_reduce_on_losses' in self.settings:
                self.auto_reduce_check.setChecked(self.settings['auto_reduce_on_losses'])
                
            # DCA Settings
            if hasattr(self, 'enable_dca_check') and 'enable_dca' in self.settings:
                self.enable_dca_check.setChecked(self.settings['enable_dca'])
            if hasattr(self, 'max_dca_levels_spin') and 'max_dca_levels' in self.settings:
                self.max_dca_levels_spin.setValue(self.settings['max_dca_levels'])
            if hasattr(self, 'dca_multiplier_spin') and 'dca_volume_multiplier' in self.settings:
                self.dca_multiplier_spin.setValue(self.settings['dca_volume_multiplier'])
            if hasattr(self, 'dca_mode_combo') and 'dca_mode' in self.settings:
                index = self.dca_mode_combo.findText(self.settings['dca_mode'])
                if index >= 0:
                    self.dca_mode_combo.setCurrentIndex(index)
            if hasattr(self, 'dca_sl_mode_combo') and 'dca_sl_mode' in self.settings:
                index = self.dca_sl_mode_combo.findText(self.settings['dca_sl_mode'])
                if index >= 0:
                    self.dca_sl_mode_combo.setCurrentIndex(index)
            if hasattr(self, 'dca_min_drawdown_spin') and 'dca_min_drawdown' in self.settings:
                self.dca_min_drawdown_spin.setValue(self.settings['dca_min_drawdown'])
            if hasattr(self, 'dca_avg_sl_profit_spin') and 'dca_avg_sl_profit_percent' in self.settings:
                self.dca_avg_sl_profit_spin.setValue(self.settings['dca_avg_sl_profit_percent'])
                
            # DCA Mode-specific settings
            if hasattr(self, 'dca_atr_period_spin') and 'dca_atr_period' in self.settings:
                self.dca_atr_period_spin.setValue(self.settings['dca_atr_period'])
            if hasattr(self, 'dca_atr_mult_spin') and 'dca_atr_multiplier' in self.settings:
                self.dca_atr_mult_spin.setValue(self.settings['dca_atr_multiplier'])
            if hasattr(self, 'dca_base_distance_spin') and 'dca_distance_pips' in self.settings:
                self.dca_base_distance_spin.setValue(self.settings['dca_distance_pips'])
            if hasattr(self, 'dca_fibo_start_combo') and 'dca_fibo_start_level' in self.settings:
                # ðŸ”§ FIX: dca_fibo_start_level is index (int), not text
                try:
                    idx = int(self.settings['dca_fibo_start_level'])
                    if 0 <= idx < self.dca_fibo_start_combo.count():
                        self.dca_fibo_start_combo.setCurrentIndex(idx)
                except (ValueError, TypeError):
                    pass  # Keep default if invalid
            if hasattr(self, 'dca_fibo_exec_combo') and 'dca_fibo_exec_mode' in self.settings:
                # ðŸ”§ ADD: Load exec mode
                exec_mode = self.settings['dca_fibo_exec_mode']
                index = self.dca_fibo_exec_combo.findText(exec_mode)
                if index >= 0:
                    self.dca_fibo_exec_combo.setCurrentIndex(index)
            
            # Load symbol exposure table with settings
            if hasattr(self, 'populate_exposure_table') and ('symbol_exposure' in self.settings or 'symbol_multipliers' in self.settings):
                self.populate_exposure_table(self.settings)
                
            print("âœ… Applied ALL settings to GUI controls")
            
        except Exception as e:
            print(f"âš ï¸ Error applying settings to GUI: {e}")
    
    def auto_save_risk_settings(self):
        """ðŸ†• Auto-save when GUI changes (no popup) - with debounce"""
        # ðŸš« PREVENT AUTO-SAVE during initialization
        if getattr(self, '_is_initializing', False):
            return True
            
        # ðŸš« PREVENT INFINITE LOOP: Skip auto-save if already saving
        if getattr(self, '_is_saving_settings', False):
            return True
        
        # â° DEBOUNCE: Only auto-save every 2 seconds to avoid spam
        import time
        current_time = time.time()
        last_auto_save = getattr(self, '_last_auto_save_time', 0)
        
        if current_time - last_auto_save < 2.0:  # 2 second debounce
            return True  # Skip this auto-save
            
        self._last_auto_save_time = current_time
        result = self.save_risk_settings()
        if result:
            print("ðŸ”„ Auto-saved risk settings")
        return result
    
    def toggle_dca_profit_controls(self):
        """Show/hide DCA profit controls based on selected SL mode"""
        if hasattr(self, 'dca_sl_mode_combo') and hasattr(self, 'dca_avg_sl_profit_spin'):
            current_mode = self.dca_sl_mode_combo.currentText()
            is_average_mode = "SL trung bÃ¬nh" in current_mode or "Average SL" in current_mode
            
            # Show profit controls only for Average SL mode
            self.dca_avg_sl_profit_spin.setVisible(is_average_mode)
            
            # Also hide/show the label
            if hasattr(self, 'dca_avg_sl_profit_label'):
                self.dca_avg_sl_profit_label.setVisible(is_average_mode)
    
    def update_ui_from_settings(self):
        """Update UI controls from loaded settings"""
        try:
            # Force reload settings from file to ensure we have latest OFF values
            if os.path.exists("risk_management/risk_settings.json"):
                with open("risk_management/risk_settings.json", 'r', encoding='utf-8') as f:
                    file_settings = json.load(f)
                print(f"ðŸ” DEBUG update_ui_from_settings: loaded from file max_total_volume={file_settings.get('max_total_volume')}, min_risk_reward_ratio={file_settings.get('min_risk_reward_ratio')}")
            else:
                file_settings = self.settings
                
            # Set max_risk_combo value
            if hasattr(self, 'max_risk_combo'):
                current_max_risk = file_settings.get('max_risk_percent', 2.0)
                if isinstance(current_max_risk, str) and current_max_risk.upper() == "OFF":
                    self.max_risk_combo.setCurrentText("OFF")
                else:
                    self.max_risk_combo.setCurrentText(str(current_max_risk))
            
            # Set daily_loss_combo value
            if hasattr(self, 'daily_loss_combo'):
                current_daily_loss = file_settings.get('max_daily_loss_percent', 3.0)
                if current_daily_loss is None:
                    self.daily_loss_combo.setCurrentText("OFF")
                elif isinstance(current_daily_loss, str) and current_daily_loss.upper() == "OFF":
                    self.daily_loss_combo.setCurrentText("OFF")
                else:
                    self.daily_loss_combo.setCurrentText(str(current_daily_loss))
            
            self.min_lot_spin.setValue(file_settings.get('min_volume_auto', 0.01))
            if hasattr(self, 'max_lot_combo'):
                current_max_lot = file_settings.get('max_total_volume', 10.0)
                print(f"ðŸ” DEBUG updating max_lot_combo with: {current_max_lot} (type: {type(current_max_lot)})")
                if current_max_lot is None:
                    self.max_lot_combo.setCurrentText("OFF")
                    print("ðŸ” DEBUG set max_lot_combo to OFF (null value)")
                elif isinstance(current_max_lot, str) and current_max_lot.upper() == "OFF":
                    self.max_lot_combo.setCurrentText("OFF")
                    print("ðŸ” DEBUG set max_lot_combo to OFF")
                else:
                    self.max_lot_combo.setCurrentText(str(current_max_lot))
                    print(f"ðŸ” DEBUG set max_lot_combo to {current_max_lot}")
            if hasattr(self, 'min_rr_combo'):
                current_rr = file_settings.get('min_risk_reward_ratio', 1.5)
                print(f"ðŸ” DEBUG updating min_rr_combo with: {current_rr} (type: {type(current_rr)})")
                if current_rr is None:
                    self.min_rr_combo.setCurrentText("OFF")
                    print("ðŸ” DEBUG set min_rr_combo to OFF (null value)")
                elif isinstance(current_rr, str) and current_rr.upper() == "OFF":
                    self.min_rr_combo.setCurrentText("OFF")
                    print("ðŸ” DEBUG set min_rr_combo to OFF")
                else:
                    self.min_rr_combo.setCurrentText(str(current_rr))
                    print(f"ðŸ” DEBUG set min_rr_combo to {current_rr}")
            elif hasattr(self, 'min_rr_spin'):
                current_rr_val = file_settings.get('min_risk_reward_ratio', 1.5)
                if current_rr_val is not None:
                    self.min_rr_spin.setValue(current_rr_val)
            
            # Update ComboBox controls with OFF support
            if hasattr(self, 'avoid_news_combo'):
                avoid_minutes = file_settings.get('avoid_news_minutes', 30)
                if avoid_minutes is None:
                    self.avoid_news_combo.setCurrentText("OFF")
                elif isinstance(avoid_minutes, str) and avoid_minutes.upper() == "OFF":
                    self.avoid_news_combo.setCurrentText("OFF")
                else:
                    self.avoid_news_combo.setCurrentText(str(avoid_minutes))
                    
            if hasattr(self, 'emergency_dd_combo'):
                emergency_dd = file_settings.get('emergency_stop_drawdown', 10.0)
                if emergency_dd is None:
                    self.emergency_dd_combo.setCurrentText("OFF")
                elif isinstance(emergency_dd, str) and emergency_dd.upper() == "OFF":
                    self.emergency_dd_combo.setCurrentText("OFF")
                else:
                    self.emergency_dd_combo.setCurrentText(str(emergency_dd))
                    
            if hasattr(self, 'max_drawdown_combo'):
                max_dd = file_settings.get('max_drawdown_percent', 5.0)
                if max_dd is None:
                    self.max_drawdown_combo.setCurrentText("OFF")
                elif isinstance(max_dd, str) and max_dd.upper() == "OFF":
                    self.max_drawdown_combo.setCurrentText("OFF")
                else:
                    self.max_drawdown_combo.setCurrentText(str(max_dd))
            
            # Update DCA settings
            if hasattr(self, 'enable_dca_check'):
                self.enable_dca_check.setChecked(file_settings.get('enable_dca', False))
            if hasattr(self, 'max_dca_levels_spin'):
                self.max_dca_levels_spin.setValue(file_settings.get('max_dca_levels', 3))
            

                
            # Load Fibonacci level
            # (Removed Fibonacci level load)
                        
            # Update UI based on mode (call after loading values)
            # (Removed call to on_dca_mode_changed â€“ legacy)
                
            if hasattr(self, 'dca_multiplier_spin'):
                self.dca_multiplier_spin.setValue(file_settings.get('dca_volume_multiplier', 1.5))
            if hasattr(self, 'dca_mode_combo'):
                saved_mode_key = file_settings.get('dca_mode', 'fixed_multiple')
                # Map legacy labels to new keys
                legacy_map = {
                    'Bá»™i sá»‘ ATR': 'atr_multiple',
                    'Pips cá»‘ Ä‘á»‹nh': 'fixed_pips',
                    'Má»©c Fibo': 'fibo_levels',
                    'Bá»™i sá»‘ cá»‘ Ä‘á»‹nh': 'fixed_pips',
                    'Tá»± Ä‘á»™ng theo tá»· lá»‡': 'atr_multiple',
                    'Má»©c Fibonacci': 'fibo_levels'
                }
                saved_mode_key = legacy_map.get(saved_mode_key, saved_mode_key)
                for i in range(self.dca_mode_combo.count()):
                    if self.dca_mode_combo.itemData(i) == saved_mode_key:
                        self.dca_mode_combo.setCurrentIndex(i)
                        break
                # After setting mode, refresh visibility if function exists
                try:
                    if hasattr(self, 'get_current_dca_mode_key') and hasattr(self, 'dca_fibo_note'):
                        # Re-run refresh function defined inline earlier if present
                        # (Inline function not stored; emulate by toggling via mode change signal)
                        pass
                except Exception:
                    pass
            if hasattr(self, 'dca_min_drawdown_spin'):
                self.dca_min_drawdown_spin.setValue(file_settings.get('dca_min_drawdown', 1.0))
            if hasattr(self, 'dca_atr_period_spin'):
                self.dca_atr_period_spin.setValue(int(file_settings.get('dca_atr_period', 14)))
            if hasattr(self, 'dca_atr_mult_spin'):
                self.dca_atr_mult_spin.setValue(file_settings.get('dca_atr_multiplier', 1.5))
            if hasattr(self, 'dca_base_distance_spin'):
                self.dca_base_distance_spin.setValue(int(file_settings.get('dca_distance_pips', 50)))
            # New: load Fibonacci start level (migration from legacy levels list)
            if hasattr(self, 'dca_fibo_start_combo'):
                fibo_sequence = [1,1,2,3,5,8,13,21,34,55,89]
                if 'dca_fibo_start_level' in file_settings:
                    start_idx = int(file_settings.get('dca_fibo_start_level', 0))
                else:
                    # Derive from first legacy level number if present
                    legacy_levels = file_settings.get('dca_fibo_levels') or ""
                    if isinstance(legacy_levels, list):
                        parts = legacy_levels
                    else:
                        parts = [p.strip() for p in str(legacy_levels).split(',') if p.strip()]
                    start_idx = 0
                    if parts:
                        try:
                            first_val = int(float(parts[0]))
                            if first_val in fibo_sequence:
                                start_idx = fibo_sequence.index(first_val)
                        except Exception:
                            pass
                if 0 <= start_idx < self.dca_fibo_start_combo.count():
                    self.dca_fibo_start_combo.setCurrentIndex(start_idx)
            if hasattr(self, 'dca_fibo_exec_combo'):
                exec_mode = file_settings.get('dca_fibo_exec_mode')
                if exec_mode:
                    for i in range(self.dca_fibo_exec_combo.count()):
                        if self.dca_fibo_exec_combo.itemText(i) == exec_mode:
                            self.dca_fibo_exec_combo.setCurrentIndex(i)
                            break
            # Removed high confidence DCA checkbox; ignore legacy key if present
            
            if hasattr(self, 'dca_sl_mode_combo'):
                dca_sl_mode_value = file_settings.get('dca_sl_mode', 'SL trung bÃ¬nh')
                
                # ðŸ”§ BACKWARD COMPATIBILITY: Handle legacy values
                valid_modes = ["SL riÃªng láº»", "SL trung bÃ¬nh", "Individual SL", "Average SL"]
                if dca_sl_mode_value not in valid_modes:
                    if dca_sl_mode_value in ["adaptive", "Chá»‰ hÃ²a vá»‘n", "Breakeven Only", "breakeven"]:
                        dca_sl_mode_value = 'SL trung bÃ¬nh'  # Default to Average SL for removed legacy modes
                        print(f"ðŸ”§ MIGRATED removed DCA SL mode '{file_settings.get('dca_sl_mode')}' to 'SL trung bÃ¬nh'")
                
                # Find matching item in combo
                for i in range(self.dca_sl_mode_combo.count()):
                    if self.dca_sl_mode_combo.itemText(i) == dca_sl_mode_value:
                        self.dca_sl_mode_combo.setCurrentIndex(i)
                        break
            
            # ðŸ†• NEW: Load DCA Average SL Profit Percentage
            if hasattr(self, 'dca_avg_sl_profit_spin'):
                self.dca_avg_sl_profit_spin.setValue(file_settings.get('dca_avg_sl_profit_percent', 10.0))
            
            # Update Volume Management settings
            if hasattr(self, 'volume_mode_combo'):
                self.volume_mode_combo.setCurrentText(file_settings.get('volume_mode', I18N.t('Risk-Based (Auto)', 'Theo rá»§i ro (Tá»± Ä‘á»™ng)')))
                self.update_volume_mode_explanation()
            if hasattr(self, 'fixed_volume_spin'):
                self.fixed_volume_spin.setValue(file_settings.get('fixed_volume_lots', 0.10))
            if hasattr(self, 'default_volume_spin'):
                self.default_volume_spin.setValue(file_settings.get('default_volume_lots', 0.10))
            
            # Update SL/TP Mode combo
            if hasattr(self, 'sltp_mode_combo'):
                # Load sltp_mode with proper conversion
                sltp_mode_key = file_settings.get('sltp_mode', 'Bá»™i sá»‘ ATR')
                self.sltp_mode_combo.setCurrentText(self.get_sltp_mode_display_text(sltp_mode_key))
                self.update_sltp_mode_controls()  # Refresh controls based on loaded mode
            
            # ðŸ”§ FIXED: Load SL/TP values after mode is set
            if hasattr(self, 'default_sl_spin') and hasattr(self, 'default_tp_spin'):
                # Load SL value based on current mode
                current_sltp_mode = self.sltp_mode_combo.currentText() if hasattr(self, 'sltp_mode_combo') else ""
                
                print(f"ðŸ” [LOAD DEBUG] Current SL/TP mode: '{current_sltp_mode}'")
                
                if I18N.t('Fixed Pips', 'Pips cá»‘ Ä‘á»‹nh') in current_sltp_mode:
                    sl_val = file_settings.get('default_sl_pips', 50.0)
                    tp_val = file_settings.get('default_tp_pips', 100.0)
                    print(f"ðŸ” [LOAD DEBUG] Loading Pips mode: SL={sl_val}, TP={tp_val}")
                    self.default_sl_spin.setValue(sl_val)
                    self.default_tp_spin.setValue(tp_val)
                elif I18N.t('ATR Multiple', 'Bá»™i sá»‘ ATR') in current_sltp_mode:
                    sl_val = file_settings.get('default_sl_atr_multiplier', 2.0)
                    tp_val = file_settings.get('default_tp_atr_multiplier', 3.0)
                    print(f"ðŸ” [LOAD DEBUG] Loading ATR mode: SL={sl_val}, TP={tp_val}")
                    self.default_sl_spin.setValue(sl_val)
                    self.default_tp_spin.setValue(tp_val)
                elif I18N.t('Percentage', 'Pháº§n trÄƒm') in current_sltp_mode:
                    sl_val = file_settings.get('default_sl_percentage', 2.0)
                    tp_val = file_settings.get('default_tp_percentage', 4.0)
                    print(f"ðŸ” [LOAD DEBUG] Loading Percentage mode: SL={sl_val}, TP={tp_val}")
                    self.default_sl_spin.setValue(sl_val)
                    self.default_tp_spin.setValue(tp_val)
                elif I18N.t('Support/Resistance Buffer', 'Äá»‡m Há»— trá»£/KhÃ¡ng cá»±') in current_sltp_mode:
                    sl_val = file_settings.get('default_sl_buffer', 10.0)
                    tp_val = file_settings.get('default_tp_buffer', 20.0)
                    print(f"ðŸ” [LOAD DEBUG] Loading Buffer mode: SL={sl_val}, TP={tp_val}")
                    self.default_sl_spin.setValue(sl_val)
                    self.default_tp_spin.setValue(tp_val)
                else:
                    # Default to Pips mode values
                    sl_val = file_settings.get('default_sl_pips', 50.0)
                    tp_val = file_settings.get('default_tp_pips', 100.0)
                    print(f"ðŸ” [LOAD DEBUG] Loading Default (Pips) mode: SL={sl_val}, TP={tp_val}")
                    self.default_sl_spin.setValue(sl_val)
                    self.default_tp_spin.setValue(tp_val)
            
            # Update Position/Trading Hours settings
            if hasattr(self, 'max_positions_spin'):
                self.max_positions_spin.setValue(int(file_settings.get('max_positions', 5)))
            if hasattr(self, 'max_positions_per_symbol_spin'):
                self.max_positions_per_symbol_spin.setValue(int(file_settings.get('max_positions_per_symbol', 2)))
            if hasattr(self, 'max_correlation_spin'):
                self.max_correlation_spin.setValue(file_settings.get('max_correlation', 0.7))
            if hasattr(self, 'start_hour_spin'):
                self.start_hour_spin.setValue(int(file_settings.get('trading_hours_start', 0)))
            if hasattr(self, 'start_minute_spin'):
                self.start_minute_spin.setValue(int(file_settings.get('trading_minutes_start', 0)))
            if hasattr(self, 'end_hour_spin'):
                self.end_hour_spin.setValue(int(file_settings.get('trading_hours_end', 23)))
            if hasattr(self, 'end_minute_spin'):
                self.end_minute_spin.setValue(int(file_settings.get('trading_minutes_end', 59)))
            
            # Update Market Conditions settings
            if hasattr(self, 'spread_multiplier_spin'):
                self.spread_multiplier_spin.setValue(file_settings.get('max_spread_multiplier', 3.0))
            if hasattr(self, 'max_slippage_spin'):
                self.max_slippage_spin.setValue(int(file_settings.get('max_slippage', 10)))
            
            # Update other checkboxes
            if hasattr(self, 'auto_reduce_check'):
                self.auto_reduce_check.setChecked(file_settings.get('auto_reduce_on_losses', True))
            
            # Update symbol exposure table with file settings
            if hasattr(self, 'exposure_table'):
                self.populate_exposure_table(file_settings)
                    
        except Exception as e:
            print(f"âŒ Error updating UI from settings: {e}")
    
    def auto_refresh_settings(self):
        """Auto-refresh settings from file if changed by backend"""
        try:
            if os.path.exists("risk_management/risk_settings.json"):
                # Check if file was modified
                current_mtime = os.path.getmtime("risk_management/risk_settings.json")
                if not hasattr(self, '_last_settings_mtime'):
                    self._last_settings_mtime = current_mtime
                    return
                
                if current_mtime > self._last_settings_mtime:
                    # File was modified, reload settings
                    with open("risk_management/risk_settings.json", 'r', encoding='utf-8') as f:
                        self.settings = json.load(f)
                    self.update_ui_from_settings()
                    self._last_settings_mtime = current_mtime
                    print("ðŸ”„ Risk settings auto-refreshed from file")
        except Exception as e:
            print(f"âŒ Error in auto-refresh settings: {e}")
    
    def reset_to_default(self):
        """Reset all settings to default values"""
        reply = QMessageBox.question(
            self,
            I18N.t("Reset Settings", "Äáº·t láº¡i cÃ i Ä‘áº·t"),
            I18N.t("Are you sure you want to reset all settings to default values?", "Báº¡n cÃ³ cháº¯c muá»‘n Ä‘áº·t láº¡i táº¥t cáº£ cÃ i Ä‘áº·t vá» máº·c Ä‘á»‹nh?"),
            QMessageBox.Yes | QMessageBox.No
        )
        if reply == QMessageBox.Yes:
            self.settings = {}
            self.update_ui_from_settings()
            QMessageBox.information(
                self,
                I18N.t("Reset Complete", "Äáº·t láº¡i hoÃ n táº¥t"),
                I18N.t("âœ… All settings reset to default values.", "âœ… Táº¥t cáº£ cÃ i Ä‘áº·t Ä‘Ã£ Ä‘Æ°á»£c Ä‘áº·t láº¡i vá» máº·c Ä‘á»‹nh.")
            )
    
    def generate_report(self):
        """Generate comprehensive risk management report"""
        try:
            if self.risk_manager:
                report_path = self.risk_manager.save_report()
                if report_path:
                    QMessageBox.information(
                        self,
                        I18N.t("Report Generated", "ÄÃ£ táº¡o bÃ¡o cÃ¡o"),
                        I18N.t("âœ… Risk management report saved to:\n{path}", "âœ… BÃ¡o cÃ¡o quáº£n lÃ½ rá»§i ro Ä‘Ã£ lÆ°u táº¡i:\n{path}", path=report_path)
                    )
                else:
                    QMessageBox.warning(
                        self,
                        I18N.t("Report Error", "Lá»—i bÃ¡o cÃ¡o"),
                        I18N.t("âŒ Failed to generate report.", "âŒ Táº¡o bÃ¡o cÃ¡o tháº¥t báº¡i.")
                    )
            else:
                QMessageBox.warning(
                    self,
                    I18N.t("No Risk Manager", "KhÃ´ng cÃ³ trÃ¬nh quáº£n lÃ½ rá»§i ro"),
                    I18N.t("âš ï¸ Risk manager not initialized.", "âš ï¸ TrÃ¬nh quáº£n lÃ½ rá»§i ro chÆ°a Ä‘Æ°á»£c khá»Ÿi táº¡o.")
                )
                
        except Exception as e:
            QMessageBox.critical(
                self,
                I18N.t("Report Error", "Lá»—i bÃ¡o cÃ¡o"),
                I18N.t("âŒ Error generating report: {err}", "âŒ Lá»—i khi táº¡o bÃ¡o cÃ¡o: {err}", err=str(e))
            )
    
    def sync_symbols_from_market(self, connected=False):
        """Synchronize available symbols from Market Tab"""
        try:
            if connected and self.market_tab:
                # Get checked symbols from market tab
                self.available_symbols = list(self.market_tab.checked_symbols)
                print(f"ðŸ”„ Risk Management synchronized {len(self.available_symbols)} symbols from Market Tab")
                
                # Update symbol exposure settings
                for symbol in self.available_symbols:
                    if symbol not in self.settings.get('symbol_exposure', {}):
                        self.settings.setdefault('symbol_exposure', {})[symbol] = 2.0  # Default exposure
                    if symbol not in self.settings.get('symbol_multipliers', {}):
                        self.settings.setdefault('symbol_multipliers', {})[symbol] = 1.0  # Default multiplier
                
                # Update the exposure table with new symbols
                self.populate_exposure_table()
                
                # Update risk manager if available
                if self.risk_manager:
                    self.update_risk_manager_symbols()
                    
                self.save_risk_settings()
                
                # Update info label
                if hasattr(self, 'exposure_info_label'):
                    self.exposure_info_label.setText(I18N.t(
                        "âœ… Synced {n} symbols from Market Tab",
                        "âœ… ÄÃ£ Ä‘á»“ng bá»™ {n} mÃ£ tá»« tab Thá»‹ trÆ°á»ng",
                        n=len(self.available_symbols)
                    ))
                    
                print(f"âœ… Symbol synchronization completed")
            else:
                self.available_symbols = []
                self.populate_exposure_table()  # Clear table
                if hasattr(self, 'exposure_info_label'):
                    self.exposure_info_label.setText(I18N.t(
                        "âš ï¸ Please connect to MT5 and select symbols in Market Tab",
                        "âš ï¸ Vui lÃ²ng káº¿t ná»‘i MT5 vÃ  chá»n mÃ£ á»Ÿ tab Thá»‹ trÆ°á»ng"
                    ))
                print("âš ï¸ Disconnected - cleared symbol list")
                
        except Exception as e:
            print(f"âŒ Error synchronizing symbols: {e}")
    
    def populate_exposure_table(self, file_settings=None):
        """Populate exposure table with current available symbols"""
        try:
            # Use file_settings if provided, otherwise fall back to self.settings
            settings_to_use = file_settings if file_settings is not None else self.settings
            
            symbols_to_show = self.available_symbols if self.available_symbols else []
            
            self.exposure_table.setRowCount(len(symbols_to_show))
            
            if not symbols_to_show:
                # Show message when no symbols available
                self.exposure_table.setRowCount(1)
                self.exposure_table.setItem(0, 0, QTableWidgetItem(I18N.t(
                    "No symbols selected", "ChÆ°a chá»n mÃ£"
                )))
                self.exposure_table.setItem(0, 1, QTableWidgetItem("--"))
                self.exposure_table.setItem(0, 2, QTableWidgetItem("--"))
                return
            
            for i, symbol in enumerate(symbols_to_show):
                # Symbol name (read-only)
                symbol_item = QTableWidgetItem(symbol)
                symbol_item.setFlags(symbol_item.flags() & ~Qt.ItemIsEditable)  # Make read-only
                symbol_item.setBackground(Qt.lightGray)
                self.exposure_table.setItem(i, 0, symbol_item)
                
                # Max exposure spinbox
                exposure_spin = QDoubleSpinBox()
                exposure_spin.setRange(0.1, 50.0)
                exposure_spin.setSingleStep(0.1)
                exposure_spin.setValue(settings_to_use.get('symbol_exposure', {}).get(symbol, 2.0))
                exposure_spin.setToolTip(I18N.t(
                    f"Maximum exposure for {symbol} in lots",
                    I18N.t("Max volume for {sym} (lot)", "Khá»‘i lÆ°á»£ng tá»‘i Ä‘a cho {sym} (lot)", sym=symbol)
                ))
                # Connect to auto-save
                exposure_spin.valueChanged.connect(lambda value, s=symbol: self.update_symbol_exposure(s, value))
                self.exposure_table.setCellWidget(i, 1, exposure_spin)
                
                # Risk multiplier spinbox  
                multiplier_spin = QDoubleSpinBox()
                multiplier_spin.setRange(0.1, 3.0)
                multiplier_spin.setSingleStep(0.1)
                multiplier_spin.setValue(settings_to_use.get('symbol_multipliers', {}).get(symbol, 1.0))
                multiplier_spin.setToolTip(I18N.t(
                    f"Risk multiplier for {symbol} (1.0 = normal risk)",
                    f"Há»‡ sá»‘ rá»§i ro cho {symbol} (1.0 = rá»§i ro chuáº©n)"
                ))
                # Connect to auto-save
                multiplier_spin.valueChanged.connect(lambda value, s=symbol: self.update_symbol_multiplier(s, value))
                self.exposure_table.setCellWidget(i, 2, multiplier_spin)
            
            print(f"ðŸ“Š Exposure table updated with {len(symbols_to_show)} symbols")
            
        except Exception as e:
            print(f"âŒ Error populating exposure table: {e}")
    
    def on_exposure_table_changed(self, row, column):
        """Handle exposure table cell changes and auto-save"""
        try:
            if not hasattr(self, 'exposure_table') or row >= self.exposure_table.rowCount():
                return
                
            # Get symbol name from first column
            symbol_item = self.exposure_table.item(row, 0)
            if not symbol_item:
                return
                
            symbol = symbol_item.text().strip()
            # Skip placeholder symbols
            if not symbol or symbol in ["ChÆ°a chá»n mÃ£", "--", ""]:
                return
                
            changed_item = self.exposure_table.item(row, column)
            if not changed_item:
                return
                
            value_text = changed_item.text().strip()
            
            if column == 1:  # Max Exposure column
                try:
                    value = float(value_text) if value_text else 0.0
                    self.update_symbol_exposure(symbol, value)
                    print(f"ðŸ’¾ Auto-saved {symbol} exposure: {value} lots")
                except ValueError:
                    print(f"âš ï¸ Invalid exposure value for {symbol}: {value_text}")
                    return
                    
            elif column == 2:  # Risk Multiplier column
                try:
                    value = float(value_text) if value_text else 1.0
                    self.update_symbol_multiplier(symbol, value)
                    print(f"ðŸ’¾ Auto-saved {symbol} multiplier: {value}")
                except ValueError:
                    print(f"âš ï¸ Invalid multiplier value for {symbol}: {value_text}")
                    return
            
            # Trigger auto-save
            self.auto_save_risk_settings()
            
        except Exception as e:
            print(f"âŒ Error handling exposure table change: {e}")
    
    def update_symbol_exposure(self, symbol, value):
        """Update symbol exposure setting"""
        try:
            self.settings.setdefault('symbol_exposure', {})[symbol] = value
            print(f"ðŸ“Š Updated {symbol} exposure: {value} lots")
        except Exception as e:
            print(f"âŒ Error updating symbol exposure: {e}")
    
    def update_symbol_multiplier(self, symbol, value):
        """Update symbol risk multiplier setting"""
        try:
            self.settings.setdefault('symbol_multipliers', {})[symbol] = value
            print(f"ðŸŽ¯ Updated {symbol} multiplier: {value}")
        except Exception as e:
            print(f"âŒ Error updating symbol multiplier: {e}")
    
    def update_risk_manager_symbols(self):
        """Update risk manager with current symbols"""
        if not self.risk_manager:
            return
            
        try:
            # Update symbol exposure limits
            symbol_exposure = self.settings.get('symbol_exposure', {})
            symbol_multipliers = self.settings.get('symbol_multipliers', {})
            
            for symbol in self.available_symbols:
                if hasattr(self.risk_manager.risk_params, 'symbol_max_exposure'):
                    self.risk_manager.risk_params.symbol_max_exposure[symbol] = symbol_exposure.get(symbol, 1000.0)
                if hasattr(self.risk_manager.risk_params, 'symbol_risk_multipliers'):
                    self.risk_manager.risk_params.symbol_risk_multipliers[symbol] = symbol_multipliers.get(symbol, 1.0)
            
            print(f"ðŸŽ¯ Updated risk manager with {len(self.available_symbols)} symbols")
            
        except Exception as e:
            print(f"âŒ Error updating risk manager symbols: {e}")
    
    def get_available_symbols(self):
        """Get list of available symbols for trading"""
        return self.available_symbols.copy() if self.available_symbols else []
    
    def validate_signal_for_symbol(self, signal):
        """Validate a trading signal using risk management"""
        if not self.risk_manager:
            return False, "Risk manager not initialized"
            
        try:
            validation = self.risk_manager.validate_signal_comprehensive(signal)
            return validation.result == ValidationResult.APPROVED, validation
        except Exception as e:
            return False, f"Validation error: {e}"
    
    def update_sltp_mode_controls(self):
        """Update SL/TP controls based on selected mode"""
        try:
            current_mode = self.sltp_mode_combo.currentText()
            
            # Update labels and ranges based on mode
            if "ATR" in current_mode or "Bá»™i sá»‘ ATR" in current_mode:
                # ATR Mode - use multipliers - Make sure controls are visible
                self.sl_label.setVisible(True)
                self.tp_label.setVisible(True)
                self.default_sl_spin.setVisible(True)
                self.default_tp_spin.setVisible(True)
                
                self.sl_label.setText(I18N.t("SL ATR Multiplier:", "Há»‡ sá»‘ ATR cho SL:"))
                self.tp_label.setText(I18N.t("TP ATR Multiplier:", "Há»‡ sá»‘ ATR cho TP:"))
                self.default_sl_spin.setRange(0.1, 100.0)  # ATR multipliers 0.1-100.0 with decimals
                self.default_tp_spin.setRange(0.1, 100.0)
                self.default_sl_spin.setDecimals(1)  # Allow 1 decimal place for ATR multipliers
                self.default_tp_spin.setDecimals(1)
                self.default_sl_spin.setSingleStep(0.1)  # Step by 0.1
                self.default_tp_spin.setSingleStep(0.1)
                self.default_sl_spin.setValue(float(self.settings.get('default_sl_atr_multiplier', 10.0)))
                self.default_tp_spin.setValue(float(self.settings.get('default_tp_atr_multiplier', 13.0)))
                self.default_sl_spin.setSuffix("x ATR")
                self.default_tp_spin.setSuffix("x ATR")
                
            elif "Percentage" in current_mode or "Pháº§n trÄƒm" in current_mode:
                # Percentage Mode - Make sure controls are visible
                self.sl_label.setVisible(True)
                self.tp_label.setVisible(True)
                self.default_sl_spin.setVisible(True)
                self.default_tp_spin.setVisible(True)
                
                self.sl_label.setText(I18N.t("SL Percentage (%):", "SL pháº§n trÄƒm (%):"))
                self.tp_label.setText(I18N.t("TP Percentage (%):", "TP pháº§n trÄƒm (%):"))
                self.default_sl_spin.setRange(0, 100)  # 0-100%
                self.default_tp_spin.setRange(0, 100)
                self.default_sl_spin.setValue(self.settings.get('default_sl_percentage', 2))
                self.default_tp_spin.setValue(self.settings.get('default_tp_percentage', 5))
                self.default_sl_spin.setSuffix("%")
                self.default_tp_spin.setSuffix("%")
                
            elif "Support" in current_mode or "Há»— trá»£" in current_mode:
                # Support/Resistance Mode - Make sure controls are visible
                self.sl_label.setVisible(True)
                self.tp_label.setVisible(True)
                self.default_sl_spin.setVisible(True)
                self.default_tp_spin.setVisible(True)
                
                self.sl_label.setText(I18N.t("SL Buffer (pips):", "Äá»‡m SL (pips):"))
                self.tp_label.setText(I18N.t("TP Buffer (pips):", "Äá»‡m TP (pips):"))
                self.default_sl_spin.setRange(0, 1000)  # Buffer in pips
                self.default_tp_spin.setRange(0, 1000)
                self.default_sl_spin.setValue(self.settings.get('default_sl_buffer', 10))
                self.default_tp_spin.setValue(self.settings.get('default_tp_buffer', 10))
                self.default_sl_spin.setSuffix(" pips")
                self.default_tp_spin.setSuffix(" pips")
                
            elif "Signal" in current_mode or "Theo Signal" in current_mode or "Theo TÃ­n hiá»‡u" in current_mode:
                # Signal Based Mode - Hide SL/TP controls since they come from signal
                self.sl_label.setVisible(False)
                self.tp_label.setVisible(False)
                self.default_sl_spin.setVisible(False)
                self.default_tp_spin.setVisible(False)
                
            else:
                # Fixed Pips Mode (default) - Make sure controls are visible
                self.sl_label.setVisible(True)
                self.tp_label.setVisible(True)
                self.default_sl_spin.setVisible(True)
                self.default_tp_spin.setVisible(True)
                
                self.sl_label.setText(I18N.t("Default SL (pips):", "SL máº·c Ä‘á»‹nh (pips):"))
                self.tp_label.setText(I18N.t("Default TP (pips):", "TP máº·c Ä‘á»‹nh (pips):"))
                self.default_sl_spin.setRange(0, 10000)  # Pips
                self.default_tp_spin.setRange(0, 50000)
                self.default_sl_spin.setValue(self.settings.get('default_sl_pips', 50))
                self.default_tp_spin.setValue(self.settings.get('default_tp_pips', 100))
                self.default_sl_spin.setSuffix(" pips")
                self.default_tp_spin.setSuffix(" pips")
                
        except Exception as e:
            print(f"âŒ Error updating SL/TP mode controls: {e}")
            
    def get_sltp_mode_key(self):
        """Convert display text to standardized key for sltp_mode"""
        try:
            current_text = self.sltp_mode_combo.currentText()
            
            # Map display text to standardized keys
            mode_mapping = {
                # English to key
                "Fixed Pips": "Pips cá»‘ Ä‘á»‹nh",
                "ATR Multiple": "Bá»™i sá»‘ ATR", 
                "Support/Resistance": "Há»— trá»£/KhÃ¡ng cá»±",
                "Percentage": "Pháº§n trÄƒm",
                "Signal Based": "Theo Signal",
                # Vietnamese to key (keep as is)
                "Pips cá»‘ Ä‘á»‹nh": "Pips cá»‘ Ä‘á»‹nh",
                "Bá»™i sá»‘ ATR": "Bá»™i sá»‘ ATR",
                "Há»— trá»£/KhÃ¡ng cá»±": "Há»— trá»£/KhÃ¡ng cá»±", 
                "Pháº§n trÄƒm": "Pháº§n trÄƒm",
                "Theo Signal": "Theo Signal",
                "Theo TÃ­n hiá»‡u": "Theo Signal"
            }
            
            return mode_mapping.get(current_text, "Pips cá»‘ Ä‘á»‹nh")  # Default fallback
        except Exception as e:
            print(f"âŒ Error getting sltp mode key: {e}")
            return "Pips cá»‘ Ä‘á»‹nh"  # Safe fallback
            
    def get_sltp_mode_display_text(self, key):
        """Convert standardized key to display text for sltp_mode"""
        try:
            # Map keys to display text (always use Vietnamese)
            key_to_display = {
                "Pips cá»‘ Ä‘á»‹nh": I18N.t("Fixed Pips", "Pips cá»‘ Ä‘á»‹nh"),
                "Bá»™i sá»‘ ATR": I18N.t("ATR Multiple", "Bá»™i sá»‘ ATR"),
                "Há»— trá»£/KhÃ¡ng cá»±": I18N.t("Support/Resistance", "Há»— trá»£/KhÃ¡ng cá»±"),
                "Pháº§n trÄƒm": I18N.t("Percentage", "Pháº§n trÄƒm"),
                "Theo Signal": I18N.t("Signal Based", "Theo Signal"),
                # Handle backward compatibility with English keys
                "Fixed Pips": I18N.t("Fixed Pips", "Pips cá»‘ Ä‘á»‹nh"),
                "ATR Multiple": I18N.t("ATR Multiple", "Bá»™i sá»‘ ATR"),
                "Support/Resistance": I18N.t("Support/Resistance", "Há»— trá»£/KhÃ¡ng cá»±"),
                "Percentage": I18N.t("Percentage", "Pháº§n trÄƒm"),
                "Signal Based": I18N.t("Signal Based", "Theo Signal")
            }
            
            return key_to_display.get(key, I18N.t("ATR Multiple", "Bá»™i sá»‘ ATR"))  # Default to ATR
            
        except Exception as e:
            print(f"âŒ Error getting sltp mode display: {e}")
            return I18N.t("ATR Multiple", "Bá»™i sá»‘ ATR")
    
    def _comprehensive_clean_settings(self, settings_dict):
        """
        ðŸ§¹ COMPREHENSIVE SETTINGS CLEANING - Only keep fields needed by current modes
        
        This method analyzes all mode settings and removes conflicting/unused fields:
        - OFF values cleanup
        - Volume mode conflicts  
        - SL/TP mode conflicts
        - DCA mode conflicts
        - Trading mode conflicts
        - Auto vs Manual mode conflicts
        
        Args:
            settings_dict: Raw settings dictionary from GUI
            
        Returns:
            Dict: Cleaned settings with only required fields for current modes
        """
        try:
            # Load existing settings from file to preserve all fields initially
            existing_settings = {}
            settings_file = "risk_management/risk_settings.json"
            
            if os.path.exists(settings_file):
                try:
                    with open(settings_file, 'r', encoding='utf-8') as f:
                        existing_settings = json.load(f)
                    print(f"ðŸ”„ Loaded {len(existing_settings)} existing settings from file")
                except Exception as e:
                    print(f"âš ï¸ Could not load existing settings: {e}")
            
            # Start with ALL existing settings to preserve everything initially
            cleaned = existing_settings.copy()
            
            print(f"ðŸ§¹ COMPREHENSIVE CLEANING - Starting with {len(cleaned)} existing settings")
            
            # Update with current GUI settings first
            off_fields_to_check = [
                'max_daily_loss_percent', 'max_weekly_loss_percent', 'max_monthly_loss_percent',
                'emergency_stop_daily_loss', 'min_confidence_threshold', 'high_confidence_threshold',
                'avoid_news_minutes', 'max_total_volume', 'min_risk_reward_ratio', 'emergency_stop_drawdown',
                'min_volume_auto'
            ]
            
            off_count = 0
            updated_count = 0
            
            # Process all GUI settings first
            for key, value in settings_dict.items():
                # Check if this field can be OFF and is currently OFF
                if key in off_fields_to_check:
                    if value in ["OFF", "Táº®T"] or str(value) in ["OFF", "Táº®T"]:
                        # Remove OFF field from settings (if it exists)
                        if key in cleaned:
                            del cleaned[key]
                            print(f"   ðŸš« Removed OFF field: {key}")
                            off_count += 1
                        continue
                
                # Update/add all other settings from GUI
                cleaned[key] = value
                if key not in existing_settings or existing_settings.get(key) != value:
                    updated_count += 1

            # GET CURRENT MODES
            volume_mode = cleaned.get('volume_mode', '')
            sltp_mode = cleaned.get('sltp_mode', '')
            enable_dca = cleaned.get('enable_dca', False)
            dca_mode = cleaned.get('dca_mode', '')
            
            print(f"ðŸ“‹ CURRENT MODES:")
            print(f"   Volume: '{volume_mode}'") 
            print(f"   SL/TP: '{sltp_mode}'")
            print(f"   DCA Enabled: {enable_dca}")
            print(f"   DCA Mode: '{dca_mode}'")
            
            total_removed = 0
            
            # 1. ðŸŽ¯ SL/TP MODE CLEANUP
            sltp_cleanup_count = 0
            print(f"\nðŸŽ¯ SL/TP MODE CLEANUP:")
            
            if sltp_mode in ["Bá»™i sá»‘ ATR", "ATR Multiple", "atr_multiplier"]:
                # ATR mode: remove Pips and Percentage fields
                fields_to_remove = [
                    'default_sl_pips', 'default_tp_pips',           # Pips mode fields
                    'default_sl_percentage', 'default_tp_percentage', # Percentage mode fields
                    'default_sl_buffer', 'default_tp_buffer'         # Buffer fields (unused)
                ]
                
                for field in fields_to_remove:
                    if field in cleaned:
                        del cleaned[field]
                        print(f"   ðŸš« Removed '{field}' (ATR mode)")
                        sltp_cleanup_count += 1
                
                # Ensure ATR fields exist
                if 'default_sl_atr_multiplier' not in cleaned:
                    cleaned['default_sl_atr_multiplier'] = 2.0
                    print(f"   âœ… Added 'default_sl_atr_multiplier': 2.0")
                    
                if 'default_tp_atr_multiplier' not in cleaned:
                    cleaned['default_tp_atr_multiplier'] = 1.5
                    print(f"   âœ… Added 'default_tp_atr_multiplier': 1.5")
            
            elif sltp_mode in ["Pips", "Fixed Pips", "pips"]:
                # Pips mode: remove ATR and Percentage fields
                fields_to_remove = [
                    'default_sl_atr_multiplier', 'default_tp_atr_multiplier', # ATR mode fields
                    'default_sl_percentage', 'default_tp_percentage',         # Percentage mode fields
                    'default_sl_buffer', 'default_tp_buffer'                 # Buffer fields (unused)
                ]
                
                for field in fields_to_remove:
                    if field in cleaned:
                        del cleaned[field]
                        print(f"   ðŸš« Removed '{field}' (Pips mode)")
                        sltp_cleanup_count += 1
                
                # Ensure Pips fields exist
                if 'default_sl_pips' not in cleaned:
                    cleaned['default_sl_pips'] = 50.0
                    print(f"   âœ… Added 'default_sl_pips': 50.0")
                    
                if 'default_tp_pips' not in cleaned:
                    cleaned['default_tp_pips'] = 100.0
                    print(f"   âœ… Added 'default_tp_pips': 100.0")
            
            elif sltp_mode in ["Percentage", "%", "percentage"]:
                # Percentage mode: remove ATR and Pips fields
                fields_to_remove = [
                    'default_sl_pips', 'default_tp_pips',                   # Pips mode fields
                    'default_sl_atr_multiplier', 'default_tp_atr_multiplier', # ATR mode fields
                    'default_sl_buffer', 'default_tp_buffer'                 # Buffer fields (unused)
                ]
                
                for field in fields_to_remove:
                    if field in cleaned:
                        del cleaned[field]
                        print(f"   ðŸš« Removed '{field}' (Percentage mode)")
                        sltp_cleanup_count += 1
                
                # Ensure Percentage fields exist
                if 'default_sl_percentage' not in cleaned:
                    cleaned['default_sl_percentage'] = 2.0
                    print(f"   âœ… Added 'default_sl_percentage': 2.0")
                    
                if 'default_tp_percentage' not in cleaned:
                    cleaned['default_tp_percentage'] = 1.5
                    print(f"   âœ… Added 'default_tp_percentage': 1.5")
            
            # Always remove buffer fields (not used in any mode)
            buffer_fields = ['default_sl_buffer', 'default_tp_buffer']
            for field in buffer_fields:
                if field in cleaned:
                    del cleaned[field]
                    print(f"   ðŸš« Removed '{field}' (buffer fields not used)")
                    sltp_cleanup_count += 1
            
            total_removed += sltp_cleanup_count
            
            # 2. ðŸŽ¯ VOLUME MODE CLEANUP
            volume_cleanup_count = 0
            print(f"\nðŸŽ¯ VOLUME MODE CLEANUP:")
            
            if volume_mode in ["Khá»‘i lÆ°á»£ng máº·c Ä‘á»‹nh", "Default Volume", "default"]:
                # Default Volume mode: remove fixed_volume_lots if present
                if 'fixed_volume_lots' in cleaned:
                    del cleaned['fixed_volume_lots']
                    print(f"   ðŸš« Removed 'fixed_volume_lots' (Default Volume mode)")
                    volume_cleanup_count += 1
                
                # Ensure default_volume_lots exists
                if 'default_volume_lots' not in cleaned:
                    cleaned['default_volume_lots'] = 0.15  # Default value
                    print(f"   âœ… Added 'default_volume_lots': 0.15")
                    
            elif volume_mode in ["Khá»‘i lÆ°á»£ng cá»‘ Ä‘á»‹nh", "Fixed Volume", "fixed"]:
                # Fixed Volume mode: remove default_volume_lots if present
                if 'default_volume_lots' in cleaned:
                    del cleaned['default_volume_lots']
                    print(f"   ðŸš« Removed 'default_volume_lots' (Fixed Volume mode)")
                    volume_cleanup_count += 1
                
                # Ensure fixed_volume_lots exists
                if 'fixed_volume_lots' not in cleaned:
                    cleaned['fixed_volume_lots'] = 0.1  # Default value
                    print(f"   âœ… Added 'fixed_volume_lots': 0.1")
            
            total_removed += volume_cleanup_count
            
            # 3. ðŸŽ¯ DCA MODE CLEANUP  
            dca_cleanup_count = 0
            print(f"\nðŸŽ¯ DCA MODE CLEANUP:")
            
            if not enable_dca:
                # DCA disabled: remove ALL DCA fields except enable_dca
                dca_fields_to_remove = [
                    'max_dca_levels', 'dca_mode', 'dca_mode_legacy',
                    'dca_atr_period', 'dca_atr_multiplier', 'dca_distance_pips',
                    'dca_fibo_start_level', 'dca_fibo_levels', 'dca_fibo_exec_mode',
                    'dca_volume_multiplier', 'dca_min_drawdown', 'dca_sl_mode',
                    'dca_avg_sl_profit_percent'
                ]
                
                for field in dca_fields_to_remove:
                    if field in cleaned:
                        del cleaned[field]
                        print(f"   ðŸš« Removed '{field}' (DCA disabled)")
                        dca_cleanup_count += 1
            
            elif enable_dca:
                print(f"   ðŸ“‹ DCA enabled with mode: '{dca_mode}'")
                
                if dca_mode in ["atr_multiple", "Bá»™i sá»‘ ATR"]:
                    # ATR Multiple DCA: remove Pips and Fibonacci fields
                    dca_fields_to_remove = [
                        'dca_distance_pips',                    # Pips mode field
                        'dca_fibo_start_level', 'dca_fibo_levels', 'dca_fibo_exec_mode'  # Fibonacci fields
                    ]
                    
                    for field in dca_fields_to_remove:
                        if field in cleaned:
                            del cleaned[field]
                            print(f"   ðŸš« Removed '{field}' (ATR DCA mode)")
                            dca_cleanup_count += 1
                    
                    # Ensure ATR DCA fields exist
                    if 'dca_atr_period' not in cleaned:
                        cleaned['dca_atr_period'] = 14
                        print(f"   âœ… Added 'dca_atr_period': 14")
                    if 'dca_atr_multiplier' not in cleaned:
                        cleaned['dca_atr_multiplier'] = 0.5
                        print(f"   âœ… Added 'dca_atr_multiplier': 0.5")
                
                elif dca_mode in ["fixed_distance", "Khoáº£ng cÃ¡ch cá»‘ Ä‘á»‹nh"]:
                    # Fixed Distance DCA: remove ATR and Fibonacci fields
                    dca_fields_to_remove = [
                        'dca_atr_period', 'dca_atr_multiplier', # ATR mode fields
                        'dca_fibo_start_level', 'dca_fibo_levels', 'dca_fibo_exec_mode'  # Fibonacci fields
                    ]
                    
                    for field in dca_fields_to_remove:
                        if field in cleaned:
                            del cleaned[field]
                            print(f"   ðŸš« Removed '{field}' (Fixed Distance DCA mode)")
                            dca_cleanup_count += 1
                    
                    # Ensure Fixed Distance DCA fields exist
                    if 'dca_distance_pips' not in cleaned:
                        cleaned['dca_distance_pips'] = 50.0
                        print(f"   âœ… Added 'dca_distance_pips': 50.0")
                
                elif dca_mode in ["fibonacci_levels", "Má»©c Fibonacci"]:
                    # Fibonacci DCA: remove ATR and Fixed Distance fields
                    dca_fields_to_remove = [
                        'dca_atr_period', 'dca_atr_multiplier', # ATR mode fields
                        'dca_distance_pips'                     # Fixed Distance field
                    ]
                    
                    for field in dca_fields_to_remove:
                        if field in cleaned:
                            del cleaned[field]
                            print(f"   ðŸš« Removed '{field}' (Fibonacci DCA mode)")
                            dca_cleanup_count += 1
                    
                    # Ensure Fibonacci DCA fields exist
                    if 'dca_fibo_start_level' not in cleaned:
                        cleaned['dca_fibo_start_level'] = 0
                        print(f"   âœ… Added 'dca_fibo_start_level': 0")
                    if 'dca_fibo_levels' not in cleaned:
                        cleaned['dca_fibo_levels'] = "23.6,38.2,50,61.8,78.6"
                        print(f"   âœ… Added 'dca_fibo_levels': default")
                    if 'dca_fibo_exec_mode' not in cleaned:
                        cleaned['dca_fibo_exec_mode'] = "Cháº¡m Má»©c (Market)"
                        print(f"   âœ… Added 'dca_fibo_exec_mode': Market")
            
            total_removed += dca_cleanup_count
            
            # 5. ðŸŽ¯ EMERGENCY/NEWS CLEANUP
            emergency_cleanup_count = 0
            print(f"\nðŸŽ¯ EMERGENCY/NEWS CLEANUP:")
            
            # Remove fields that have disable flags set to True
            disable_flags = {
                'disable_news_avoidance': ['avoid_news_minutes'],
                'disable_emergency_stop': ['emergency_stop_drawdown'],
                'disable_max_dd_close': ['max_drawdown_close_percent']
            }
            
            for disable_flag, related_fields in disable_flags.items():
                if cleaned.get(disable_flag, False):  # If disabled
                    for field in related_fields:
                        if field in cleaned:
                            del cleaned[field]
                            print(f"   ðŸš« Removed '{field}' ({disable_flag}=True)")
                            emergency_cleanup_count += 1
            
            total_removed += emergency_cleanup_count
            
            # FINAL SUMMARY
            print(f"\nðŸ§¹ COMPREHENSIVE CLEANING COMPLETE:")
            print(f"   ðŸ“Š Starting fields: {len(cleaned) + total_removed}")
            print(f"   âœ… Updated from GUI: {updated_count}")
            print(f"   ðŸš« Removed OFF fields: {off_count}")
            print(f"   ðŸŽ¯ SL/TP cleanup: {sltp_cleanup_count}")
            print(f"   ðŸŽ¯ Volume cleanup: {volume_cleanup_count}")
            print(f"   ðŸŽ¯ DCA cleanup: {dca_cleanup_count}")
            print(f"   ðŸŽ¯ Emergency cleanup: {emergency_cleanup_count}")
            print(f"   ðŸ“Š Final fields: {len(cleaned)}")
            print(f"   ðŸš« Total removed: {total_removed}")
            
            return cleaned
            
        except Exception as e:
            print(f"âŒ Error in comprehensive cleaning: {e}")
            return settings_dict  # Return original if cleaning fails

class AutoTradingTab(QWidget):
    def __init__(self, news_tab=None, risk_tab=None, signal_tab=None):
        super().__init__()
        self.news_tab = news_tab  # Reference to news tab for economic calendar setting
        self.risk_tab = risk_tab  # Reference to risk management tab
        self.signal_tab = signal_tab  # Reference to signal tab for AI model selection
        
        # ðŸ”’ Thread-safe lock to prevent race condition in start_auto
        self._start_lock = threading.Lock()
        
        layout = QVBoxLayout()
        
        # Auto Trading Control
        self.auto_btn = QPushButton(I18N.t("Auto Trading: OFF", "Giao dá»‹ch tá»± Ä‘á»™ng: Táº®T"))
        self.auto_btn.setCheckable(True)
        self.auto_btn.toggled.connect(self.toggle_auto)
        layout.addWidget(self.auto_btn)

        self.start_btn = QPushButton(I18N.t("Start Auto Trading", "Báº¯t Ä‘áº§u giao dá»‹ch tá»± Ä‘á»™ng"))
        self.start_btn.setEnabled(False)
        self.start_btn.clicked.connect(self.start_auto)
        layout.addWidget(self.start_btn)

        # Status Label for Auto Trading
        self.status_label = QLabel(I18N.t("âšª Status: Not Started", "âšª Tráº¡ng thÃ¡i: ChÆ°a khá»Ÿi Ä‘á»™ng"))
        self.status_label.setStyleSheet("""
            QLabel {
                padding: 10px;
                border: 2px solid #ddd;
                border-radius: 6px;
                background-color: #f9f9f9;
                font-size: 14px;
                font-weight: bold;
                color: #666;
            }
        """)
        layout.addWidget(self.status_label)

        # Progress Log (scrollable text area)
        self.progress_log = QTextEdit()
        self.progress_log.setMaximumHeight(200)
        self.progress_log.setStyleSheet("""
            QTextEdit {
                background-color: #f5f5f5;
                border: 1px solid #ccc;
                border-radius: 4px;
                font-family: 'Courier New', monospace;
                font-size: 11px;
                padding: 5px;
            }
        """)
        self.progress_log.setPlaceholderText(I18N.t("ðŸ“‹ Activity log will be displayed here...", "ðŸ“‹ Nháº­t kÃ½ hoáº¡t Ä‘á»™ng sáº½ hiá»ƒn thá»‹ á»Ÿ Ä‘Ã¢y..."))
        self.activity_log_label = QLabel(I18N.t("ðŸ“‹ Activity Log:", "ðŸ“‹ Nháº­t kÃ½ hoáº¡t Ä‘á»™ng:"))
        layout.addWidget(self.activity_log_label)
        layout.addWidget(self.progress_log)

        self.setLayout(layout)
        self.auto_manager = None
        self.main_window_ref = None  # Store main window reference

    def refresh_translations(self):
        """Refresh all UI text when language changes"""
        try:
            # Update button texts based on current state
            if hasattr(self, 'auto_btn'):
                if self.auto_btn.isChecked():
                    self.auto_btn.setText(I18N.t("Auto Trading: ON", "Giao dá»‹ch tá»± Ä‘á»™ng: Báº¬T"))
                else:
                    self.auto_btn.setText(I18N.t("Auto Trading: OFF", "Giao dá»‹ch tá»± Ä‘á»™ng: Táº®T"))
            
            if hasattr(self, 'start_btn'):
                self.start_btn.setText(I18N.t("Start Auto Trading", "Báº¯t Ä‘áº§u giao dá»‹ch tá»± Ä‘á»™ng"))
            
            if hasattr(self, 'activity_log_label'):
                self.activity_log_label.setText(I18N.t("ðŸ“‹ Activity Log:", "ðŸ“‹ Nháº­t kÃ½ hoáº¡t Ä‘á»™ng:"))
            
            if hasattr(self, 'progress_log'):
                self.progress_log.setPlaceholderText(I18N.t("ðŸ“‹ Activity log will be displayed here...", "ðŸ“‹ Nháº­t kÃ½ hoáº¡t Ä‘á»™ng sáº½ hiá»ƒn thá»‹ á»Ÿ Ä‘Ã¢y..."))
            
            # Only update status label if it shows the initial "Not Started" message
            if hasattr(self, 'status_label'):
                current_text = self.status_label.text()
                if "Not Started" in current_text or "ChÆ°a khá»Ÿi Ä‘á»™ng" in current_text:
                    self.status_label.setText(I18N.t("âšª Status: Not Started", "âšª Tráº¡ng thÃ¡i: ChÆ°a khá»Ÿi Ä‘á»™ng"))
        except Exception as e:
            print(f"[LangSwitch] AutoTradingTab refresh error: {e}")

    def set_main_window_reference(self, main_window):
        """Set main window reference Ä‘á»ƒ auto trading cÃ³ thá»ƒ access cÃ¡c tab"""
        self.main_window_ref = main_window
        print(f"[DEBUG] Main window reference set: {type(main_window)}")
        print(f"[DEBUG] Market tab available: {hasattr(main_window, 'market_tab')}")
        print(f"[DEBUG] Tab widget available: {hasattr(main_window, 'tabWidget')}")

    def update_status(self, message):
        """Update status label with message - thread safe"""
        try:
            def _update():
                if hasattr(self, 'status_label'):
                    # Determine color based on message content
                    if "âŒ" in message or "error" in message.lower() or "fail" in message.lower():
                        color = "#d32f2f"  # Red
                        bg_color = "#ffebee"
                        border_color = "#f44336"
                    elif "âœ…" in message or "success" in message.lower() or "complete" in message.lower():
                        color = "#388e3c"  # Green  
                        bg_color = "#e8f5e8"
                        border_color = "#4caf50"
                    elif "ðŸ”„" in message or "loading" in message.lower() or "running" in message.lower():
                        color = "#1976d2"  # Blue
                        bg_color = "#e3f2fd"
                        border_color = "#2196f3"
                    else:
                        color = "#666"  # Default
                        bg_color = "#f9f9f9"
                        border_color = "#ddd"
                    
                    self.status_label.setText(message)
                    self.status_label.setStyleSheet(f"""
                        QLabel {{
                            padding: 10px;
                            border: 2px solid {border_color};
                            border-radius: 6px;
                            background-color: {bg_color};
                            font-size: 14px;
                            font-weight: bold;
                            color: {color};
                        }}
                    """)
                    self.status_label.repaint()  # Force repaint

            # Use QTimer to ensure thread safety
            from PyQt5.QtCore import QTimer
            QTimer.singleShot(0, _update)
            
        except Exception as e:
            print(f"Error updating status: {e}")

    def add_log(self, message):
        """Add message to progress log - thread safe"""
        try:
            def _add_log():
                if hasattr(self, 'progress_log'):
                    from datetime import datetime
                    timestamp = datetime.now().strftime("%H:%M:%S")
                    formatted_message = f"[{timestamp}] {message}"
                    self.progress_log.append(formatted_message)
                    
                    # Auto scroll to bottom
                    cursor = self.progress_log.textCursor()
                    cursor.movePosition(cursor.End)
                    self.progress_log.setTextCursor(cursor)
                    self.progress_log.repaint()  # Force repaint

            # Use QTimer to ensure thread safety
            from PyQt5.QtCore import QTimer
            QTimer.singleShot(0, _add_log)
            
        except Exception as e:
            print(f"Error adding log: {e}")

    def update_gui_status(self, message):
        """Update both status and log - for auto trading manager to call"""
        print(f"[GUI UPDATE] {message}")  # Debug print
        self.update_status(message)
        self.add_log(message)
        
        # Force process events to update GUI immediately
        try:
            from PyQt5.QtWidgets import QApplication
            QApplication.processEvents()
        except Exception as e:
            print(f"Error processing events: {e}")

    # ðŸ”§ FIX: Add missing method aliases for unified_auto_trading_system.py
    def update_auto_trading_status(self, message):
        """Alias for update_status - used by UnifiedAutoTradingSystem"""
        self.update_status(message)
    
    def add_auto_trading_log(self, message):
        """Alias for add_log - used by UnifiedAutoTradingSystem"""
        self.add_log(message)

    def closeEvent(self, event):
        """Handle close event to cleanup threads properly - improved version"""
        try:
            print("[CLEANUP] AutoTradingTab closing - stopping auto trading...")
            
            # Force stop with aggressive cleanup
            if hasattr(self, 'auto_manager') and self.auto_manager:
                print("[CLEANUP] Force stopping auto manager...")
                try:
                    # Set shutdown flag immediately
                    if hasattr(self.auto_manager, '_shutdown_event'):
                        self.auto_manager._shutdown_event.set()
                    if hasattr(self.auto_manager, 'is_running'):
                        self.auto_manager.is_running = False
                    
                    # Try normal stop with short timeout
                    import threading
                    import time
                    
                    def force_stop():
                        try:
                            self.auto_manager.stop()
                        except Exception as e:
                            print(f"[CLEANUP] Exception during stop: {e}")
                    
                    stop_thread = threading.Thread(target=force_stop, daemon=True)
                    stop_thread.start()
                    stop_thread.join(timeout=3)  # Short timeout on close
                    
                    if stop_thread.is_alive():
                        print("[CLEANUP] Stop timed out - forcing cleanup")
                    
                except Exception as e:
                    print(f"[CLEANUP] Exception during force stop: {e}")
                finally:
                    # Always clear the reference
                    self.auto_manager = None
                    print("[CLEANUP] Auto manager reference cleared")
            
            # Call parent stop_auto for any remaining cleanup
            try:
                self.stop_auto()
            except Exception as e:
                print(f"[CLEANUP] Exception in stop_auto: {e}")
            
            print("[CLEANUP] AutoTradingTab cleanup completed")
            
        except Exception as e:
            print(f"[CLEANUP] Error during AutoTradingTab cleanup: {e}")
            import traceback
            print(f"[CLEANUP] Traceback: {traceback.format_exc()}")
        finally:
            # Always accept the close event
            event.accept()

    # === AI Model Selection Methods - Delegate to SignalTab ===
    def _get_selected_ai_model(self):
        """Get currently selected AI model from SignalTab"""
        if hasattr(self, 'signal_tab') and self.signal_tab:
            return self.signal_tab._get_selected_ai_model()
        return "aggregator"  # Default
    
    def _get_ai_server_url(self):
        """Get AI Server URL from SignalTab"""
        if hasattr(self, 'signal_tab') and self.signal_tab:
            return self.signal_tab._get_ai_server_url()
        return None  # Default - local mode
    
    def _get_ai_model_port(self):
        """Get AI model port from SignalTab"""
        if hasattr(self, 'signal_tab') and self.signal_tab:
            return self.signal_tab._get_ai_model_port()
        return 0  # Default - local mode

    def _check_ai_server_status(self):
        """Check AI Server status via SignalTab"""
        if hasattr(self, 'signal_tab') and self.signal_tab:
            self.signal_tab._check_ai_server_status()
    
    def _get_ai_server_status_text(self):
        """Get AI Server status text from SignalTab"""
        if hasattr(self, 'signal_tab') and self.signal_tab:
            if hasattr(self.signal_tab, 'ai_server_status'):
                return self.signal_tab.ai_server_status.text()
        return "ðŸ”´ Offline"

    def toggle_auto(self, checked):
        # ========== LICENSE CHECK ==========
        # Kiá»ƒm tra license trÆ°á»›c khi cho phÃ©p báº­t Auto Trading
        if checked and not check_license_for_service(self, "Auto Trading"):
            # Reset the button state if license check fails
            self.auto_btn.setChecked(False)
            return
        # ========== END LICENSE CHECK ==========
        
        if checked:
            self.auto_btn.setText(I18N.t("Auto Trading: ON", "Giao dá»‹ch tá»± Ä‘á»™ng: Báº¬T"))
            self.start_btn.setEnabled(True)
        else:
            self.auto_btn.setText(I18N.t("Auto Trading: OFF", "Giao dá»‹ch tá»± Ä‘á»™ng: Táº®T"))
            self.start_btn.setEnabled(False)
            self.stop_auto()

    def start_auto(self):
        # ðŸ”’ Thread-safe protection against race condition
        with self._start_lock:
            try:
                # Check if already running (double-click protection)
                if hasattr(self, 'auto_manager') and self.auto_manager is not None:
                    self.add_log(I18N.t("âš ï¸ Auto Trading already running - ignoring duplicate request", "âš ï¸ Auto Trading Ä‘Ã£ Ä‘ang cháº¡y - bá» qua yÃªu cáº§u duplicate"))
                    return
                
                # ðŸ¤– Check AI Model Selection (from SignalTab)
                ai_model = self._get_selected_ai_model()
                model_port = self._get_ai_model_port()
                use_ai_server = (ai_model != "aggregator")
                
                # DEBUG: Print selection details
                print(f"[AI DEBUG] _get_selected_ai_model() returned: '{ai_model}'")
                print(f"[AI DEBUG] model_port: {model_port}")
                print(f"[AI DEBUG] use_ai_server: {use_ai_server}")
                
                model_labels = {"aggregator": "Aggregator (Local)", "xgboost": "XGBoost AI", "cnn_lstm": "CNN-LSTM Pro", "transformer": "Transformer Pro"}
                model_label = model_labels.get(ai_model, ai_model)
                
                if use_ai_server:
                    # Check AI Server connection first
                    self._check_ai_server_status()
                    status_text = self._get_ai_server_status_text()
                    if "Cannot" in status_text or "Error" in status_text or "Timeout" in status_text:
                        self.add_log(f"âŒ AI Server is not available: {status_text}")
                        QMessageBox.warning(
                            self,
                            I18N.t("AI Server Unavailable", "MÃ¡y chá»§ AI khÃ´ng kháº£ dá»¥ng"),
                            I18N.t(
                                f"Cannot connect to {model_label} server on port {model_port}!\n\nPlease check:\n1. AI Server is running\n2. Correct model is started\n\nOr select 'Aggregator (Local)' in Signal Tab to use local analysis.",
                                f"KhÃ´ng thá»ƒ káº¿t ná»‘i Ä‘áº¿n server {model_label} trÃªn port {model_port}!\n\nVui lÃ²ng kiá»ƒm tra:\n1. AI Server Ä‘ang cháº¡y\n2. Model Ä‘Ãºng Ä‘Ã£ Ä‘Æ°á»£c khá»Ÿi Ä‘á»™ng\n\nHoáº·c chá»n 'Tá»•ng há»£p (Local)' á»Ÿ tab Signal Ä‘á»ƒ dÃ¹ng phÃ¢n tÃ­ch local."
                            )
                        )
                        return
                    self.add_log(f"ðŸ¤– Using {model_label} on port {model_port}")
                else:
                    self.add_log("ðŸ¤– Using Aggregator (Local) - comprehensive_aggregator.py")
                
                # Use unified auto trading system
                from unified_auto_trading_system import UnifiedAutoTradingSystem as AutoTradingManager
                self.add_log("ðŸ“¦ Using UnifiedAutoTradingSystem")
                
                # Update status
                self.update_status(I18N.t("ðŸ”„ Starting Auto Trading...", "ðŸ”„ Äang khá»Ÿi Ä‘á»™ng Auto Trading..."))
                self.add_log(I18N.t("ðŸš€ Starting Auto Trading system", "ðŸš€ Báº¯t Ä‘áº§u khá»Ÿi Ä‘á»™ng há»‡ thá»‘ng Auto Trading"))
                
                # Kiá»ƒm tra economic calendar setting
                economic_status = self.get_economic_calendar_status()
                use_calendar = self.is_economic_calendar_enabled()
                
                # Hiá»ƒn thá»‹ thÃ´ng bÃ¡o
                icon_path = os.path.join("images", "robot.png")
                msg = QMessageBox(self)
                msg.setWindowTitle(I18N.t("Auto Trading", "Giao dá»‹ch Tá»± Ä‘á»™ng"))
            
                # Táº¡o thÃ´ng bÃ¡o chi tiáº¿t
                if AppState.language() == 'vi':
                    message = f"[AUTO TRADING] Khá»Ÿi Ä‘á»™ng Giao dá»‹ch Tá»± Ä‘á»™ng!\n\n"
                    message += f"Há»‡ thá»‘ng sáº½ tá»± Ä‘á»™ng:\n"
                    message += f"1. Láº¥y Dá»¯ liá»‡u Thá»‹ trÆ°á»ng (náº¿u tab báº­t)\n"
                    message += f"2. TÃ­nh PhÃ¢n tÃ­ch Xu hÆ°á»›ng (náº¿u tab báº­t)\n"
                    message += f"3. TÃ­nh Chá»‰ bÃ¡o Ká»¹ thuáº­t (náº¿u tab báº­t)\n"
                    message += f"4. PhÃ¢n tÃ­ch MÃ´ hÃ¬nh (náº¿u tab báº­t)\n"
                    message += f"5. Táº¡o TÃ­n hiá»‡u Giao dá»‹ch (náº¿u tab báº­t)\n"
                    message += f"6. Thá»±c hiá»‡n Lá»‡nh (náº¿u cÃ³ tÃ­n hiá»‡u)\n\n"
                    message += f"[TIN Tá»¨C] PhÃ¡t hiá»‡n: {economic_status}"
                else:
                    message = f"[AUTO TRADING] Starting Simplified Auto Trading!\n\n"
                    message += f"This will automatically:\n"
                    message += f"1. Fetch Market Data (if tab enabled)\n"
                    message += f"2. Calculate Trend Analysis (if tab enabled)\n"
                    message += f"3. Calculate Technical Indicators (if tab enabled)\n"
                    message += f"4. Analyze Patterns (if tab enabled)\n"
                    message += f"5. Generate Trading Signals (if tab enabled)\n"
                    message += f"6. Execute Orders (if signals found)\n\n"
                    message += f"[NEWS] Detection: {economic_status}"
                
                msg.setText(message)
                if os.path.exists(icon_path):
                    msg.setIconPixmap(QPixmap(icon_path).scaled(64, 64, Qt.KeepAspectRatio))
                else:
                    msg.setIcon(QMessageBox.Information)
                msg.exec_()
            
                # Log setting
                print(f"[AUTO TRADING] Started Simplified Auto Trading")
                print(f"   [NEWS] News Detection: {economic_status}")
                self.add_log(I18N.t("ðŸ“° News Detection: {status}", "ðŸ“° PhÃ¡t hiá»‡n tin: {status}", status=economic_status))
                
                # Báº¯t Ä‘áº§u simplified auto trading
                if not self.auto_manager:
                    # Sá»­ dá»¥ng main window reference Ä‘Ã£ Ä‘Æ°á»£c set
                    main_window_ref = self.main_window_ref
                    
                    if main_window_ref:
                        print(f"[DEBUG] Using stored main window reference: {type(main_window_ref)}")
                        print(f"[DEBUG] Market tab available: {hasattr(main_window_ref, 'market_tab')}")
                        print(f"[DEBUG] all_tabs available: {hasattr(main_window_ref, 'all_tabs')}")
                        if hasattr(main_window_ref, 'all_tabs'):
                            print(f"[DEBUG] auto_trading_tab in all_tabs: {'auto_trading_tab' in main_window_ref.all_tabs}")
                        self.add_log(I18N.t("ðŸ”— Connected to MainWindow: {name}", "ðŸ”— Káº¿t ná»‘i vá»›i MainWindow: {name}", name=type(main_window_ref).__name__))
                    else:
                        print("[WARNING] No main window reference available - will use fallback methods")
                        self.add_log(I18N.t("âš ï¸ No MainWindow reference - using fallback methods", "âš ï¸ KhÃ´ng cÃ³ tham chiáº¿u MainWindow - sá»­ dá»¥ng phÆ°Æ¡ng phÃ¡p dá»± phÃ²ng"))
                
                    print(f"[DEBUG] Creating AutoTradingManager with main_window_ref: {main_window_ref}")
                    print(f"[DEBUG] AI Model: {ai_model}, Use AI Server: {use_ai_server}")
                    
                    # ðŸ”§ FIX: Pass actual MainWindow for GUI operations but keep status callbacks
                    self.auto_manager = AutoTradingManager(
                        main_window_ref=main_window_ref,  # Pass MainWindow for GUI clicks
                        update_interval=60  # 1 phÃºt per cycle
                    )
                    
                    # ðŸ¤– Pass AI model configuration to auto manager
                    if hasattr(self.auto_manager, 'set_ai_config'):
                        self.auto_manager.set_ai_config(
                            use_ai_server=use_ai_server,
                            ai_server_url=self._get_ai_server_url() if use_ai_server else None,
                            custom_prompt=""  # GPT Prompt removed
                        )
                        self.add_log(f"ðŸ¤– AI Config set: {'AI Server' if use_ai_server else 'Aggregator'}")
                    else:
                        # Store AI config in auto_manager directly
                        self.auto_manager._use_ai_server = use_ai_server
                        self.auto_manager._ai_server_url = self._get_ai_server_url() if use_ai_server else None
                        self.auto_manager._ai_custom_prompt = ""  # GPT Prompt removed
                        self.add_log(f"ðŸ¤– AI Config stored: {'AI Server' if use_ai_server else 'Aggregator'}")
                    
                    # ðŸ”§ FIX: Override main_window callbacks to AutoTradingTab for status updates
                    if hasattr(self.auto_manager, 'main_window'):
                        # Keep GUI reference for tab clicks
                        self.auto_manager._gui_main_window = self.auto_manager.main_window
                        # Override for status callbacks
                        self.auto_manager.main_window = self
                    print(f"[DEBUG] AutoTradingManager created: {self.auto_manager}")
                    print(f"[DEBUG] AutoTradingManager.main_window: {self.auto_manager.main_window}")
                
                    print("[PIPELINE] Starting Auto Trading Pipeline...")
                    print("[INFO] Auto Trading will check checkbox settings from each tab")
                    self.add_log(I18N.t("âš™ï¸ Auto Trading Manager initialized successfully", "âš™ï¸ Khá»Ÿi táº¡o Auto Trading Manager thÃ nh cÃ´ng"))
                    
                    # Start the pipeline in background
                    import threading
                
                    def start_pipeline():
                        try:
                            print(f"[PIPELINE DEBUG] Starting pipeline with auto_manager: {self.auto_manager}")
                            print(f"[PIPELINE DEBUG] auto_manager.main_window: {getattr(self.auto_manager, 'main_window', None)}")
                            
                            self.update_status(I18N.t("ðŸ”„ Starting pipeline...", "ðŸ”„ Äang khá»Ÿi Ä‘á»™ng pipeline..."))
                            self.add_log(I18N.t("ðŸ”§ Starting trading pipeline...", "ðŸ”§ Báº¯t Ä‘áº§u pipeline trading..."))
                        
                            # Test GUI update from auto manager
                            if hasattr(self.auto_manager, 'update_gui_status'):
                                print("[PIPELINE DEBUG] Testing auto_manager.update_gui_status...")
                                self.auto_manager.update_gui_status(I18N.t("ðŸ§ª Test status update from Auto Manager", "ðŸ§ª Test status update tá»« Auto Manager"))
                            
                            # Initialize and start the pipeline (CONTINUOUS MODE)
                            result = self.auto_manager.start()
                            if result is False:
                                print("[BLOCKED] Auto Trading Pipeline BLOCKED by risk settings!")
                                print("[INFO] Please enable auto mode in risk management first")
                                self.update_status(I18N.t("ðŸ”’ Auto Trading blocked by risk settings", "ðŸ”’ Auto Trading bá»‹ cháº·n bá»Ÿi cÃ i Ä‘áº·t rá»§i ro"))
                                self.add_log(I18N.t("âŒ Pipeline blocked - check Risk Management settings", "âŒ Pipeline bá»‹ cháº·n - kiá»ƒm tra cÃ i Ä‘áº·t Risk Management"))
                                QMessageBox.warning(self, 
                                                  I18N.t("Auto Trading Blocked", "Auto Trading Bá»‹ Cháº·n"), 
                                                  I18N.t("Auto Trading is disabled in risk management settings.\n\n"
                                                        "Please:\n"
                                                        "1. Set 'enable_auto_mode': true\n"
                                                        "2. Change trading mode to auto\n"
                                                        "3. Check risk management settings",
                                                        "Auto Trading bá»‹ táº¯t trong cÃ i Ä‘áº·t quáº£n lÃ½ rá»§i ro.\n\n"
                                                        "Vui lÃ²ng:\n"
                                                        "1. Äáº·t 'enable_auto_mode': true\n"
                                                        "2. Chuyá»ƒn cháº¿ Ä‘á»™ giao dá»‹ch sang auto\n"
                                                        "3. Kiá»ƒm tra cÃ i Ä‘áº·t quáº£n lÃ½ rá»§i ro"))
                                self.auto_manager = None
                            else:
                                print("[SUCCESS] Auto Trading Pipeline Successfully Started!")
                                self.update_status(I18N.t("ðŸ”„ Auto Trading running continuously...", "ðŸ”„ Auto Trading Ä‘ang cháº¡y liÃªn tá»¥c..."))
                                self.add_log(I18N.t("ðŸŽ‰ Pipeline started successfully - continuous mode!", "ðŸŽ‰ Pipeline khá»Ÿi Ä‘á»™ng thÃ nh cÃ´ng - cháº¿ Ä‘á»™ láº·p láº¡i!"))
                                
                                # CONTINUOUS MODE - Keep running until stopped
                                print("[CONTINUOUS] Auto Trading running in continuous mode...")
                                self.add_log(I18N.t("ðŸ”„ Continuous mode - pipeline will repeat every 60 seconds", "ðŸ”„ Cháº¡y liÃªn tá»¥c - pipeline sáº½ láº·p láº¡i sau má»—i 60 giÃ¢y"))
                                
                                # The auto_manager will handle its own cycling
                                # No need to wait or clean up - it runs continuously
                        except Exception as e:
                            print(f"[ERROR] Error starting simplified auto trading pipeline: {e}")
                            self.update_status(I18N.t("âŒ Startup error: {error}", "âŒ Lá»—i khá»Ÿi Ä‘á»™ng: {error}", error=str(e)))
                            self.add_log(I18N.t("âŒ Pipeline error: {error}", "âŒ Lá»—i pipeline: {error}", error=str(e)))
                            self.auto_manager = None
                
                    # Start pipeline in separate thread to avoid blocking UI
                    pipeline_thread = threading.Thread(target=start_pipeline, daemon=True)
                    pipeline_thread.start()
                    
                else:
                    print("[WARNING] Auto Trading Manager already running")
                    self.update_status(I18N.t("âš ï¸ Auto Trading already running", "âš ï¸ Auto Trading Ä‘Ã£ Ä‘ang cháº¡y"))
                    self.add_log(I18N.t("âš ï¸ Auto Trading Manager already active", "âš ï¸ Auto Trading Manager Ä‘Ã£ Ä‘ang hoáº¡t Ä‘á»™ng"))
                    
            except Exception as e:
                print(f"[ERROR] Error in start_auto(): {e}")
                self.update_status(I18N.t("âŒ Startup error: {error}", "âŒ Lá»—i khá»Ÿi Ä‘á»™ng: {error}", error=str(e)))
                self.add_log(I18N.t("âŒ start_auto error: {error}", "âŒ Lá»—i start_auto: {error}", error=str(e)))
                QMessageBox.critical(self, I18N.t("Error", "Lá»—i"), I18N.t("Failed to start auto trading:\n{error}", "KhÃ´ng thá»ƒ khá»Ÿi Ä‘á»™ng giao dá»‹ch tá»± Ä‘á»™ng:\n{error}", error=str(e)))

    def stop_auto(self):
        """Improved stop method with better error handling and cleanup"""
        try:
            if self.auto_manager:
                print("[STOP] Stopping Auto Trading Pipeline...")
                self.update_status(I18N.t("ðŸ”„ Stopping Auto Trading...", "ðŸ”„ Äang dá»«ng Auto Trading..."))
                self.add_log(I18N.t("ðŸ›‘ Starting to stop Auto Trading Pipeline", "ðŸ›‘ Báº¯t Ä‘áº§u dá»«ng Auto Trading Pipeline"))
                
                # Stop the manager gracefully with timeout
                try:
                    import time
                    import threading
                    
                    # Use a separate thread to stop with timeout
                    def stop_with_timeout():
                        try:
                            self.auto_manager.stop()
                            return True
                        except Exception as e:
                            print(f"[STOP ERROR] {e}")
                            return False
                    
                    stop_thread = threading.Thread(target=stop_with_timeout, daemon=True)
                    stop_thread.start()
                    stop_thread.join(timeout=10)  # 10 second timeout
                    
                    if stop_thread.is_alive():
                        print("[WARNING] Stop operation timed out")
                        self.add_log(I18N.t("âš ï¸ Stop timeout - forcing cleanup", "âš ï¸ Stop timeout - forcing cleanup"))
                    else:
                        print("[SUCCESS] Auto Trading Pipeline Stopped Successfully")
                        self.add_log(I18N.t("âœ… Auto Trading Pipeline stopped successfully", "âœ… Auto Trading Pipeline Ä‘Ã£ dá»«ng thÃ nh cÃ´ng"))
                    
                    self.update_status(I18N.t("âšª Auto Trading stopped", "âšª Auto Trading Ä‘Ã£ dá»«ng"))
                    
                except Exception as e:
                    print(f"[ERROR] Error stopping auto manager: {e}")
                    self.update_status(I18N.t("âš ï¸ Error stopping Auto Trading", "âš ï¸ Lá»—i khi dá»«ng Auto Trading"))
                    self.add_log(I18N.t("âŒ Manager stop error: {error}", "âŒ Lá»—i dá»«ng manager: {error}", error=str(e)))
                
                # Force cleanup
                finally:
                    try:
                        # Try to force cleanup any remaining resources
                        if hasattr(self.auto_manager, '_shutdown_event'):
                            self.auto_manager._shutdown_event.set()
                        if hasattr(self.auto_manager, 'is_running'):
                            self.auto_manager.is_running = False
                    except:
                        pass
                    
                    # Clear reference
                    self.auto_manager = None
                    print("[CLEANUP] Auto manager reference cleared")
                
            else:
                print("[WARNING] No Auto Trading Manager to stop")
                self.update_status(I18N.t("âšª No Auto Trading to stop", "âšª KhÃ´ng cÃ³ Auto Trading Ä‘á»ƒ dá»«ng"))
                self.add_log(I18N.t("âš ï¸ No Auto Trading Manager to stop", "âš ï¸ KhÃ´ng cÃ³ Auto Trading Manager Ä‘á»ƒ dá»«ng"))
                
        except Exception as e:
            print(f"[ERROR] Error in stop_auto(): {e}")
            import traceback
            print(f"[ERROR] Traceback: {traceback.format_exc()}")
            self.update_status(I18N.t("âŒ Stop error: {error}", "âŒ Lá»—i dá»«ng: {error}", error=str(e)))
            self.add_log(I18N.t("âŒ stop_auto error: {error}", "âŒ Lá»—i stop_auto: {error}", error=str(e)))
            
            # Force clear auto_manager even if error
            try:
                self.auto_manager = None
                print("[FORCE CLEANUP] Auto manager reference force cleared")
            except:
                pass

    def is_economic_calendar_enabled(self):
        """Kiá»ƒm tra xem economic calendar cÃ³ Ä‘Æ°á»£c báº­t khÃ´ng"""
        if self.news_tab:
            return self.news_tab.get_economic_calendar_setting()
        else:
            # Fallback to user config
            user_config = load_user_config()
            return user_config.get("use_economic_calendar", True)

    def get_economic_calendar_status(self):
        """Láº¥y status text cá»§a economic calendar setting"""
        enabled = self.is_economic_calendar_enabled()
        return "âœ… Enabled" if enabled else "âŒ Disabled"

class IndicatorTab(QWidget):
    INDICATOR_OPTIONS = [
        {"name": "MA", "label": "Moving Average"},
        {"name": "MACD", "label": "MACD"},
        {"name": "RSI", "label": "RSI"},
        {"name": "Stochastic", "label": "Stochastic"},
        {"name": "Bollinger Bands", "label": "Bollinger Bands"},
        {"name": "ATR", "label": "ATR"},
        {"name": "ADX", "label": "ADX"},
        {"name": "CCI", "label": "CCI"},
        {"name": "WilliamsR", "label": "Williams %R"},
        {"name": "ROC", "label": "ROC"},
        {"name": "OBV", "label": "OBV"},
        {"name": "MFI", "label": "MFI"},
        {"name": "PSAR", "label": "Parabolic SAR"},
    {"name": "Chaikin", "label": "Chaikin Money Flow"},  # token 'chaikin' (CMF)
        {"name": "EOM", "label": "Ease of Movement"},
        {"name": "ForceIndex", "label": "Force Index"},
        {"name": "Donchian", "label": "Donchian Channel"},
        {"name": "TRIX", "label": "TRIX"},
        {"name": "DPO", "label": "DPO"},
        {"name": "MassIndex", "label": "Mass Index"},
        {"name": "Vortex", "label": "Vortex Indicator"},
        {"name": "KST", "label": "KST Oscillator"},
        {"name": "StochRSI", "label": "Stochastic RSI"},
        {"name": "UltimateOscillator", "label": "Ultimate Oscillator"},
        {"name": "Keltner", "label": "Keltner Channel"},
        {"name": "Envelope", "label": "Envelope"},  # <-- ThÃªm dÃ²ng nÃ y
        {"name": "Fibonacci", "label": "Fibonacci"},
        {"name": "Ichimoku", "label": "Ichimoku"},
    ]

    def __init__(self, market_tab):
        super().__init__()
        self.market_tab = market_tab
        self.indicator_rows = []
        self.workers = []
        self.indicator_list = []  # <-- ThÃªm dÃ²ng nÃ y
        self.user_config = load_user_config()
        self.init_ui()
        self.restore_user_config()  # <-- ThÃªm dÃ²ng nÃ y
        # Sync current UI selections to whitelist file for aggregator
        try:
            self._persist_indicator_whitelist()
        except Exception as _e:
            print(f"Could not persist indicator whitelist on init: {_e}")

    def init_ui(self):
        layout = QVBoxLayout()
        self.search_box = QLineEdit()
        # Localized placeholder
        self.search_box.setPlaceholderText(I18N.t("Search indicator...", "TÃ¬m chá»‰ bÃ¡o..."))
        self.search_box.hide()
        layout.addWidget(self.search_box)
        
        # Header vá»›i Add Indicator vÃ  Toggle button
        header_layout = QHBoxLayout()
        self.add_btn = QPushButton(I18N.t("Add Indicator", "ThÃªm chá»‰ bÃ¡o"))
        self.add_btn.clicked.connect(self.add_indicator_row)
        header_layout.addWidget(self.add_btn)
        
        # Spacer Ä‘á»ƒ Ä‘áº©y toggle button sang pháº£i
        header_layout.addStretch()
        
        # Toggle button nhá» á»Ÿ gÃ³c pháº£i
        self.toggle_btn = QPushButton(I18N.t("Add All", "ThÃªm táº¥t cáº£"))
        self.toggle_btn.clicked.connect(self.toggle_all_indicators)
        self.toggle_btn.setMaximumWidth(80)  # LÃ m nÃºt nhá»
        self.toggle_btn.setStyleSheet("QPushButton { background-color: #51cf66; color: white; font-size: 10px; }")
        header_layout.addWidget(self.toggle_btn)
        
        layout.addLayout(header_layout)
        
        self.indicator_area = QVBoxLayout()
        layout.addLayout(self.indicator_area)
        self.export_btn = QPushButton(I18N.t("Calculate & Save Indicator", "TÃ­nh & lÆ°u chá»‰ bÃ¡o"))
        self.export_btn.clicked.connect(self.export_indicators)
        layout.addWidget(self.export_btn)
        self.log_output = QTextEdit()
        self.log_output.setReadOnly(True)
        layout.addWidget(self.log_output)

        # Table Ä‘á»ƒ hiá»ƒn thá»‹ káº¿t quáº£ tÃ­n hiá»‡u
        self.table = QTableWidget(0, 4)
        # Localized header labels
        self.table.setHorizontalHeaderLabels([
            I18N.t("Indicator", "Chá»‰ bÃ¡o"),
            I18N.t("Value", "GiÃ¡ trá»‹"),
            I18N.t("Time", "Thá»i gian"),
            I18N.t("Signal", "TÃ­n hiá»‡u"),
        ])
        header = self.table.horizontalHeader()
        for i in range(self.table.columnCount()):
            header.setSectionResizeMode(i, QHeaderView.Stretch)
        
        # Äáº£m báº£o cá»™t Time cÃ³ width Ä‘á»§ lá»›n Ä‘á»ƒ hiá»ƒn thá»‹ Ä‘áº§y Ä‘á»§ thá»i gian
        self.table.setColumnWidth(2, 150)  # TÄƒng tá»« 100 lÃªn 150px
        header.setSectionResizeMode(2, QHeaderView.Interactive)  # Allow manual resize for Time column
        
        layout.addWidget(self.table)

        self.setLayout(layout)

    def add_indicator_row(self):
        row_layout = QHBoxLayout()
        indi_combo = QComboBox()
        indi_combo.addItems([opt["label"] for opt in self.INDICATOR_OPTIONS])
        row_layout.addWidget(indi_combo)
        row_dict = {"indi_combo": indi_combo, "layout": row_layout}
        self.indicator_rows.append(row_dict)
        self.indicator_area.addLayout(row_layout)
        indi_combo.currentIndexChanged.connect(lambda idx, row=row_dict: self.on_indicator_changed(idx, row))
        self.on_indicator_changed(0, row_dict)
        self.save_current_user_config()  # <-- ThÃªm dÃ²ng nÃ y
        # Persist whitelist whenever user adds an indicator
        try:
            self._persist_indicator_whitelist()
        except Exception as _e:
            print(f"Could not persist indicator whitelist after add: {_e}")
        
        # Update toggle button text
        self.update_toggle_button()

        # Khi combobox Ä‘Æ°á»£c focus, hiá»‡n Ã´ tÃ¬m kiáº¿m
        def on_focus_in(event):
            self.search_box.show()
            self.search_box.setFocus()
            self.search_box.clear()
            try:
                self.search_box.textChanged.disconnect()
            except Exception:
                pass
            self.search_box.textChanged.connect(lambda: self.filter_indicator_combo(indi_combo))
            return QComboBox.focusInEvent(indi_combo, event)
        indi_combo.focusInEvent = on_focus_in

        # Khi combobox máº¥t focus, áº©n Ã´ tÃ¬m kiáº¿m
        def on_focus_out(event):
            self.search_box.hide()
            self.search_box.clear()
            return QComboBox.focusOutEvent(indi_combo, event)
        indi_combo.focusOutEvent = on_focus_out

        # Khi chá»n xong, áº©n Ã´ tÃ¬m kiáº¿m
        def hide_search_box():
            self.search_box.hide()
            self.search_box.clear()
        indi_combo.activated.connect(hide_search_box)

    def remove_indicator_row(self, row_dict):
        layout = row_dict["layout"]
        for i in reversed(range(layout.count())):
            widget = layout.itemAt(i).widget()
            if widget:
                widget.setParent(None)
        self.indicator_area.removeItem(layout)
        self.indicator_rows.remove(row_dict)
        self.save_current_user_config()  # <-- ThÃªm dÃ²ng nÃ y
        # Persist whitelist whenever user removes an indicator
        try:
            self._persist_indicator_whitelist()
        except Exception as _e:
            print(f"Could not persist indicator whitelist after remove: {_e}")
        
        # Update toggle button text
        self.update_toggle_button()

    def on_indicator_changed(self, index, row_dict):
        layout = row_dict["layout"]
        while layout.count() > 1:
            item = layout.takeAt(1)
            widget = item.widget()
            if widget:
                widget.deleteLater()
        indi_label = row_dict["indi_combo"].currentText()
        indi_name = self._label_to_name(indi_label)
        if not indi_name:
            # Unknown label; skip building parameter widgets for this row
            try:
                self.log_output.append(f"âš ï¸ Unknown indicator label: {indi_label}. Skipping parameter UI.")
            except Exception:
                print(f"âš ï¸ Unknown indicator label: {indi_label}. Skipping parameter UI.")
            return
        # Táº¡o widget tham sá»‘ cho tá»«ng indicator
        if indi_name == "MA":
            period_spin = QSpinBox(); period_spin.setMinimum(1); period_spin.setMaximum(1000); period_spin.setValue(20)
            layout.addWidget(QLabel("Period:")); layout.addWidget(period_spin)
            ma_type_combo = QComboBox(); ma_type_combo.addItems(["SMA", "EMA", "WMA", "TEMA"])
            layout.addWidget(QLabel("Type:")); layout.addWidget(ma_type_combo)
            row_dict["period_spin"] = period_spin
            row_dict["ma_type_combo"] = ma_type_combo
            # Persist whitelist whenever MA params change
            try:
                period_spin.valueChanged.connect(lambda _=None: (self.save_current_user_config(), self._persist_indicator_whitelist()))
                ma_type_combo.currentTextChanged.connect(lambda _=None: (self.save_current_user_config(), self._persist_indicator_whitelist()))
            except Exception as _e:
                print(f"Could not bind MA change handlers: {_e}")
            # Persist whitelist whenever MA params change
            try:
                period_spin.valueChanged.connect(lambda _=None: (self.save_current_user_config(), self._persist_indicator_whitelist()))
                ma_type_combo.currentTextChanged.connect(lambda _=None: (self.save_current_user_config(), self._persist_indicator_whitelist()))
            except Exception as _e:
                print(f"Could not bind MA change handlers: {_e}")
        elif indi_name == "RSI":
            period_spin = QSpinBox(); period_spin.setMinimum(1); period_spin.setMaximum(1000); period_spin.setValue(14)
            layout.addWidget(QLabel("Period:")); layout.addWidget(period_spin)
            row_dict["period_spin"] = period_spin
        elif indi_name == "MACD":
            fast_spin = QSpinBox(); fast_spin.setMinimum(1); fast_spin.setMaximum(100); fast_spin.setValue(12)
            slow_spin = QSpinBox(); slow_spin.setMinimum(1); slow_spin.setMaximum(100); slow_spin.setValue(26)
            signal_spin = QSpinBox(); signal_spin.setMinimum(1); signal_spin.setMaximum(100); signal_spin.setValue(9)
            layout.addWidget(QLabel("Fast:")); layout.addWidget(fast_spin)
            layout.addWidget(QLabel("Slow:")); layout.addWidget(slow_spin)
            layout.addWidget(QLabel("Signal:")); layout.addWidget(signal_spin)
            row_dict["fast_spin"] = fast_spin; row_dict["slow_spin"] = slow_spin; row_dict["signal_spin"] = signal_spin
        elif indi_name == "Stochastic":
            period_spin = QSpinBox(); period_spin.setMinimum(1); period_spin.setMaximum(1000); period_spin.setValue(14)
            smooth_spin = QSpinBox(); smooth_spin.setMinimum(1); smooth_spin.setMaximum(100); smooth_spin.setValue(3)
            layout.addWidget(QLabel("Period:")); layout.addWidget(period_spin)
            layout.addWidget(QLabel("Smooth:")); layout.addWidget(smooth_spin)
            row_dict["period_spin"] = period_spin; row_dict["smooth_spin"] = smooth_spin
        elif indi_name == "Bollinger Bands":
            window_spin = QSpinBox(); window_spin.setMinimum(1); window_spin.setMaximum(1000); window_spin.setValue(20)
            dev_spin = QSpinBox(); dev_spin.setMinimum(1); dev_spin.setMaximum(10); dev_spin.setValue(2)
            layout.addWidget(QLabel("Window:")); layout.addWidget(window_spin)
            layout.addWidget(QLabel("Dev:")); layout.addWidget(dev_spin)
            row_dict["window_spin"] = window_spin; row_dict["dev_spin"] = dev_spin
        elif indi_name in ["ATR", "ADX", "CCI", "WilliamsR", "ROC", "MFI", "Chaikin", "EOM", "ForceIndex", "TRIX", "DPO"]:
            period_spin = QSpinBox(); period_spin.setMinimum(1); period_spin.setMaximum(1000)
            # GiÃ¡ trá»‹ máº·c Ä‘á»‹nh cho tá»«ng indicator
            default = 14 if indi_name in ["ATR", "ADX", "WilliamsR", "MFI", "ForceIndex"] else 20
            if indi_name == "TRIX": default = 15
            if indi_name == "DPO": default = 20
            period_spin.setValue(default)
            layout.addWidget(QLabel("Period:")); layout.addWidget(period_spin)
            row_dict["period_spin"] = period_spin
        elif indi_name == "PSAR":
            step_spin = QDoubleSpinBox(); step_spin.setDecimals(3); step_spin.setSingleStep(0.01); step_spin.setValue(0.02)
            max_step_spin = QDoubleSpinBox(); max_step_spin.setDecimals(2); max_step_spin.setSingleStep(0.01); max_step_spin.setValue(0.2)
            layout.addWidget(QLabel("Step:")); layout.addWidget(step_spin)
            layout.addWidget(QLabel("Max Step:")); layout.addWidget(max_step_spin)
            row_dict["step_spin"] = step_spin; row_dict["max_step_spin"] = max_step_spin
        elif indi_name == "Donchian":
            window_spin = QSpinBox(); window_spin.setMinimum(1); window_spin.setMaximum(1000); window_spin.setValue(20)
            layout.addWidget(QLabel("Window:")); layout.addWidget(window_spin)
            row_dict["window_spin"] = window_spin
        elif indi_name == "MassIndex":
            fast_spin = QSpinBox(); fast_spin.setMinimum(1); fast_spin.setMaximum(100); fast_spin.setValue(9)
            slow_spin = QSpinBox(); slow_spin.setMinimum(1); slow_spin.setMaximum(100); slow_spin.setValue(25)
            layout.addWidget(QLabel("Fast:")); layout.addWidget(fast_spin)
            layout.addWidget(QLabel("Slow:")); layout.addWidget(slow_spin)
            row_dict["fast_spin"] = fast_spin; row_dict["slow_spin"] = slow_spin
        elif indi_name == "Vortex":
            period_spin = QSpinBox(); period_spin.setMinimum(1); period_spin.setMaximum(1000); period_spin.setValue(14)
            layout.addWidget(QLabel("Period:")); layout.addWidget(period_spin)
            row_dict["period_spin"] = period_spin
        elif indi_name == "KST":
            window1_spin = QSpinBox(); window1_spin.setMinimum(1); window1_spin.setMaximum(100); window1_spin.setValue(10)
            window2_spin = QSpinBox(); window2_spin.setMinimum(1); window2_spin.setMaximum(100); window2_spin.setValue(15)
            window3_spin = QSpinBox(); window3_spin.setMinimum(1); window3_spin.setMaximum(100); window3_spin.setValue(20)
            window4_spin = QSpinBox(); window4_spin.setMinimum(1); window4_spin.setMaximum(100); window4_spin.setValue(30)
            window_sig_spin = QSpinBox(); window_sig_spin.setMinimum(1); window_sig_spin.setMaximum(100); window_sig_spin.setValue(9)
            layout.addWidget(QLabel("window1:")); layout.addWidget(window1_spin)
            layout.addWidget(QLabel("window2:")); layout.addWidget(window2_spin)
            layout.addWidget(QLabel("window3:")); layout.addWidget(window3_spin)
            layout.addWidget(QLabel("window4:")); layout.addWidget(window4_spin)
            layout.addWidget(QLabel("window_sig:")); layout.addWidget(window_sig_spin)
            row_dict["window1_spin"] = window1_spin
            row_dict["window2_spin"] = window2_spin
            row_dict["window3_spin"] = window3_spin
            row_dict["window4_spin"] = window4_spin
            row_dict["window_sig_spin"] = window_sig_spin
        elif indi_name == "StochRSI":
            period_spin = QSpinBox(); period_spin.setMinimum(1); period_spin.setMaximum(1000); period_spin.setValue(14)
            smooth1_spin = QSpinBox(); smooth1_spin.setMinimum(1); smooth1_spin.setMaximum(100); smooth1_spin.setValue(3)
            smooth2_spin = QSpinBox(); smooth2_spin.setMinimum(1); smooth2_spin.setMaximum(100); smooth2_spin.setValue(3)
            layout.addWidget(QLabel("Period:")); layout.addWidget(period_spin)
            layout.addWidget(QLabel("Smooth1:")); layout.addWidget(smooth1_spin)
            layout.addWidget(QLabel("Smooth2:")); layout.addWidget(smooth2_spin)
            row_dict["period_spin"] = period_spin; row_dict["smooth1_spin"] = smooth1_spin; row_dict["smooth2_spin"] = smooth2_spin
        elif indi_name == "UltimateOscillator":
            short_spin = QSpinBox(); short_spin.setMinimum(1); short_spin.setMaximum(100); short_spin.setValue(7)
            medium_spin = QSpinBox(); medium_spin.setMinimum(1); medium_spin.setMaximum(100); medium_spin.setValue(14)
            long_spin = QSpinBox(); long_spin.setMinimum(1); long_spin.setMaximum(100); long_spin.setValue(28)
            layout.addWidget(QLabel("Short:")); layout.addWidget(short_spin)
            layout.addWidget(QLabel("Medium:")); layout.addWidget(medium_spin)
            layout.addWidget(QLabel("Long:")); layout.addWidget(long_spin)
            row_dict["short_spin"] = short_spin; row_dict["medium_spin"] = medium_spin; row_dict["long_spin"] = long_spin
        elif indi_name == "Keltner":
            window_spin = QSpinBox(); window_spin.setMinimum(1); window_spin.setMaximum(1000); window_spin.setValue(20)
            layout.addWidget(QLabel("Window:")); layout.addWidget(window_spin)
            row_dict["window_spin"] = window_spin
        elif indi_name == "Fibonacci":
            lookback_spin = QSpinBox()
            lookback_spin.setMinimum(10)
            lookback_spin.setMaximum(1000)
            lookback_spin.setValue(100)
            layout.addWidget(QLabel("Lookback:"))
            layout.addWidget(lookback_spin)
            row_dict["lookback_spin"] = lookback_spin
        elif indi_name == "Ichimoku":
            tenkan_spin = QSpinBox(); tenkan_spin.setMinimum(1); tenkan_spin.setMaximum(100); tenkan_spin.setValue(9)
            kijun_spin = QSpinBox(); kijun_spin.setMinimum(1); kijun_spin.setMaximum(100); kijun_spin.setValue(26)
            senkou_spin = QSpinBox(); senkou_spin.setMinimum(1); senkou_spin.setMaximum(100); senkou_spin.setValue(52)
            layout.addWidget(QLabel("Tenkan:")); layout.addWidget(tenkan_spin)
            layout.addWidget(QLabel("Kijun:")); layout.addWidget(kijun_spin)
            layout.addWidget(QLabel("Senkou:")); layout.addWidget(senkou_spin)
            row_dict["tenkan_spin"] = tenkan_spin
            row_dict["kijun_spin"] = kijun_spin
            row_dict["senkou_spin"] = senkou_spin
        elif indi_name == "Envelope":
            period_spin = QSpinBox(); period_spin.setMinimum(1); period_spin.setMaximum(1000); period_spin.setValue(20)
            percent_spin = QDoubleSpinBox(); percent_spin.setDecimals(2); percent_spin.setSingleStep(0.1); percent_spin.setValue(2.0)
            layout.addWidget(QLabel("Period:")); layout.addWidget(period_spin)
            layout.addWidget(QLabel("Percent:")); layout.addWidget(percent_spin)
            row_dict["period_spin"] = period_spin
            row_dict["percent_spin"] = percent_spin      
        # Localized Remove button
        remove_btn = QPushButton(I18N.t("Remove", "XÃ³a"))
        layout.addWidget(remove_btn)
        row_dict["remove_btn"] = remove_btn
        remove_btn.clicked.connect(lambda: self.remove_indicator_row(row_dict))
        # Sá»­a dÃ²ng nÃ y:
        QTimer.singleShot(0, self.save_current_user_config)
        # Also persist whitelist after any indicator change
        try:
            self._persist_indicator_whitelist()
        except Exception as _e:
            print(f"Could not persist indicator whitelist after change: {_e}")

    def _collect_indicator_whitelist_tokens(self):
        """Return a sorted list of aggregator indicator tokens selected in UI.
        Supported tokens expanded: rsi, macd, adx, stochrsi, stochastic, atr, donchian, ema20, ema50, ema100, ema200,
        sma20, wma20, bollinger, keltner, ichimoku, cci, williamsr, roc, obv, chaikin, eom, force, trix, dpo, mass,
        vortex, kst, ultimate, envelopes, momentum, fibonacci (fibonacci auto-kept by aggregator; not needed here).
        """
        tokens = set()
        for row in self.indicator_rows:
            try:
                combo = row.get("indi_combo")
                if not combo:
                    continue
                label = combo.currentText()
                name = next((opt["name"] for opt in self.INDICATOR_OPTIONS if opt["label"] == label), None)
                if not name:
                    continue
                n = name.lower()
                # Normalize multi-word / variant names to aggregator tokens
                alias_map = {
                    'bollinger bands':'bollinger',
                    'donchian channel':'donchian',
                    'forceindex':'force',
                    'massindex':'mass',
                    'ultimateoscillator':'ultimate',
                    'parabolic sar':'psar',
                    'chaikin money flow':'chaikin','cmf':'chaikin',
                    'ease of movement':'eom',
                    'kst oscillator':'kst',
                    'vortex indicator':'vortex',
                    'stochastic rsi':'stochrsi',
                    'williamsr':'williamsr',
                    'williams %r':'williamsr',
                    'envelope':'envelopes',  # treat single as plural token used in aggregator
                    'fibonacci':'fibonacci'
                }
                if n in alias_map:
                    n = alias_map[n]
                # Direct one-to-one names
                direct = {"rsi","macd","adx","stochrsi","stochastic","atr","donchian","bollinger","keltner","ichimoku","cci","williamsr","roc","obv","chaikin","eom","force","trix","dpo","mass","vortex","kst","ultimate","envelopes","mfi","psar","fibonacci"}
                if n in direct:
                    tokens.add(n)
                elif n == "ma":
                    # Map moving average selection to specific MA tokens based on type & period (generalized)
                    p = row.get("period_spin")
                    t = row.get("ma_type_combo")
                    try:
                        period = int(p.value()) if p else None
                        ma_type = t.currentText().upper() if t else ""
                        if period and ma_type in {"EMA","SMA","WMA","TEMA"}:
                            tokens.add(f"{ma_type.lower()}{period}")
                    except Exception:
                        pass
            except Exception:
                continue
        return sorted(tokens)

    def _persist_indicator_whitelist(self):
        """Write the selected indicator tokens to analysis_results/indicator_whitelist.json for the aggregator to consume."""
        try:
            wl = self._collect_indicator_whitelist_tokens()
            
            # ðŸŽ¯ ADD PATTERN TOKENS: Read ONLY from GUI checkboxes (Analysis tab)
            # NEVER read from notification_config.json - that's for notification settings only!
            
            # Try to get Analysis tab reference from main window
            analysis_tab = None
            main_window = None
            
            try:
                # This is IndicatorTab, get main window
                widget = self
                while widget:
                    parent = widget.parent()
                    if parent is None:
                        main_window = widget
                        break
                    widget = parent
                
                if main_window and hasattr(main_window, 'analysis_tab'):
                    analysis_tab = main_window.analysis_tab
            except Exception as e:
                print(f"[DEBUG] âš ï¸ Failed to get Analysis tab reference: {e}")
            
            # Get checkbox states from Analysis tab (ONLY source for Auto Trading)
            candlestick_enabled = False
            price_patterns_enabled = False
            
            if analysis_tab:
                candlestick_enabled = hasattr(analysis_tab, 'include_candlestick_cb') and analysis_tab.include_candlestick_cb.isChecked()
                price_patterns_enabled = hasattr(analysis_tab, 'include_price_patterns_cb') and analysis_tab.include_price_patterns_cb.isChecked()
                print(f"[DEBUG] ðŸ“– Read pattern settings from Analysis tab GUI: candlestick={candlestick_enabled}, price_patterns={price_patterns_enabled}")
            else:
                # If can't access Analysis tab, READ from current whitelist file (preserves user choice)
                print(f"[DEBUG] âš ï¸ Can't access Analysis tab - attempting to read existing whitelist file")
                try:
                    import os, json
                    wl_path = os.path.join(os.getcwd(), 'analysis_results', 'indicator_whitelist.json')
                    print(f"[DEBUG] ðŸ” Checking whitelist file at: {wl_path}")
                    if os.path.exists(wl_path):
                        print(f"[DEBUG] âœ… File exists, reading...")
                        with open(wl_path, 'r', encoding='utf-8') as f:
                            current_wl = json.load(f)
                        print(f"[DEBUG] ðŸ“„ File contents: {current_wl}")
                        candlestick_enabled = 'candlestick' in current_wl
                        price_patterns_enabled = 'price_patterns' in current_wl
                        print(f"[DEBUG] ðŸ“– Read from existing whitelist file: candlestick={candlestick_enabled}, price_patterns={price_patterns_enabled}")
                    else:
                        # File doesn't exist yet - use safe defaults (both disabled to avoid unwanted runs)
                        print(f"[DEBUG] âš ï¸ File does NOT exist")
                        candlestick_enabled = False
                        price_patterns_enabled = False
                        print(f"[DEBUG] âš ï¸ No whitelist file - using safe defaults: candlestick=False, price_patterns=False")
                except Exception as e:
                    print(f"[DEBUG] âŒ Error reading whitelist: {e} - defaulting to False")
                    import traceback
                    traceback.print_exc()
            
            # Add pattern tokens based on checkbox state
            if candlestick_enabled:
                wl.append('candlestick')
                print(f"[DEBUG] âœ… Added 'candlestick' token (enabled in GUI)")
            else:
                print(f"[DEBUG] âš ï¸ 'candlestick' NOT added (disabled in GUI)")
            
            if price_patterns_enabled:
                wl.append('price_patterns')
                print(f"[DEBUG] âœ… Added 'price_patterns' token (enabled in GUI)")
            else:
                print(f"[DEBUG] âš ï¸ 'price_patterns' NOT added (disabled in GUI)")
            
            out_dir = os.path.join(os.getcwd(), "analysis_results")
            os.makedirs(out_dir, exist_ok=True)
            out_fp = os.path.join(out_dir, "indicator_whitelist.json")
            with open(out_fp, "w", encoding="utf-8") as f:
                json.dump(wl, f, ensure_ascii=False, indent=2)
            print(f"[DEBUG] ðŸ’¾ Saved whitelist to {out_fp}: {wl}")
            # Optional log message if available
            try:
                if hasattr(self, "log_output") and self.log_output:
                    self.log_output.append(f"ðŸ’¾ Saved indicator whitelist: {', '.join(wl) if wl else '(empty)'}")
            except Exception:
                pass
        except Exception as e:
            print(f"Failed to save indicator whitelist: {e}")

    def _label_to_name(self, indi_label: str):
        """Map a UI label back to its canonical indicator name safely.
        Returns None if the label is unknown. Handles minor variations and whitespace.
        """
        try:
            if not indi_label:
                return None
            # Exact label match
            for opt in self.INDICATOR_OPTIONS:
                if opt.get("label") == indi_label:
                    return opt.get("name")
            # Fallback: direct name match (if label equals name)
            for opt in self.INDICATOR_OPTIONS:
                if opt.get("name") == indi_label:
                    return opt.get("name")
            # Case-insensitive, trimmed label match
            lbl_norm = str(indi_label).strip().lower()
            for opt in self.INDICATOR_OPTIONS:
                if str(opt.get("label", "")).strip().lower() == lbl_norm:
                    return opt.get("name")
            return None
        except Exception:
            return None

    def clear_all_indicator_data(self):
        """Clear only specific indicator data files being re-exported, not all files"""
        import os
        import glob
        import time
        
        indicator_dir = "indicator_output"
        if os.path.exists(indicator_dir):
            try:
                # Get current symbols and timeframes being processed
                symbols = list(self.market_tab.checked_symbols) if hasattr(self, 'market_tab') and hasattr(self.market_tab, 'checked_symbols') else []
                selected_tfs = []
                if hasattr(self, 'market_tab') and hasattr(self.market_tab, 'tf_checkboxes'):
                    selected_tfs = [tf for tf in self.market_tab.tf_checkboxes if self.market_tab.tf_checkboxes[tf].isChecked()]
                
                # Only clear files for symbols and timeframes being re-exported
                files_removed = 0
                if symbols and selected_tfs:
                    for symbol in symbols:
                        for tf in selected_tfs:
                            # Clear files matching patterns for this symbol and timeframe
                            patterns = [
                                f"{symbol}_m_{tf}_indicators.json*",
                                f"{symbol}_{tf}_indicators.json*", 
                                f"{symbol}._{tf}_indicators.json*",
                                f"{symbol}._m_{tf}_indicators.json*"
                            ]
                            
                            for pattern in patterns:
                                file_path = os.path.join(indicator_dir, pattern)
                                matching_files = glob.glob(file_path)
                                for file_to_remove in matching_files:
                                    try:
                                        # Additional safety: only remove files older than 1 minute to avoid conflicts
                                        file_age = os.path.getctime(file_to_remove)
                                        current_time = time.time()
                                        if (current_time - file_age) > 60:  # 60 seconds old
                                            os.remove(file_to_remove)
                                            files_removed += 1
                                            print(f"ðŸ§¹ Removed old indicator file: {os.path.basename(file_to_remove)}")
                                        else:
                                            print(f"â³ Skipping recent file: {os.path.basename(file_to_remove)} (too new)")
                                    except Exception as e:
                                        print(f"âš ï¸ Could not remove {file_to_remove}: {e}")
                    
                    if files_removed > 0:
                        self.log_output.append(f"ðŸ§¹ Selective Cleanup: Removed {files_removed} old indicator files for selected symbols")
                        print(f"ðŸ§¹ Selective Cleanup: Removed {files_removed} old indicator files for selected symbols")
                    else:
                        self.log_output.append("ðŸ§¹ Selective Cleanup: No old indicator files found to remove")
                        print("ðŸ§¹ Selective Cleanup: No old indicator files found to remove")
                else:
                    self.log_output.append("âš ï¸ No symbols or timeframes selected - skipping indicator data cleanup")
                    print("âš ï¸ No symbols or timeframes selected - skipping indicator data cleanup")
                
            except Exception as e:
                error_msg = f"âš ï¸ Warning: Could not clear indicator data: {e}"
                self.log_output.append(error_msg)
                print(error_msg)
        else:
            # Create directory if it doesn't exist
            os.makedirs(indicator_dir, exist_ok=True)
            self.log_output.append("ðŸ“ Created indicator_output directory")
            print("ðŸ“ Created indicator_output directory")

    def update_toggle_button(self):
        """Update toggle button text based on current indicators"""
        if len(self.indicator_rows) > 0:
            self.toggle_btn.setText(I18N.t("Clear All", "XÃ³a táº¥t cáº£"))
            self.toggle_btn.setStyleSheet("QPushButton { background-color: #ff6b6b; color: white; font-size: 10px; }")
        else:
            self.toggle_btn.setText(I18N.t("Add All", "ThÃªm táº¥t cáº£"))
            self.toggle_btn.setStyleSheet("QPushButton { background-color: #51cf66; color: white; font-size: 10px; }")

    def apply_language_to_indicator_rows(self):
        """Ensure dynamic 'Remove' buttons reflect current language immediately."""
        try:
            for row in self.indicator_rows:
                btn = row.get("remove_btn")
                if btn:
                    btn.setText(I18N.t("Remove", "XÃ³a"))
        except Exception:
            pass

    def toggle_all_indicators(self):
        """Toggle between Add All and Remove All indicators"""
        if len(self.indicator_rows) > 0:
            # Remove all indicators
            self.remove_all_indicators()
        else:
            # Add all indicators
            self.add_all_indicators()

    def add_all_indicators(self):
        """Add one of each type of indicator with default parameters"""
        # Define default indicators to add (one of each type) - ALL 28 INDICATORS
        default_indicators = [
            ("Moving Average", {"ma_type": "SMA", "period": 20}),
            ("MACD", {"fast": 12, "slow": 26, "signal": 9}),
            ("RSI", {"period": 14}),
            ("Stochastic", {"period": 14, "smooth": 3}),
            ("Bollinger Bands", {"window": 20, "dev": 2}),
            ("ATR", {"period": 14}),
            ("ADX", {"period": 14}),
            ("CCI", {"period": 20}),
            ("Williams %R", {"period": 14}),
            ("ROC", {"period": 12}),
            ("OBV", {}),
            ("MFI", {"period": 14}),
            ("Parabolic SAR", {"acceleration": 0.02, "max_step": 0.2}),
            ("Chaikin Money Flow", {"period": 20}),
            ("Ease of Movement", {"window": 14}),
            ("Force Index", {"period": 13}),
            ("Donchian Channel", {"window": 20}),
            ("TRIX", {"period": 14}),
            ("DPO", {"period": 20}),
            ("Mass Index", {"period": 25}),
            ("Vortex Indicator", {"period": 14}),
            ("KST Oscillator", {"roc1": 10, "roc2": 15, "roc3": 20, "roc4": 30, "window1": 10, "window2": 10, "window3": 10, "window4": 15, "window_sig": 9}),
            ("Stochastic RSI", {"period": 14, "smooth1": 3, "smooth2": 3}),
            ("Ultimate Oscillator", {"short": 7, "medium": 14, "long": 28}),
            ("Keltner Channel", {"window": 20}),
            ("Envelope", {"period": 20, "percent": 2.0}),
            ("Fibonacci", {"lookback": 100}),
            ("Ichimoku", {"tenkan": 9, "kijun": 26, "senkou": 52})
        ]
        
        self.log_output.append("ðŸ”§ Adding all default indicators...")
        
        for indicator_label, params in default_indicators:
            try:
                # Add new indicator row
                self.add_indicator_row()
                
                # Get the last added row
                row_dict = self.indicator_rows[-1]
                
                # Set the indicator type
                combo = row_dict["indi_combo"]
                for i in range(combo.count()):
                    if combo.itemText(i) == indicator_label:
                        combo.setCurrentIndex(i)
                        self.on_indicator_changed(i, row_dict)
                        break
                
                # Set parameters if controls exist
                for param_name, param_value in params.items():
                    # Handle spin boxes (most common)
                    if f"{param_name}_spin" in row_dict:
                        row_dict[f"{param_name}_spin"].setValue(param_value)
                    # Handle combo boxes
                    elif f"{param_name}_combo" in row_dict:
                        combo_widget = row_dict[f"{param_name}_combo"]
                        for j in range(combo_widget.count()):
                            if combo_widget.itemText(j) == str(param_value):
                                combo_widget.setCurrentIndex(j)
                                break
                    # Handle special cases with different naming patterns
                    elif param_name == "ma_type" and "ma_type_combo" in row_dict:
                        combo_widget = row_dict["ma_type_combo"]
                        for j in range(combo_widget.count()):
                            if combo_widget.itemText(j) == str(param_value):
                                combo_widget.setCurrentIndex(j)
                                break
                    elif param_name == "dev" and "std_spin" in row_dict:
                        row_dict["std_spin"].setValue(param_value)
                    elif param_name == "acceleration" and "accel_spin" in row_dict:
                        row_dict["accel_spin"].setValue(param_value)
                    elif param_name == "max_step" and "maxstep_spin" in row_dict:
                        row_dict["maxstep_spin"].setValue(param_value)
                    elif param_name == "smooth" and "k_spin" in row_dict:
                        row_dict["k_spin"].setValue(param_value)
                
            except Exception as e:
                self.log_output.append(f"âš ï¸ Error adding {indicator_label}: {e}")
        
        self.log_output.append(f"âœ… Added {len(default_indicators)} indicators successfully!")
        self.update_toggle_button()

    def remove_all_indicators(self):
        """Remove all current indicators"""
        self.log_output.append("ðŸ—‘ï¸ Removing all indicators...")
        
        # Remove all indicators (copy list to avoid modification during iteration)
        indicators_to_remove = self.indicator_rows.copy()
        for row_dict in indicators_to_remove:
            self.remove_indicator_row(row_dict)
        
        self.log_output.append("âœ… All indicators removed!")
        self.update_toggle_button()

    def export_indicators(self):
        # Dá»«ng táº¥t cáº£ worker cÅ© trÆ°á»›c khi táº¡o má»›i
        self.stop_all_workers()
        
        # ðŸ§¹ Clear only specific old indicator data before starting new calculation
        self.clear_all_indicator_data()
        
        self.table.setRowCount(0)
        symbols = list(self.market_tab.checked_symbols)
        selected_tfs = [(tf, self.market_tab.tf_spinboxes[tf].value()) for tf in self.market_tab.tf_checkboxes if self.market_tab.tf_checkboxes[tf].isChecked()]
        
        # DEBUG: Log what's selected
        self.log_output.append(f"DEBUG: Selected symbols: {symbols}")
        self.log_output.append(f"DEBUG: Selected timeframes: {selected_tfs}")
        
        if not symbols or not selected_tfs:
            self.log_output.append("Please select symbol and timeframe in Market tab.")
            return
        indicator_list = []
        for row in self.indicator_rows:
            indi_label = row["indi_combo"].currentText()
            indi_name = self._label_to_name(indi_label)
            if not indi_name:
                # Skip invalid/unknown indicator rows gracefully
                warn_msg = f"âš ï¸ Skipping unknown indicator label during export: '{indi_label}'"
                try:
                    self.log_output.append(warn_msg)
                except Exception:
                    print(warn_msg)
                continue
            params = {}
            # Láº¥y params cho tá»«ng indicator, vÃ­ dá»¥:
            if indi_name in ["RSI", "ATR", "ADX", "CCI", "WilliamsR", "ROC", "MFI", "Chaikin", "EOM", "ForceIndex", "TRIX", "DPO"]:
                params["period"] = row["period_spin"].value()
            elif indi_name == "Bollinger Bands":
                params["window"] = row["window_spin"].value()
                params["dev"] = row["dev_spin"].value()
            elif indi_name == "MA":
                params["period"] = row["period_spin"].value()
                params["ma_type"] = row["ma_type_combo"].currentText()
            elif indi_name == "MACD":
                params["fast"] = row["fast_spin"].value()
                params["slow"] = row["slow_spin"].value()
                params["signal"] = row["signal_spin"].value()
            elif indi_name == "Stochastic":
                params["period"] = row["period_spin"].value()
                params["smooth"] = row["smooth_spin"].value()
            elif indi_name == "PSAR":
                params["step"] = row["step_spin"].value()
                params["max_step"] = row["max_step_spin"].value()
            elif indi_name == "Donchian":
                params["window"] = row["window_spin"].value()
            elif indi_name == "MassIndex":
                params["fast"] = row["fast_spin"].value()
                params["slow"] = row["slow_spin"].value()
            elif indi_name == "Vortex":
                params["period"] = row["period_spin"].value()
            elif indi_name == "KST":
                params["window1"] = row["window1_spin"].value()
                params["window2"] = row["window2_spin"].value()
                params["window3"] = row["window3_spin"].value()
                params["window4"] = row["window4_spin"].value()
                params["window_sig"] = row["window_sig_spin"].value()
            elif indi_name == "StochRSI":
                params["period"] = row["period_spin"].value()
                params["smooth1"] = row["smooth1_spin"].value()
                params["smooth2"] = row["smooth2_spin"].value()
            elif indi_name == "UltimateOscillator":
                params["short"] = row["short_spin"].value()
                params["medium"] = row["medium_spin"].value()
                params["long"] = row["long_spin"].value()
            elif indi_name == "Keltner":
                params["window"] = row["window_spin"].value()
            elif indi_name == "Fibonacci":
                params["lookback"] = row["lookback_spin"].value()
            elif indi_name == "Ichimoku":
                params["tenkan"] = row["tenkan_spin"].value()
                params["kijun"] = row["kijun_spin"].value()
                params["senkou"] = row["senkou_spin"].value()
            elif indi_name == "Envelope":
              
                if "period_spin" in row:
                    params["period"] = row["period_spin"].value()
                else:
                    params["period"] = 20  # default
                if "percent_spin" in row:
                    params["percent"] = row["percent_spin"].value()
                else:
                    params["percent"] = 2  # default
            indicator_list.append({
                "name": indi_name,
                "params": params
            })
        self.indicator_list = indicator_list
        self.last_export_hash = hashlib.md5(json.dumps(indicator_list, sort_keys=True).encode()).hexdigest()
        self.pending_workers = 0
        
        # DEBUG: Log indicator list
        self.log_output.append(f"DEBUG: Indicator list: {[i['name'] for i in indicator_list]}")
        
        for sym in symbols:
            for tf, count in selected_tfs:
                self.log_output.append(f"DEBUG: Starting worker for {sym} {tf} with {count} candles")
                worker = IndicatorWorker(sym, tf, count, indicator_list)
                worker.finished.connect(self.on_indicator_finished)
                worker.finished.connect(lambda _, w=worker: self.cleanup_worker(w))
                worker.error.connect(self.on_indicator_error)  # ThÃªm dÃ²ng nÃ y
                worker.start()
                self.workers.append(worker)
                self.pending_workers += 1

    def on_indicator_error(self, msg):
        QMessageBox.critical(self, I18N.t("Indicator Error", "Lá»—i chá»‰ bÃ¡o"), msg)
        self.log_output.append(msg)

    def cleanup_worker(self, worker):
        if worker in self.workers:
            try:
                # Request graceful stop first
                if hasattr(worker, 'request_stop'):
                    worker.request_stop()
                
                # Properly terminate the thread before cleanup
                if worker.isRunning():
                    worker.quit()
                    worker.wait(3000)  # Wait up to 3 seconds for thread to finish
                
                self.workers.remove(worker)
                worker.deleteLater()
            except Exception as e:
                print(f"Warning: Error cleaning up worker: {e}")
                # Force removal from list even if cleanup fails
                if worker in self.workers:
                    self.workers.remove(worker)

    def on_indicator_finished(self, msg):
        import json
        try:
            # DEBUG: Log raw message
            self.log_output.append(f"DEBUG: Received message: {msg[:200]}...")
            
            data = json.loads(msg)
            if "error" in data:
                self.log_output.append(data["error"])
                return
            symbol = data.get("symbol", "")
            timeframe = data.get("timeframe", "")
            results = data.get("results", [])
            
            # DEBUG: Log results
            self.log_output.append(f"DEBUG: Processing {len(results)} results for {symbol} {timeframe}")
            
            for r in results:
                indi = r.get("indicator", "")
                detail = r.get("detail", "")
                signal = r.get("signal", "")
                time_val = r.get("time", "")
                
                # DEBUG: Log each result
                self.log_output.append(f"DEBUG: {indi} -> {signal} -> {detail}")
                
                # --- HIá»‚N THá»Š GIÃ TRá»Š THá»°C Táº¾ THAY VÃŒ TÃŠN Cá»˜T ---
                if detail and detail != "N/A" and detail != "":
                    value = detail  # Sá»­ dá»¥ng detail tá»« export_indicators (Ä‘Ã£ cÃ³ giÃ¡ trá»‹ thá»±c)
                else:
                    value = f"{indi}: No data"
                indi_full = f"{indi}_{symbol}_{timeframe}"
                time_str = format_time(time_val)
                
                # Chá»n icon vÃ  mÃ u cho signal
                if signal == "Bullish":
                    icon = "â†‘"
                    color = Qt.green
                elif signal == "Bearish":
                    icon = "â†“"
                    color = Qt.red
                elif signal == "Neutral":
                    icon = "â†’"
                    color = Qt.darkYellow
                else:
                    icon = ""
                    color = Qt.black
                row = self.table.rowCount()
                self.table.insertRow(row)
                self.table.setItem(row, 0, QTableWidgetItem(indi_full))
                self.table.setItem(row, 1, QTableWidgetItem(str(value)))
                self.table.setItem(row, 2, QTableWidgetItem(time_str))
                signal_item = QTableWidgetItem(f"{icon} {signal}")
                signal_item.setForeground(color)
                self.table.setItem(row, 3, signal_item)
        except Exception as e:
            self.log_output.append(f"Error displaying indicator result: {e}\n{msg}")
    def restore_user_config(self):
        config = self.user_config.get("indicator_tab", [])
        # XÃ³a cÃ¡c indicator cÅ© trÆ°á»›c khi khÃ´i phá»¥c
        while self.indicator_rows:
            self.remove_indicator_row(self.indicator_rows[0])
        for indi in config:
            self.add_indicator_row()
            row = self.indicator_rows[-1]
            combo = row["indi_combo"]
            idx = combo.findText(indi.get("label", indi.get("name", "")))
            if idx >= 0:
                combo.setCurrentIndex(idx)
            for k, v in indi.get("params", {}).items():
                widget_name = f"{k}_spin"
                if widget_name in row:
                    row[widget_name].setValue(v)
                elif k == "ma_type" and "ma_type_combo" in row:
                    idx2 = row["ma_type_combo"].findText(v)
                    if idx2 >= 0:
                        row["ma_type_combo"].setCurrentIndex(idx2)
        
        # Update toggle button after restoring config
        self.update_toggle_button()

    def save_current_user_config(self):
        config = []
        for row in self.indicator_rows:
            indi_label = row["indi_combo"].currentText()
            # Robust lookup: handle missing label gracefully
            indi_name = None
            for opt in self.INDICATOR_OPTIONS:
                try:
                    if opt.get("label") == indi_label:
                        indi_name = opt.get("name")
                        break
                except Exception:
                    continue
            if not indi_name:
                # Fallback: try direct name match or skip
                for opt in self.INDICATOR_OPTIONS:
                    if opt.get("name") == indi_label:
                        indi_name = opt.get("name")
                        break
            if not indi_name:
                # Skip this row to avoid StopIteration crash
                print(f"âš ï¸ Skipping unknown indicator label '{indi_label}' during save")
                continue
            params = {}
            def safe_get(widget, method="value"):
                try:
                    if widget is not None:
                        return getattr(widget, method)()
                except RuntimeError:
                    return None
                return None

            if "period_spin" in row:
                v = safe_get(row["period_spin"])
                if v is not None:
                    params["period"] = v
            if "ma_type_combo" in row:
                v = safe_get(row["ma_type_combo"], "currentText")
                if v is not None:
                    params["ma_type"] = v
            if "fast_spin" in row:
                v = safe_get(row["fast_spin"])
                if v is not None:
                    params["fast"] = v
            if "slow_spin" in row:
                v = safe_get(row["slow_spin"])
                if v is not None:
                    params["slow"] = v
            if "signal_spin" in row:
                v = safe_get(row["signal_spin"])
                if v is not None:
                    params["signal"] = v
            if "smooth_spin" in row:
                v = safe_get(row["smooth_spin"])
                if v is not None:
                    params["smooth"] = v
            if "window_spin" in row:
                v = safe_get(row["window_spin"])
                if v is not None:
                    params["window"] = v
            if "dev_spin" in row:
                v = safe_get(row["dev_spin"])
                if v is not None:
                    params["dev"] = v
            if "step_spin" in row:
                v = safe_get(row["step_spin"])
                if v is not None:
                    params["step"] = v
            if "max_step_spin" in row:
                v = safe_get(row["max_step_spin"])
                if v is not None:
                    params["max_step"] = v
            if "window1_spin" in row:
                v = safe_get(row["window1_spin"])
                if v is not None:
                    params["window1"] = v
            if "window2_spin" in row:
                v = safe_get(row["window2_spin"])
                if v is not None:
                    params["window2"] = v
            if "window3_spin" in row:
                v = safe_get(row["window3_spin"])
                if v is not None:
                    params["window3"] = v
            if "window4_spin" in row:
                v = safe_get(row["window4_spin"])
                if v is not None:
                    params["window4"] = v
            if "window_sig_spin" in row:
                v = safe_get(row["window_sig_spin"])
                if v is not None:
                    params["window_sig"] = v
            if "smooth1_spin" in row:
                v = safe_get(row["smooth1_spin"])
                if v is not None:
                    params["smooth1"] = v
            if "smooth2_spin" in row:
                v = safe_get(row["smooth2_spin"])
                if v is not None:
                    params["smooth2"] = v
            if "short_spin" in row:
                v = safe_get(row["short_spin"])
                if v is not None:
                    params["short"] = v
            if "medium_spin" in row:
                v = safe_get(row["medium_spin"])
                if v is not None:
                    params["medium"] = v
            if "long_spin" in row:
                v = safe_get(row["long_spin"])
                if v is not None:
                    params["long"] = v
            if "lookback_spin" in row:
                v = safe_get(row["lookback_spin"])
                if v is not None:
                    params["lookback"] = v
            if "tenkan_spin" in row:
                v = safe_get(row["tenkan_spin"])
                if v is not None:
                    params["tenkan"] = v
            if "kijun_spin" in row:
                v = safe_get(row["kijun_spin"])
                if v is not None:
                    params["kijun"] = v
            if "senkou_spin" in row:
                v = safe_get(row["senkou_spin"])
                if v is not None:
                    params["senkou"] = v
            config.append({
                "name": indi_name,
                "label": indi_label,
                "params": params
            })
        user_config = load_user_config()
        user_config["indicator_tab"] = config
        save_user_config(user_config)

    def stop_all_workers(self):
        for worker in getattr(self, "workers", []):
            try:
                # Request graceful stop first
                if hasattr(worker, 'request_stop'):
                    worker.request_stop()
                
                worker.quit()
                worker.wait(3000)  # Wait up to 3 seconds
            except Exception:
                pass
        self.workers = []

    def get_active_indicators(self):
        """Get list of active indicators for chart display"""
        active_indicators = []
        
        for row in self.indicator_rows:
            try:
                # Check if widgets still exist
                if "indi_combo" not in row or row["indi_combo"] is None:
                    continue
                
                # Safe widget access with try-catch
                try:
                    indi_label = row["indi_combo"].currentText()
                except RuntimeError:
                    # Widget has been deleted
                    continue
                    
                if not indi_label:
                    continue
                    
                indi_name = next((opt["name"] for opt in self.INDICATOR_OPTIONS if opt["label"] == indi_label), None)
                if not indi_name:
                    continue
                
                # Get parameters safely
                params = {}
                
                # Helper function for safe widget access
                def safe_get_value(widget_key, method="value"):
                    try:
                        if widget_key in row and row[widget_key] is not None:
                            widget = row[widget_key]
                            if method == "value":
                                return widget.value()
                            elif method == "currentText":
                                return widget.currentText()
                    except (RuntimeError, AttributeError):
                        # Widget deleted or method not available
                        pass
                    return None
                
                # Get common parameters
                period = safe_get_value("period_spin")
                if period is not None:
                    params["period"] = period
                
                ma_type = safe_get_value("ma_type_combo", "currentText")
                if ma_type:
                    params["ma_type"] = ma_type
                
                window = safe_get_value("window_spin")
                if window is not None:
                    params["window"] = window
                
                window1 = safe_get_value("window1_spin")
                if window1 is not None:
                    params["window1"] = window1
                
                window2 = safe_get_value("window2_spin")
                if window2 is not None:
                    params["window2"] = window2
                
                # Add indicator to list
                active_indicators.append({
                    "name": indi_name,
                    "label": indi_label,
                    "params": params
                })
                
                print(f"âœ… Added indicator: {indi_name} with params: {params}")
                
            except Exception as e:
                print(f"Error getting indicator: {e}")
                continue
        
        print(f"ðŸ” Total active indicators: {len(active_indicators)}")
        return active_indicators

        
class PatternTab(QWidget):
    def __init__(self, market_tab, indicator_tab):
        super().__init__()
        self.market_tab = market_tab
        self.indicator_tab = indicator_tab
        self.pattern_data = []
        self.worker = None
        self.init_ui()
        self.load_patterns()

        # Removed auto refresh timer - manual refresh only

    def init_ui(self):
        layout = QVBoxLayout()
        
        # Enable checkbox
        self.enable_checkbox = QCheckBox(I18N.t("Enable candlestick pattern detection", "Báº­t phÃ¡t hiá»‡n mÃ´ hÃ¬nh náº¿n"))
        self.enable_checkbox.setChecked(True)
        # ðŸ”¥ Connect to whitelist update
        self.enable_checkbox.toggled.connect(self._update_whitelist)
        layout.addWidget(self.enable_checkbox)
        
        # Filter options - chá»‰ giá»¯ confidence filter
        filter_layout = QHBoxLayout()
        
        self.min_confidence_label = QLabel(I18N.t("ðŸ“Š Min confidence:", "ðŸ“Š Äá»™ tin cáº­y tá»‘i thiá»ƒu:"))
        filter_layout.addWidget(self.min_confidence_label)
        
        self.min_confidence_spinbox = QDoubleSpinBox()
        self.min_confidence_spinbox.setRange(0.0, 1.0)
        self.min_confidence_spinbox.setSingleStep(0.1)
        self.min_confidence_spinbox.setValue(0.3)  # Lower default value
        self.min_confidence_spinbox.valueChanged.connect(self.on_filter_changed)
        self.min_confidence_spinbox.setToolTip(I18N.t(
            "Minimum confidence threshold (0.0 = all patterns, 1.0 = only highest confidence)",
            "NgÆ°á»¡ng Ä‘á»™ tin cáº­y tá»‘i thiá»ƒu (0.0 = táº¥t cáº£ mÃ´ hÃ¬nh, 1.0 = chá»‰ mÃ´ hÃ¬nh cÃ³ Ä‘á»™ tin cáº­y cao nháº¥t)"
        ))
        filter_layout.addWidget(self.min_confidence_spinbox)
        
        layout.addLayout(filter_layout)
        
        # Status label for pattern statistics with improved styling
        self.status_label = QLabel(I18N.t("No patterns loaded", "ChÆ°a táº£i mÃ´ hÃ¬nh nÃ o"))
        self.status_label.setStyleSheet("""
            QLabel {
                background-color: #f0f0f0;
                border: 1px solid #cccccc;
                border-radius: 5px;
                padding: 8px;
                font-weight: bold;
                color: #333333;
            }
        """)
        layout.addWidget(self.status_label)
        
        # Main action button
        self.fetch_pattern_btn = QPushButton(I18N.t("ðŸ” Fetch Candlestick Patterns", "ðŸ” Láº¥y mÃ´ hÃ¬nh náº¿n"))
        self.fetch_pattern_btn.clicked.connect(self.fetch_patterns_and_reload)
        self.fetch_pattern_btn.setMinimumHeight(35)
        layout.addWidget(self.fetch_pattern_btn)
        
        # Pattern table - 7 columns: Symbol, Timeframe, Time, Pattern, Length, Signal, Confidence
        self.table = QTableWidget(0, 7)
        self.table.setHorizontalHeaderLabels([I18N.t("Symbol", "MÃ£"), I18N.t("Timeframe", "Khung TG"), I18N.t("Time", "Thá»i gian"), I18N.t("Pattern", "MÃ´ hÃ¬nh"), I18N.t("Length", "Äá»™ dÃ i"), I18N.t("Signal", "TÃ­n hiá»‡u"), I18N.t("Confidence", "Äá»™ tin cáº­y")])
        header = self.table.horizontalHeader()
        for i in range(self.table.columnCount()):
            header.setSectionResizeMode(i, QHeaderView.Stretch)
        layout.addWidget(self.table)
        self.setLayout(layout)

    def fetch_patterns_and_reload(self):
    
        if self.worker is not None and self.worker.isRunning():
            self.worker.quit()
            self.worker.wait()
        symbols = list(self.market_tab.checked_symbols)
        timeframes = [tf for tf in self.market_tab.tf_checkboxes if self.market_tab.tf_checkboxes[tf].isChecked()]
        if not symbols or not timeframes:
            QMessageBox.warning(self, I18N.t("Warning", "Cáº£nh bÃ¡o"), I18N.t("Please select symbol and timeframe in Market tab.", "Vui lÃ²ng chá»n mÃ£ vÃ  khung thá»i gian trong tab Thá»‹ trÆ°á»ng."))
            return
        self.fetch_pattern_btn.setEnabled(False)
        indicator_list = getattr(self.indicator_tab, "indicator_list", [])
        self.worker = PatternWorker(symbols, timeframes, indicator_list)
        self.worker.finished.connect(self.on_patterns_finished)
        self.worker.error.connect(self.on_patterns_error)
        self.worker.start()

    def on_patterns_finished(self):
        self.fetch_pattern_btn.setEnabled(True)
        self.load_patterns()

    def on_patterns_error(self, msg):
        QMessageBox.critical(self, I18N.t("Pattern Error", "Lá»—i mÃ´ hÃ¬nh"), msg)
        self.fetch_pattern_btn.setEnabled(True)

    def load_patterns(self):
        """Load and display patterns using helper functions"""
        self.table.setRowCount(0)
        self.pattern_data.clear()
        folder = "./pattern_signals"
        
        if not os.path.exists(folder):
            self.status_label.setText("âŒ Pattern folder not found")
            return

        # Get selected symbols and timeframes from market tab
        selected_symbols = set(self.market_tab.checked_symbols)
        selected_timeframes = set(tf for tf in self.market_tab.tf_checkboxes if self.market_tab.tf_checkboxes[tf].isChecked())
        
        # If nothing is selected, load all patterns
        if not selected_symbols or not selected_timeframes:
            selected_symbols = None
            selected_timeframes = None
        
        # Get filter settings from UI (chá»‰ confidence, khÃ´ng cÃ²n candlestick_only)
        min_confidence = self.min_confidence_spinbox.value()
        
        print(f"ðŸ“Š Loading patterns with filters: min_confidence={min_confidence}")
        
        # Show loading status
        self.status_label.setText(f"ðŸ”„ Loading patterns (min_conf: {min_confidence})...")
        
        # Load and filter patterns using helper functions (luÃ´n láº¥y táº¥t cáº£ patterns)
        patterns = load_and_filter_patterns(
            folder,
            selected_symbols,
            selected_timeframes,
            candlestick_only=False,  # LuÃ´n lÃ  False
            min_confidence=min_confidence
        )
        
        print(f"âœ… Loaded {len(patterns)} patterns after filtering")
        
        # Sort patterns by priority using helper function (now sorted by Symbol first)
        sorted_patterns = sort_patterns_by_priority(patterns)
        
        # Add patterns to table
        for pattern_obj in sorted_patterns:
            self.add_pattern_row(
                pattern_obj['symbol'],
                pattern_obj['timeframe'],
                pattern_obj['time'],
                pattern_obj['pattern'],
                pattern_obj['pattern_length'],
                pattern_obj['signal'],
                pattern_obj.get('confidence', 0.5),  # Add confidence
                pattern_obj.get('score', 0.0)  # Add score instead of recommendation
            )
        
        # Update status label using helper functions
        stats = get_pattern_statistics(sorted_patterns)
        status_message = format_status_message(stats, candlestick_only=False)  # LuÃ´n lÃ  False
        self.status_label.setText(status_message)

    def add_pattern_row(self, symbol, timeframe, time_key, pattern, pattern_length=1, signal=None, confidence=0.5, score=0.0):
        """Add a pattern row to the table - pure UI logic with icon in symbol"""
        row = self.table.rowCount()
        self.table.insertRow(row)
        
        # Check if pattern is candlestick using helper function
        is_candlestick = is_candlestick_pattern(pattern)
        
        # Add candlestick icon to symbol name (only show candlestick icon for candlestick tab)
        symbol_with_icon = f"ðŸ•¯ï¸ {symbol}"
        
        # Create table items
        symbol_item = QTableWidgetItem(symbol_with_icon)
        timeframe_item = QTableWidgetItem(timeframe)
        time_item = QTableWidgetItem(str(time_key))
        pattern_item = QTableWidgetItem(str(pattern))
        length_item = QTableWidgetItem(str(pattern_length))
        
        # Highlight candlestick patterns
        if is_candlestick:
            font = symbol_item.font()
            font.setBold(True)
            for item in [symbol_item, timeframe_item, time_item, pattern_item, length_item]:
                item.setFont(font)
            
            from PyQt5.QtGui import QColor
            bg_color = QColor(255, 255, 200)  # Light yellow background
            for item in [symbol_item, timeframe_item, time_item, pattern_item, length_item]:
                item.setBackground(bg_color)
        
        # Set table items
        self.table.setItem(row, 0, symbol_item)
        self.table.setItem(row, 1, timeframe_item)
        self.table.setItem(row, 2, time_item)
        self.table.setItem(row, 3, pattern_item)
        self.table.setItem(row, 4, length_item)
        
        # Signal column with score
        if signal is None:
            signal = ""
        
        # Add score to signal display: "Bullish (0.8)" or "Neutral (-0.166)"
        # Always show score regardless of positive/negative value
        display_signal = f"{signal} ({score:.3f})"
        
        # Color signal based on type
        color = None
        if "Bullish" in signal:
            color = Qt.green
        elif "Bearish" in signal:
            color = Qt.red
        elif "Neutral" in signal:
            color = Qt.darkYellow
        
        signal_item = QTableWidgetItem(display_signal)
        if color:
            signal_item.setForeground(color)
        
        # Apply candlestick highlighting to signal column
        if is_candlestick:
            font = signal_item.font()
            font.setBold(True)
            signal_item.setFont(font)
            from PyQt5.QtGui import QColor
            bg_color = QColor(255, 255, 200)
            signal_item.setBackground(bg_color)
        
        self.table.setItem(row, 5, signal_item)
        
        # Confidence column (only show confidence value)
        confidence_text = f"{confidence:.2f}"
        confidence_item = QTableWidgetItem(confidence_text)
        
        # Color based on confidence level
        if confidence >= 0.7:
            confidence_item.setForeground(Qt.darkGreen)
        elif confidence >= 0.5:
            confidence_item.setForeground(Qt.darkBlue)
        elif confidence >= 0.3:
            confidence_item.setForeground(Qt.darkYellow)
        else:
            confidence_item.setForeground(Qt.gray)
        
        # Apply candlestick highlighting to confidence column
        if is_candlestick:
            font = confidence_item.font()
            font.setBold(True)
            confidence_item.setFont(font)
            from PyQt5.QtGui import QColor
            bg_color = QColor(255, 255, 200)
            confidence_item.setBackground(bg_color)
        
        self.table.setItem(row, 6, confidence_item)

    def on_filter_changed(self):
        """Handle filter changes with debug information"""
        min_confidence = self.min_confidence_spinbox.value()
        
        print(f"ðŸ”„ Filter changed: min_confidence={min_confidence}")
        
        # Update status to show filter state
        self.status_label.setText(f"ðŸ”„ Loading patterns... (min_conf: {min_confidence})")
        
        # Load patterns with new filter
        self.load_patterns()
    
    def _update_whitelist(self, checked):
        """Update whitelist when candlestick checkbox toggled"""
        try:
            print(f"\n{'='*60}")
            print(f"ðŸ”¥ [PatternTab] Candlestick checkbox toggled: {checked}")
            print(f"{'='*60}")
            
            import os, json
            wl_path = os.path.join(os.getcwd(), 'analysis_results', 'indicator_whitelist.json')
            
            # Read current whitelist
            wl = []
            if os.path.exists(wl_path):
                with open(wl_path, 'r', encoding='utf-8') as f:
                    wl = json.load(f)
            
            # ðŸ”¥ ONLY remove 'candlestick' token (keep price_patterns and other indicators)
            wl = [t for t in wl if t not in ('candlestick', 'patterns')]
            
            # Add candlestick if checked
            if checked:
                wl.append('candlestick')
                print(f"âœ… Added 'candlestick' to whitelist")
            else:
                print(f"âš ï¸ Removed 'candlestick' from whitelist")
            
            # Save
            os.makedirs(os.path.dirname(wl_path), exist_ok=True)
            with open(wl_path, 'w', encoding='utf-8') as f:
                json.dump(wl, f, ensure_ascii=False, indent=2)
            
            print(f"ðŸ’¾ Saved whitelist: {wl}")
            
        except Exception as e:
            print(f"âŒ Error updating whitelist: {e}")
            import traceback
            traceback.print_exc()
    
    def refresh_translations(self):
        """Refresh all UI text when language changes"""
        try:
            self.enable_checkbox.setText(I18N.t("Enable candlestick pattern detection", "Báº­t phÃ¡t hiá»‡n mÃ´ hÃ¬nh náº¿n"))
            self.min_confidence_label.setText(I18N.t("ðŸ“Š Min confidence:", "ðŸ“Š Äá»™ tin cáº­y tá»‘i thiá»ƒu:"))
            self.fetch_pattern_btn.setText(I18N.t("ðŸ” Fetch Candlestick Patterns", "ðŸ” Láº¥y mÃ´ hÃ¬nh náº¿n"))
            self.table.setHorizontalHeaderLabels([I18N.t("Symbol", "MÃ£"), I18N.t("Timeframe", "Khung TG"), I18N.t("Time", "Thá»i gian"), I18N.t("Pattern", "MÃ´ hÃ¬nh"), I18N.t("Length", "Äá»™ dÃ i"), I18N.t("Signal", "TÃ­n hiá»‡u"), I18N.t("Confidence", "Äá»™ tin cáº­y")])
        except Exception as e:
            print(f"[LangSwitch] PatternTab refresh error: {e}")

class PricePatternTab(QWidget):
    def __init__(self, market_tab):
        super().__init__()
        self.market_tab = market_tab
        self.pattern_data = []
        self.worker = None
        self.init_ui()
        self.load_patterns()

        # Removed auto refresh timer - manual refresh only

    def init_ui(self):
        layout = QVBoxLayout()

        # Enable checkbox
        self.enable_checkbox = QCheckBox(I18N.t("Enable price pattern detection", "Báº­t phÃ¡t hiá»‡n mÃ´ hÃ¬nh giÃ¡"))
        self.enable_checkbox.setChecked(True)
        # ðŸ”¥ Connect to whitelist update
        self.enable_checkbox.toggled.connect(self._update_whitelist)
        layout.addWidget(self.enable_checkbox)

        # Filter options - add confidence filter and age filter
        filter_layout = QHBoxLayout()

        self.min_confidence_label = QLabel(I18N.t("ðŸ“Š Min confidence:", "ðŸ“Š Äá»™ tin cáº­y tá»‘i thiá»ƒu:"))
        filter_layout.addWidget(self.min_confidence_label)

        self.min_confidence_spinbox = QDoubleSpinBox()
        self.min_confidence_spinbox.setRange(0.0, 1.0)
        self.min_confidence_spinbox.setSingleStep(0.1)
        self.min_confidence_spinbox.setValue(0.3)  # Lower default value
        self.min_confidence_spinbox.valueChanged.connect(self.on_filter_changed)
        self.min_confidence_spinbox.setToolTip(I18N.t(
            "Minimum confidence threshold (0.0 = all patterns, 1.0 = only highest confidence)",
            "NgÆ°á»¡ng Ä‘á»™ tin cáº­y tá»‘i thiá»ƒu (0.0 = táº¥t cáº£ mÃ´ hÃ¬nh, 1.0 = chá»‰ mÃ´ hÃ¬nh cÃ³ Ä‘á»™ tin cáº­y cao nháº¥t)"
        ))
        filter_layout.addWidget(self.min_confidence_spinbox)

        # Add age filter
        self.max_age_label = QLabel(I18N.t("ðŸ“… Max age (days):", "ðŸ“… Tuá»•i tá»‘i Ä‘a (ngÃ y):"))
        filter_layout.addWidget(self.max_age_label)

        self.max_age_spinbox = QSpinBox()
        self.max_age_spinbox.setRange(1, 365)
        self.max_age_spinbox.setValue(90)  # Default 90 days for better initial visibility
        self.max_age_spinbox.valueChanged.connect(self.on_filter_changed)
        self.max_age_spinbox.setToolTip(I18N.t("Maximum age of patterns in days (only show patterns from last X days)", "Tuá»•i tá»‘i Ä‘a cá»§a mÃ´ hÃ¬nh tÃ­nh theo ngÃ y (chá»‰ hiá»ƒn thá»‹ mÃ´ hÃ¬nh tá»« X ngÃ y gáº§n nháº¥t)"))
        filter_layout.addWidget(self.max_age_spinbox)

        layout.addLayout(filter_layout)

        # Status label for pattern statistics with improved styling
        self.status_label = QLabel(I18N.t("No patterns loaded", "ChÆ°a táº£i mÃ´ hÃ¬nh nÃ o"))
        self.status_label.setStyleSheet(
            """
            QLabel {
                background-color: #f0f0f0;
                border: 1px solid #cccccc;
                border-radius: 5px;
                padding: 8px;
                font-weight: bold;
                color: #333333;
            }
            """
        )
        layout.addWidget(self.status_label)

        # Main action button
        self.fetch_pattern_btn = QPushButton(I18N.t("ðŸ” Fetch Price Patterns", "ðŸ” Láº¥y mÃ´ hÃ¬nh giÃ¡"))
        self.fetch_pattern_btn.clicked.connect(self.fetch_patterns_and_reload)
        self.fetch_pattern_btn.setMinimumHeight(35)
        layout.addWidget(self.fetch_pattern_btn)

        # Pattern table - 8 columns with Age column
        self.table = QTableWidget(0, 8)  # 8 columns
        self.table.setHorizontalHeaderLabels(
            [I18N.t("Symbol", "MÃ£"), I18N.t("Timeframe", "Khung TG"), I18N.t("Time Period", "Khoáº£ng TG"), I18N.t("Pattern", "MÃ´ hÃ¬nh"), I18N.t("Length", "Äá»™ dÃ i"), I18N.t("Signal", "TÃ­n hiá»‡u"), I18N.t("Confidence", "Äá»™ tin cáº­y"), I18N.t("Age", "Tuá»•i")]
        )
        header = self.table.horizontalHeader()
        for i in range(self.table.columnCount()):
            header.setSectionResizeMode(i, QHeaderView.Stretch)
        layout.addWidget(self.table)
        self.setLayout(layout)


    def fetch_patterns_and_reload(self):
        if self.worker is not None and self.worker.isRunning():
            self.worker.quit()
            self.worker.wait()
        symbols = list(self.market_tab.checked_symbols)
        timeframes = [tf for tf in self.market_tab.tf_checkboxes if self.market_tab.tf_checkboxes[tf].isChecked()]
        if not symbols or not timeframes:
            QMessageBox.warning(self, I18N.t("Warning", "Cáº£nh bÃ¡o"), I18N.t("Please select symbol and timeframe in Market tab.", "Vui lÃ²ng chá»n mÃ£ vÃ  khung thá»i gian trong tab Thá»‹ trÆ°á»ng."))
            return
        self.fetch_pattern_btn.setEnabled(False)
        self.worker = PricePatternWorker(symbols, timeframes)
        self.worker.finished.connect(self.on_patterns_finished)
        self.worker.error.connect(self.on_patterns_error)
        self.worker.start()

    def on_patterns_finished(self):
        self.fetch_pattern_btn.setEnabled(True)
        self.load_patterns()

    def on_patterns_error(self, msg):
        QMessageBox.critical(self, I18N.t("Pattern Error", "Lá»—i mÃ´ hÃ¬nh"), msg)
        self.fetch_pattern_btn.setEnabled(True)

    def load_patterns(self):
        """Load and display price patterns robustly (handles symbol suffixes and helper fallback)"""
        self.table.setRowCount(0)
        self.pattern_data.clear()
        folder = "./pattern_price"

        if not os.path.exists(folder):
            self.status_label.setText("âŒ Pattern folder not found")
            return

        # Selections from Market tab
        selected_symbols = set(self.market_tab.checked_symbols)
        selected_timeframes = set(tf for tf in self.market_tab.tf_checkboxes if self.market_tab.tf_checkboxes[tf].isChecked())

        # Filters
        min_confidence = self.min_confidence_spinbox.value()
        max_age_days = self.max_age_spinbox.value()
        self.status_label.setText(f"ðŸ”„ Loading patterns (min_conf: {min_confidence}, max_age: {max_age_days}d)...")

        # Normalize selected symbols for tolerant matching
        def _norm(s: str) -> str:
            return ''.join(ch for ch in s.upper() if ch.isalnum())

        norm_selected = {_norm(s) for s in selected_symbols} if selected_symbols else set()

        # Load patterns with helper; if empty (likely due to symbol suffix mismatch), fall back to manual loader
        patterns = []
        try:
            patterns = load_price_patterns_from_folder(
                folder,
                None if not selected_symbols else selected_symbols,
                None if not selected_timeframes else selected_timeframes
            )
        except Exception as e:
            print(f"âš ï¸ Helper load failed, will use manual loader: {e}")

        if not patterns:
            patterns = self._manual_load_price_patterns(folder)

        print(f"âœ… Loaded {len(patterns)} price patterns before filtering")

        # Apply selection filtering with normalized symbol matching and timeframe filter
        patterns_all = list(patterns)
        if norm_selected:
            patterns = [p for p in patterns if _norm(str(p.get('symbol', ''))) in norm_selected]
        if selected_timeframes:
            tf_set = {tf.upper() for tf in selected_timeframes}
            patterns = [p for p in patterns if str(p.get('timeframe', '')).upper() in tf_set]

        # If selection filters remove everything, relax selection (show all)
        if not patterns and patterns_all:
            print("â„¹ï¸ Selection filters returned 0; ignoring symbol/timeframe filters to show available patterns.")
            patterns = patterns_all

        # Filter by confidence and age
        now_dt = datetime.now()
        cutoff_time = now_dt - timedelta(days=max_age_days)
        filtered_patterns = []
        for p in patterns:
            # Confidence filter
            if float(p.get('confidence', 0.0)) < float(min_confidence):
                continue

            # Time filter
            tstr = p.get('end_time') or p.get('time') or p.get('start_time')
            if not tstr:
                continue
            try:
                # Accept both ISO and "YYYY-MM-DD HH:MM:SS"
                ts = datetime.fromisoformat(str(tstr).replace('Z', '+00:00')) if 'T' in str(tstr) or 'Z' in str(tstr) else datetime.strptime(str(tstr), "%Y-%m-%d %H:%M:%S")
            except Exception:
                # Best-effort parse
                try:
                    ts = datetime.fromisoformat(str(tstr))
                except Exception:
                    continue
            if ts >= cutoff_time:
                # Ensure required keys exist
                if 'time' not in p:
                    p['time'] = tstr
                filtered_patterns.append(p)

        print(f"âœ… Filtered to {len(filtered_patterns)} patterns after selection, confidence and age")

        # Graceful fallback: if nothing passes filters, relax age then confidence
        if not filtered_patterns and patterns:
            print("â„¹ï¸ No patterns matched filters; relaxing age to 365 days...")
            cutoff_time_relaxed = now_dt - timedelta(days=365)
            for p in patterns:
                if float(p.get('confidence', 0.0)) < float(min_confidence):
                    continue
                tstr = p.get('end_time') or p.get('time') or p.get('start_time')
                if not tstr:
                    continue
                try:
                    ts = datetime.fromisoformat(str(tstr).replace('Z', '+00:00')) if 'T' in str(tstr) or 'Z' in str(tstr) else datetime.strptime(str(tstr), "%Y-%m-%d %H:%M:%S")
                except Exception:
                    try:
                        ts = datetime.fromisoformat(str(tstr))
                    except Exception:
                        continue
                if ts >= cutoff_time_relaxed:
                    if 'time' not in p:
                        p['time'] = tstr
                    filtered_patterns.append(p)

        if not filtered_patterns and patterns:
            print("â„¹ï¸ Still none; relaxing confidence to 0.0 and age to 365 days...")
            cutoff_time_relaxed = now_dt - timedelta(days=365)
            for p in patterns:
                tstr = p.get('end_time') or p.get('time') or p.get('start_time')
                if not tstr:
                    continue
                try:
                    ts = datetime.fromisoformat(str(tstr).replace('Z', '+00:00')) if 'T' in str(tstr) or 'Z' in str(tstr) else datetime.strptime(str(tstr), "%Y-%m-%d %H:%M:%S")
                except Exception:
                    try:
                        ts = datetime.fromisoformat(str(tstr))
                    except Exception:
                        continue
                if ts >= cutoff_time_relaxed:
                    if 'time' not in p:
                        p['time'] = tstr
                    filtered_patterns.append(p)

        # Sort and display
        try:
            sorted_patterns = sort_patterns_by_priority(filtered_patterns)
        except Exception:
            # Fallback: newest first by time
            def _key_time(x):
                t = x.get('end_time') or x.get('time') or ''
                try:
                    return datetime.fromisoformat(str(t).replace('Z', '+00:00'))
                except Exception:
                    try:
                        return datetime.strptime(str(t), "%Y-%m-%d %H:%M:%S")
                    except Exception:
                        return datetime.min
            sorted_patterns = sorted(filtered_patterns, key=_key_time, reverse=True)

        for p in sorted_patterns:
            self.add_pattern_row(
                p.get('symbol', ''),
                p.get('timeframe', ''),
                p.get('time', ''),
                p.get('pattern', p.get('type', '')),
                p.get('pattern_length', 1),
                p.get('signal', ''),
                p.get('confidence', 0.5),
                p
            )

        # Update status
        try:
            stats = get_pattern_statistics(sorted_patterns)
            status_message = format_status_message(stats, candlestick_only=False)
            self.status_label.setText(status_message)
        except Exception:
            self.status_label.setText(f"ðŸ“Š Showing {len(sorted_patterns)} price patterns")

    def _manual_load_price_patterns(self, folder: str):
        """Manual loader for price patterns from JSON files in folder."""
        results = []
        try:
            for name in os.listdir(folder):
                if not name.endswith('_patterns.json'):
                    continue
                path = os.path.join(folder, name)
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        arr = json.load(f)
                        if isinstance(arr, list):
                            # Derive symbol/timeframe from filename when missing
                            parts = name[:-14]  # strip '_patterns.json'
                            # Expect pattern: SYMBOL_TF or SYMBOL_extra_TF
                            sym = None
                            tf = None
                            toks = parts.split('_')
                            if len(toks) >= 2:
                                tf = toks[-1]
                                sym = '_'.join(toks[:-1])
                            for p in arr:
                                if 'symbol' not in p and sym:
                                    p['symbol'] = sym
                                if 'timeframe' not in p and tf:
                                    p['timeframe'] = tf
                                results.append(p)
                except Exception as e:
                    print(f"âš ï¸ Failed reading {path}: {e}")
        except Exception as e:
            print(f"âŒ Manual loader error: {e}")
        return results

    def add_pattern_row(self, symbol, timeframe, time_key, pattern, pattern_length=1, signal=None, confidence=0.5, pattern_obj=None):
        """Add a pattern row to the table with enhanced information including Age column"""
        row = self.table.rowCount()
        self.table.insertRow(row)
        
        # Add icon to symbol name - using chart icon for price patterns
        symbol_with_icon = f"ðŸ“Š {symbol}"
        
        # Calculate age of pattern
        age_text = "Unknown"
        age_color = Qt.black
        
        if pattern_obj:
            try:
                # Get the most recent time from pattern
                pattern_time_str = None
                if 'end_time' in pattern_obj and pattern_obj['end_time']:
                    pattern_time_str = pattern_obj['end_time']
                elif 'time' in pattern_obj and pattern_obj['time']:
                    pattern_time_str = pattern_obj['time']
                elif 'start_time' in pattern_obj and pattern_obj['start_time']:
                    pattern_time_str = pattern_obj['start_time']
                
                if pattern_time_str:
                    pattern_time = datetime.fromisoformat(pattern_time_str.replace('Z', '+00:00'))
                    current_time = datetime.now()
                    age_delta = current_time - pattern_time
                    
                    # Format age display
                    total_seconds = age_delta.total_seconds()
                    if total_seconds < 3600:  # Less than 1 hour
                        minutes = int(total_seconds // 60)
                        age_text = f"{minutes}m"
                        age_color = Qt.darkGreen  # Very fresh
                    elif total_seconds < 86400:  # Less than 1 day
                        hours = int(total_seconds // 3600)
                        age_text = f"{hours}h"
                        age_color = Qt.blue  # Fresh
                    elif total_seconds < 604800:  # Less than 1 week
                        days = int(total_seconds // 86400)
                        age_text = f"{days}d"
                        age_color = Qt.darkYellow  # Moderate
                    else:  # More than 1 week
                        weeks = int(total_seconds // 604800)
                        age_text = f"{weeks}w"
                        age_color = Qt.red  # Old
                        
            except Exception as e:
                print(f"âš ï¸ Failed to calculate age for pattern: {e}")
        
        # Format time period to show start and end time if available
        time_period = time_key
        if pattern_obj:
            start_time = pattern_obj.get('start_time', '')
            end_time = pattern_obj.get('end_time', '')
            
            if start_time and end_time:
                # Extract just the date and time part (remove seconds if present)
                try:
                    if isinstance(start_time, str) and len(start_time) > 16:
                        start_display = start_time[:16]  # YYYY-MM-DD HH:MM
                    else:
                        start_display = str(start_time)
                    
                    if isinstance(end_time, str) and len(end_time) > 16:
                        end_display = end_time[:16]  # YYYY-MM-DD HH:MM
                    else:
                        end_display = str(end_time)
                    
                    time_period = f"{start_display} â†’ {end_display}"
                except:
                    time_period = str(time_key)
        
        # Create table items with bold font
        symbol_item = QTableWidgetItem(symbol_with_icon)
        symbol_item.setFont(QFont("Arial", 9, QFont.Bold))
        timeframe_item = QTableWidgetItem(timeframe)
        timeframe_item.setFont(QFont("Arial", 9, QFont.Bold))
        time_item = QTableWidgetItem(time_period)
        time_item.setFont(QFont("Arial", 9, QFont.Bold))
        pattern_item = QTableWidgetItem(str(pattern))
        pattern_item.setFont(QFont("Arial", 9, QFont.Bold))
        length_item = QTableWidgetItem(str(pattern_length))
        length_item.setFont(QFont("Arial", 9, QFont.Bold))
        
        # Set table items
        self.table.setItem(row, 0, symbol_item)
        self.table.setItem(row, 1, timeframe_item)
        self.table.setItem(row, 2, time_item)
        self.table.setItem(row, 3, pattern_item)
        self.table.setItem(row, 4, length_item)
        
        # Signal column - similar to PatternTab format with score
        if signal is None:
            signal = ""
        
        # Parse signal and score
        signal_with_score = ""
        
        # Check if signal already contains score in parentheses
        if "(" in signal and ")" in signal:
            signal_with_score = signal
        else:
            # For price patterns, we may need to derive score from confidence or other data
            # For now, display signal with confidence as score
            if signal:
                signal_with_score = f"{signal} ({confidence:.1f})"
            else:
                signal_with_score = f"({confidence:.1f})"
        
        # Color signal based on type
        color = None
        if any(keyword in signal.upper() for keyword in ["BULL", "UPWARD", "UP", "BUY", "LONG"]):
            color = Qt.darkGreen
        elif any(keyword in signal.upper() for keyword in ["BEAR", "DOWNWARD", "DOWN", "SELL", "SHORT"]):
            color = Qt.red
        elif any(keyword in signal.upper() for keyword in ["NEUTRAL", "SIDEWAYS", "CONSOLIDATION"]):
            color = Qt.darkYellow
        else:
            color = Qt.blue
        
        signal_item = QTableWidgetItem(signal_with_score)
        signal_item.setFont(QFont("Arial", 9, QFont.Bold))
        if color:
            signal_item.setForeground(color)
        
        self.table.setItem(row, 5, signal_item)
        
        # Confidence column (only show confidence value)
        confidence_text = f"{confidence:.2f}"
        confidence_item = QTableWidgetItem(confidence_text)
        confidence_item.setFont(QFont("Arial", 9, QFont.Bold))
        
        # Color based on confidence level
        if confidence >= 0.7:
            confidence_item.setForeground(Qt.darkGreen)
        elif confidence >= 0.5:
            confidence_item.setForeground(Qt.darkBlue)
        elif confidence >= 0.3:
            confidence_item.setForeground(Qt.darkYellow)
        else:
            confidence_item.setForeground(Qt.gray)
        
        self.table.setItem(row, 6, confidence_item)
        
        # Age column
        age_item = QTableWidgetItem(age_text)
        age_item.setFont(QFont("Arial", 9, QFont.Bold))
        age_item.setForeground(age_color)
        self.table.setItem(row, 7, age_item)

    def on_filter_changed(self):
        """Handle filter changes with debug information"""
        min_confidence = self.min_confidence_spinbox.value()
        max_age_days = self.max_age_spinbox.value()
        
        print(f"ðŸ”„ Price pattern filter changed: min_confidence={min_confidence}, max_age_days={max_age_days}")
        
        # Update status to show filter state
        self.status_label.setText(f"ðŸ”„ Loading patterns... (min_conf: {min_confidence}, max_age: {max_age_days}d)")
        
        # Load patterns with new filter
        self.load_patterns()
    
    def _update_whitelist(self, checked):
        """Update whitelist when price_patterns checkbox toggled"""
        try:
            print(f"\n{'='*60}")
            print(f"ðŸ”¥ [PricePatternTab] Price patterns checkbox toggled: {checked}")
            print(f"{'='*60}")
            
            import os, json
            wl_path = os.path.join(os.getcwd(), 'analysis_results', 'indicator_whitelist.json')
            
            # Read current whitelist
            wl = []
            if os.path.exists(wl_path):
                with open(wl_path, 'r', encoding='utf-8') as f:
                    wl = json.load(f)
            
            # ðŸ”¥ ONLY remove 'price_patterns' token (keep candlestick and other indicators)
            wl = [t for t in wl if t not in ('price_patterns', 'patterns')]
            
            # Add price_patterns if checked
            if checked:
                wl.append('price_patterns')
                print(f"âœ… Added 'price_patterns' to whitelist")
            else:
                print(f"âš ï¸ Removed 'price_patterns' from whitelist")
            
            # Save
            os.makedirs(os.path.dirname(wl_path), exist_ok=True)
            with open(wl_path, 'w', encoding='utf-8') as f:
                json.dump(wl, f, ensure_ascii=False, indent=2)
            
            print(f"ðŸ’¾ Saved whitelist: {wl}")
            
        except Exception as e:
            print(f"âŒ Error updating whitelist: {e}")
            import traceback
            traceback.print_exc()
    
    def refresh_translations(self):
        """Refresh all UI text when language changes"""
        try:
            self.enable_checkbox.setText(I18N.t("Enable price pattern detection", "Báº­t phÃ¡t hiá»‡n mÃ´ hÃ¬nh giÃ¡"))
            self.min_confidence_label.setText(I18N.t("ðŸ“Š Min confidence:", "ðŸ“Š Äá»™ tin cáº­y tá»‘i thiá»ƒu:"))
            self.max_age_label.setText(I18N.t("ðŸ“… Max age (days):", "ðŸ“… Tuá»•i tá»‘i Ä‘a (ngÃ y):"))
            self.fetch_pattern_btn.setText(I18N.t("ðŸ” Fetch Price Patterns", "ðŸ” Láº¥y mÃ´ hÃ¬nh giÃ¡"))
            self.table.setHorizontalHeaderLabels([I18N.t("Symbol", "MÃ£"), I18N.t("Timeframe", "Khung TG"), I18N.t("Time Period", "Khoáº£ng TG"), I18N.t("Pattern", "MÃ´ hÃ¬nh"), I18N.t("Length", "Äá»™ dÃ i"), I18N.t("Signal", "TÃ­n hiá»‡u"), I18N.t("Confidence", "Äá»™ tin cáº­y"), I18N.t("Age", "Tuá»•i")])
        except Exception as e:
            print(f"[LangSwitch] PricePatternTab refresh error: {e}")

class PatternWorker(QThread):
    finished = pyqtSignal()
    error = pyqtSignal(str)  # ThÃªm signal bÃ¡o lá»—i

    def __init__(self, symbols, timeframes, indicator_list):
        super().__init__()
        self.symbols = symbols
        self.timeframes = timeframes
        self.indicator_list = indicator_list if indicator_list is not None else []
    
    def run(self):
        try:
            from pattern_detector import analyze_patterns
            for symbol in self.symbols:
                for tf in self.timeframes:
                    print(f"âž¡ï¸ Analyzing {symbol} timeframe {tf} ...")
                    analyze_patterns(symbol, tf, self.indicator_list)
            self.finished.emit()
        except Exception as e:
            import traceback
            tb = traceback.format_exc()
            self.error.emit(f"Lá»—i khi phÃ¡t hiá»‡n mÃ´ hÃ¬nh náº¿n:\n{e}\n{tb}")

class PricePatternWorker(QThread):
    finished = pyqtSignal()
    error = pyqtSignal(str)

    def __init__(self, symbols, timeframes):
        super().__init__()
        self.symbols = symbols
        self.timeframes = timeframes

    def run(self):
        try:
            # Import and validate required modules
            try:
                from price_patterns_full_data import main as analyze_price_patterns
            except ImportError as e:
                self.error.emit(f"Failed to import price_patterns_full_data module:\n{e}")
                return
            
            # Validate input parameters
            if not self.symbols or not self.timeframes:
                self.error.emit("No symbols or timeframes selected for pattern analysis")
                return
            
            # Check if required folders exist
            import os
            required_folders = ["data", "indicator_output"]
            missing_folders = []
            for folder in required_folders:
                if not os.path.exists(folder):
                    missing_folders.append(folder)
            
            if missing_folders:
                self.error.emit(f"Missing required folders: {', '.join(missing_folders)}\nPlease run data and indicator fetching first.")
                return
            
            # Run pattern analysis with error handling
            analyze_price_patterns(symbols=self.symbols, timeframes=self.timeframes)
            self.finished.emit()
            
        except FileNotFoundError as e:
            self.error.emit(f"File not found error:\n{e}\n\nPlease ensure data files exist for selected symbols/timeframes.")
        except ImportError as e:
            self.error.emit(f"Import error:\n{e}\n\nPlease check if all required modules are available.")
        except Exception as e:
            import traceback
            tb = traceback.format_exc()
            self.error.emit(f"Error generating price patterns:\n{e}\n\nFull traceback:\n{tb}")

class IndicatorWorker(QThread):
    finished = pyqtSignal(str)
    error = pyqtSignal(str)  # ThÃªm dÃ²ng nÃ y
    def __init__(self, sym, tf, count, indicator_list):
        super().__init__()
        self.sym = sym
        self.tf = tf
        self.count = count
        self.indicator_list = indicator_list
        self._stop_requested = False

    def request_stop(self):
        """Request the worker to stop gracefully"""
        self._stop_requested = True

    def run(self):
        try:
            # Check for stop request before starting
            if self._stop_requested:
                return
                
            from mt5_indicator_exporter import export_indicators
            results = export_indicators(self.sym, self.tf, self.count, self.indicator_list)
          
            # Check for stop request before emitting
            if self._stop_requested:
                return
                
            msg = json.dumps({
                "symbol": self.sym,
                "timeframe": self.tf,
                "results": results
            })
            self.finished.emit(msg)
        except Exception as e:
            if not self._stop_requested:  # Only emit error if not stopping
                import traceback
                tb = traceback.format_exc()
                self.error.emit(f"ERROR for {self.sym} {self.tf}: {e}\n{tb}")

class TrendWorker(QThread):
    finished = pyqtSignal(dict)
    def __init__(self, symbol, timeframe, count):
        super().__init__()
        self.symbol = symbol
        self.timeframe = timeframe
        self.count = count
        self._stop_requested = False

    def request_stop(self):
        """Request the worker to stop gracefully"""
        self._stop_requested = True

    def run(self):
        try:
            # Check for stop request before starting
            if self._stop_requested:
                return
                
            try:
                from trendline_support_resistance import analyze_trend_channel_sr
                result = analyze_trend_channel_sr(self.symbol, self.timeframe, self.count)
                
                # Check for stop request before emitting
                if not self._stop_requested:
                    self.finished.emit(result)
            except ImportError as e:
                # Module not available, return empty result
                if not self._stop_requested:
                    self.finished.emit({"error": f"Trendline analysis module not available: {str(e)}"})
            except ValueError as e:
                # Handle data insufficient errors gracefully
                if not self._stop_requested:
                    if "Insufficient data" in str(e):
                        self.finished.emit({"error": f"Insufficient data for {self.symbol} {self.timeframe}: {str(e)}"})
                    else:
                        self.finished.emit({"error": f"Data validation error: {str(e)}"})
        except Exception as e:
            # Handle any other unexpected errors
            if not self._stop_requested:
                self.finished.emit({"error": f"Unexpected error in trend analysis: {str(e)}"})

class TrendTab(QWidget):
    def __init__(self, market_tab):
        super().__init__()
        self.market_tab = market_tab
        self.init_ui()
        self.workers = []
        self.pending = 0
        self.results = {}

    def init_ui(self):
        layout = QVBoxLayout()
        self.enable_checkbox = QCheckBox(I18N.t("Enable Trend Detection", "Báº­t phÃ¡t hiá»‡n xu hÆ°á»›ng"))
        self.enable_checkbox.setChecked(True)
        layout.addWidget(self.enable_checkbox)

        self.calc_btn = QPushButton(I18N.t("Calculate Trendline & SR", "TÃ­nh Trendline & S/R"))
        self.calc_btn.clicked.connect(self.on_calculate)
        layout.addWidget(self.calc_btn)

        self.result_label = QLabel("")
        layout.addWidget(self.result_label)

        self.table = QTableWidget(0, 4)
        self.table.setHorizontalHeaderLabels([I18N.t("Symbol", "MÃ£"), I18N.t("Timeframe", "Khung TG"), I18N.t("Type", "Loáº¡i"), I18N.t("Value", "GiÃ¡ trá»‹")])
        header = self.table.horizontalHeader()
        for i in range(self.table.columnCount()):
            header.setSectionResizeMode(i, QHeaderView.Stretch)
        layout.addWidget(self.table)
        self.setLayout(layout)

    def clear_all_trend_data(self):
        """Clear all saved trendline data files"""
        import os
        import shutil
        
        trendline_dir = "trendline_sr"
        if os.path.exists(trendline_dir):
            try:
                # Count files before deletion
                file_count = len([f for f in os.listdir(trendline_dir) if os.path.isfile(os.path.join(trendline_dir, f))])
                
                # Remove all files in trendline_sr directory
                shutil.rmtree(trendline_dir)
                os.makedirs(trendline_dir, exist_ok=True)
                
                print(f"ðŸ§¹ Trend Data Cleanup: Removed {file_count} old trendline files")
                
            except Exception as e:
                print(f"âš ï¸ Warning: Could not clear trendline data: {e}")
        else:
            # Create directory if it doesn't exist
            os.makedirs(trendline_dir, exist_ok=True)
            print("ðŸ“ Created trendline_sr directory")

    def on_calculate(self):
        if not self.enable_checkbox.isChecked():
            QMessageBox.information(self, I18N.t("Info", "ThÃ´ng tin"), I18N.t("Trend Detect is disabled!", "PhÃ¡t hiá»‡n xu hÆ°á»›ng Ä‘ang táº¯t!"))
            return
        
        # Dá»«ng táº¥t cáº£ worker cÅ© náº¿u cÃ²n cháº¡y
        for worker in self.workers:
            if worker.isRunning():
                worker.quit()
                worker.wait()
        self.workers = []
        
        symbols = list(self.market_tab.checked_symbols)
        timeframes = [tf for tf in self.market_tab.tf_checkboxes if self.market_tab.tf_checkboxes[tf].isChecked()]
        if not symbols or not timeframes:
            QMessageBox.warning(self, I18N.t("Warning", "Cáº£nh bÃ¡o"), I18N.t("Please select symbol and timeframe in Market tab.", "Vui lÃ²ng chá»n mÃ£ vÃ  khung thá»i gian trong tab Thá»‹ trÆ°á»ng."))
            return
            
        count = 200
        
        # ðŸ§¹ Clear all previous data immediately when starting new calculation
        self.clear_all_trend_data()
        
        self.table.setRowCount(0)
        self.table.clearContents()  # Clear all cell contents
        self.results = {}  # Clear results dict
        self.result_label.setText(I18N.t("Calculating...", "Äang tÃ­nh..."))
        
        self.pending = 0
        
        for symbol in symbols:
            for timeframe in timeframes:
                worker = TrendWorker(symbol, timeframe, count)
                # Use functools.partial to avoid lambda closure issues
                from functools import partial
                worker.finished.connect(partial(self.on_result_with_cleanup, symbol=symbol, timeframe=timeframe, worker=worker))
                self.workers.append(worker)
                self.pending += 1
                worker.start()
        self.calc_btn.setEnabled(False)

    def on_result_with_cleanup(self, result, symbol, timeframe, worker):
        """Handle result and cleanup worker"""
        # Cleanup the finished worker
        self.cleanup_worker(worker)
        
        # Process the result
        if "error" in result:
            error_msg = result['error']
            # Cáº£i thiá»‡n hiá»ƒn thá»‹ lá»—i vá»›i thÃ´ng tin symbol vÃ  timeframe
            full_error = f"Error for {symbol} {timeframe}: {error_msg}"
            self.result_label.setText(full_error)
            
            # Chá»‰ hiá»ƒn thá»‹ popup náº¿u khÃ´ng pháº£i lá»—i thiáº¿u dá»¯ liá»‡u thÃ´ng thÆ°á»ng
            if "Insufficient data" not in error_msg:
                QMessageBox.warning(self, I18N.t("Trend Analysis Warning", "Cáº£nh bÃ¡o phÃ¢n tÃ­ch xu hÆ°á»›ng"), full_error)
            else:
                # Log lá»—i thiáº¿u dá»¯ liá»‡u mÃ  khÃ´ng spam popup
                print(f"âš ï¸ Trend Analysis: {full_error}")
        else:
            key = (symbol, timeframe)
            self.results[key] = result
        self.pending -= 1
        if self.pending <= 0:
            self.display_results()
            self.calc_btn.setEnabled(True)

    def on_result(self, result, symbol, timeframe):
        """Legacy method for backward compatibility"""
        return self.on_result_with_cleanup(result, symbol, timeframe, None)

    def display_results(self):
        self.table.setRowCount(0)
        now_str = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        self.result_label.setText(f"Calculated for all selected symbols/timeframes at {now_str}")

        last_symbol = None
        last_timeframe = None

        for (symbol, timeframe), result in sorted(self.results.items()):
            # DÃ²ng phÃ¢n cÃ¡ch giá»¯a cÃ¡c nhÃ³m
            if last_symbol is not None and (symbol != last_symbol or timeframe != last_timeframe):
                row = self.table.rowCount()
                self.table.insertRow(row)
                for col in range(self.table.columnCount()):
                    item = QTableWidgetItem("")
                    item.setBackground(Qt.black)
                    self.table.setItem(row, col, item)

            # --- Trendline ---
            trendline_arr = result.get("trendline")
            slope = result.get("trend_slope")
            intercept = result.get("trend_intercept")
            max_dev = result.get("max_deviation")
            min_dev = result.get("min_deviation")
            if trendline_arr and isinstance(trendline_arr, list) and len(trendline_arr) > 0:
                trend_start = trendline_arr[0]
                trend_end = trendline_arr[-1]
                info = [f"{trend_start:.5f} - {trend_end:.5f}"]
                if slope is not None:
                    info.append(f"Slope: {slope:.5f}")
                if intercept is not None:
                    info.append(f"Intercept: {intercept:.5f}")
                if max_dev is not None:
                    info.append(f"MaxDev: {max_dev:.5f}")
                if min_dev is not None:
                    info.append(f"MinDev: {min_dev:.5f}")
                row = self.table.rowCount()

                self.table.insertRow(row)
                self.table.setItem(row, 0, QTableWidgetItem(symbol))
                self.table.setItem(row, 1, QTableWidgetItem(timeframe))
                self.table.setItem(row, 2, QTableWidgetItem("Trendline"))
                self.table.setItem(row, 3, QTableWidgetItem(" | ".join(info)))

            # --- Channel Upper ---
            channel_upper = result.get("channel_upper")
            if channel_upper and isinstance(channel_upper, list) and len(channel_upper) > 0:
                row = self.table.rowCount()
                self.table.insertRow(row)
                self.table.setItem(row, 0, QTableWidgetItem(symbol))
                self.table.setItem(row, 1, QTableWidgetItem(timeframe))
                self.table.setItem(row, 2, QTableWidgetItem("Channel Upper"))
                self.table.setItem(row, 3, QTableWidgetItem(f"{max(channel_upper):.5f}"))

            # --- Channel Lower ---
            channel_lower = result.get("channel_lower")
            if channel_lower and isinstance(channel_lower, list) and len(channel_lower) > 0:
                row = self.table.rowCount()
                self.table.insertRow(row)
                self.table.setItem(row, 0, QTableWidgetItem(symbol))
                self.table.setItem(row, 1, QTableWidgetItem(timeframe))
                self.table.setItem(row, 2, QTableWidgetItem("Channel Lower"))
                self.table.setItem(row, 3, QTableWidgetItem(f"{min(channel_lower):.5f}"))

            # --- Support/Resistance ---
            for lvl in result.get("support", []):
                sr_type = "Support"
                row = self.table.rowCount()
                self.table.insertRow(row)
                self.table.setItem(row, 0, QTableWidgetItem(symbol))
                self.table.setItem(row, 1, QTableWidgetItem(timeframe))
                self.table.setItem(row, 2, QTableWidgetItem(sr_type))
                self.table.setItem(row, 3, QTableWidgetItem(f"{lvl:.5f}"))

            for lvl in result.get("resistance", []):
                sr_type = "Resistance"
                row = self.table.rowCount()
                self.table.insertRow(row)
                self.table.setItem(row, 0, QTableWidgetItem(symbol))
                self.table.setItem(row, 1, QTableWidgetItem(timeframe))
                self.table.setItem(row, 2, QTableWidgetItem(sr_type))
                self.table.setItem(row, 3, QTableWidgetItem(f"{lvl:.5f}"))

            last_symbol = symbol
            last_timeframe = timeframe
    
    def cleanup_worker(self, worker):
        """Cleanup finished worker thread"""
        if worker in self.workers:
            try:
                # Request graceful stop first
                if hasattr(worker, 'request_stop'):
                    worker.request_stop()
                
                # Properly terminate the thread before cleanup
                if worker.isRunning():
                    worker.quit()
                    worker.wait(3000)  # Wait up to 3 seconds for thread to finish
                self.workers.remove(worker)
                worker.deleteLater()
            except Exception as e:
                print(f"Warning: Error cleaning up trend worker: {e}")
                # Force removal from list even if cleanup fails
                if worker in self.workers:
                    self.workers.remove(worker)
    
    def stop_all_workers(self):
        """Stop all running trend workers"""
        for worker in getattr(self, "workers", []):
            try:
                # Request graceful stop first
                if hasattr(worker, 'request_stop'):
                    worker.request_stop()
                
                if worker.isRunning():
                    worker.quit()
                    worker.wait(3000)
            except Exception:
                pass
        self.workers = []
    
    def refresh_translations(self):
        """Refresh all UI text when language changes"""
        try:
            self.enable_checkbox.setText(I18N.t("Enable Trend Detection", "Báº­t phÃ¡t hiá»‡n xu hÆ°á»›ng"))
            self.calc_btn.setText(I18N.t("Calculate Trendline & SR", "TÃ­nh Trendline & S/R"))
            self.table.setHorizontalHeaderLabels([I18N.t("Symbol", "MÃ£"), I18N.t("Timeframe", "Khung TG"), I18N.t("Type", "Loáº¡i"), I18N.t("Value", "GiÃ¡ trá»‹")])
        except Exception as e:
            print(f"[LangSwitch] TrendTab refresh error: {e}")


class PricingDialog(QDialog):
    """Dialog hiá»ƒn thá»‹ báº£ng giÃ¡ gia háº¡n license"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle(I18N.t("ðŸ’° Pricing Plans", "ðŸ’° Báº£ng GiÃ¡ Gia Háº¡n"))
        self.setMinimumWidth(550)
        self.setModal(True)
        self.init_ui()
    
    def init_ui(self):
        layout = QVBoxLayout()
        layout.setSpacing(15)
        
        # Header
        header = QLabel(I18N.t("ðŸ’° License Pricing Plans", "ðŸ’° Báº£ng GiÃ¡ Gia Háº¡n License"))
        header.setStyleSheet("font-size: 20px; font-weight: bold; color: #2196F3; margin-bottom: 10px;")
        header.setAlignment(Qt.AlignCenter)
        layout.addWidget(header)
        
        # Instruction
        instruction = QLabel(I18N.t("ðŸ‘† Click on a plan to view payment details", "ðŸ‘† Nháº¥n vÃ o gÃ³i Ä‘á»ƒ xem thÃ´ng tin thanh toÃ¡n"))
        instruction.setStyleSheet("font-size: 12px; color: #666; font-style: italic;")
        instruction.setAlignment(Qt.AlignCenter)
        layout.addWidget(instruction)
        
        # Pricing table
        pricing_group = QGroupBox(I18N.t("Choose Your Plan", "Chá»n GÃ³i PhÃ¹ Há»£p"))
        pricing_layout = QVBoxLayout()
        
        # Plan cards - now clickable buttons
        self.plans = [
            {"duration": I18N.t("1 Month", "1 ThÃ¡ng"), "months": 1, "price": "$199", "save": "", "color": "#4CAF50"},
            {"duration": I18N.t("3 Months", "3 ThÃ¡ng"), "months": 3, "price": "$499", "save": I18N.t("Save $98", "Tiáº¿t kiá»‡m $98"), "color": "#2196F3"},
            {"duration": I18N.t("6 Months", "6 ThÃ¡ng"), "months": 6, "price": "$799", "save": I18N.t("Save $395", "Tiáº¿t kiá»‡m $395"), "color": "#FF9800"},
            {"duration": I18N.t("1 Year", "1 NÄƒm"), "months": 12, "price": "$1299", "save": I18N.t("Save $1089", "Tiáº¿t kiá»‡m $1089"), "color": "#E91E63", "best": True},
        ]
        
        for plan in self.plans:
            plan_btn = QPushButton()
            plan_btn.setCursor(Qt.PointingHandCursor)
            plan_btn.setStyleSheet(f"""
                QPushButton {{
                    background-color: white;
                    border: 2px solid {plan['color']};
                    border-radius: 10px;
                    padding: 15px;
                    text-align: left;
                }}
                QPushButton:hover {{
                    background-color: {plan['color']}20;
                    border: 3px solid {plan['color']};
                }}
            """)
            
            # Create button content
            btn_layout = QHBoxLayout(plan_btn)
            btn_layout.setContentsMargins(10, 5, 10, 5)
            
            # Duration
            duration_label = QLabel(plan["duration"])
            duration_label.setStyleSheet(f"font-size: 16px; font-weight: bold; color: {plan['color']}; background: transparent;")
            duration_label.setFixedWidth(100)
            btn_layout.addWidget(duration_label)
            
            # Price
            price_label = QLabel(plan["price"])
            price_label.setStyleSheet("font-size: 24px; font-weight: bold; color: #333; background: transparent;")
            price_label.setFixedWidth(80)
            btn_layout.addWidget(price_label)
            
            # Save amount
            if plan.get("save"):
                save_label = QLabel(plan["save"])
                save_label.setStyleSheet("font-size: 12px; color: #4CAF50; font-weight: bold; background: transparent;")
                btn_layout.addWidget(save_label)
            
            # Best value badge
            if plan.get("best"):
                best_label = QLabel(I18N.t("â­ BEST VALUE", "â­ Æ¯U ÄÃƒI NHáº¤T"))
                best_label.setStyleSheet("font-size: 11px; color: white; background-color: #E91E63; padding: 3px 8px; border-radius: 5px; font-weight: bold;")
                btn_layout.addWidget(best_label)
            
            btn_layout.addStretch()
            
            # Arrow indicator
            arrow_label = QLabel("â†’")
            arrow_label.setStyleSheet(f"font-size: 20px; color: {plan['color']}; font-weight: bold; background: transparent;")
            btn_layout.addWidget(arrow_label)
            
            # Connect click event
            plan_btn.clicked.connect(lambda checked, p=plan: self.show_payment_details(p))
            
            pricing_layout.addWidget(plan_btn)
        
        pricing_group.setLayout(pricing_layout)
        layout.addWidget(pricing_group)
        
        # Close button
        close_btn = QPushButton(I18N.t("Close", "ÄÃ³ng"))
        close_btn.setStyleSheet("""
            QPushButton {
                background-color: #607D8B;
                color: white;
                font-weight: bold;
                padding: 10px 30px;
                border: none;
                border-radius: 5px;
                font-size: 14px;
            }
            QPushButton:hover {
                background-color: #455A64;
            }
        """)
        close_btn.clicked.connect(self.accept)
        layout.addWidget(close_btn, alignment=Qt.AlignCenter)
        
        self.setLayout(layout)
    
    def show_payment_details(self, plan):
        """Hiá»ƒn thá»‹ dialog chi tiáº¿t thanh toÃ¡n cho gÃ³i Ä‘Ã£ chá»n"""
        payment_dialog = PaymentDetailsDialog(plan, self)
        payment_dialog.exec_()


class PaymentDetailsDialog(QDialog):
    """Dialog hiá»ƒn thá»‹ chi tiáº¿t thanh toÃ¡n vá»›i PayOS integration"""
    
    def __init__(self, plan, parent=None):
        super().__init__(parent)
        self.plan = plan
        self.payment_data = None  # LÆ°u thÃ´ng tin payment tá»« PayOS
        self.order_code = None
        self.setWindowTitle(I18N.t(f"ðŸ’³ Payment - {plan['duration']}", f"ðŸ’³ Thanh ToÃ¡n - {plan['duration']}"))
        self.setMinimumWidth(550)
        self.setModal(True)
        self.init_ui()
    
    def init_ui(self):
        layout = QVBoxLayout()
        layout.setSpacing(15)
        
        # Header with plan info
        header = QLabel(I18N.t(f"ðŸ“¦ Selected Plan: {self.plan['duration']}", f"ðŸ“¦ GÃ³i ÄÃ£ Chá»n: {self.plan['duration']}"))
        header.setStyleSheet(f"font-size: 18px; font-weight: bold; color: {self.plan['color']}; padding: 10px;")
        header.setAlignment(Qt.AlignCenter)
        layout.addWidget(header)
        
        # Price summary
        price_group = QGroupBox(I18N.t("ðŸ’° Price Summary", "ðŸ’° Tá»•ng Thanh ToÃ¡n"))
        price_layout = QVBoxLayout()
        
        price_info = QLabel(f"""
            <table style='width: 100%;'>
                <tr>
                    <td style='font-size: 14px;'>{I18N.t('Plan:', 'GÃ³i:')}</td>
                    <td style='font-size: 14px; font-weight: bold; text-align: right;'>{self.plan['duration']}</td>
                </tr>
                <tr>
                    <td style='font-size: 14px;'>{I18N.t('Amount:', 'Sá»‘ tiá»n:')}</td>
                    <td style='font-size: 22px; font-weight: bold; color: #E91E63; text-align: right;'>{self.plan['price']}</td>
                </tr>
            </table>
        """)
        price_info.setTextFormat(Qt.RichText)
        price_info.setStyleSheet("padding: 15px; background-color: #FFF3E0; border-radius: 8px;")
        price_layout.addWidget(price_info)
        
        price_group.setLayout(price_layout)
        layout.addWidget(price_group)
        
        # Payment Methods Tabs
        self.payment_tabs = QTabWidget()
        self.payment_tabs.setStyleSheet("""
            QTabWidget::pane {
                border: 1px solid #ddd;
                border-radius: 8px;
                background: white;
            }
            QTabBar::tab {
                background: #f0f0f0;
                padding: 10px 20px;
                margin-right: 2px;
                border-top-left-radius: 8px;
                border-top-right-radius: 8px;
                font-weight: bold;
            }
            QTabBar::tab:selected {
                background: white;
                border-bottom: 2px solid #2196F3;
            }
        """)
        
        # ===== TAB 1: PAYOS AUTO PAYMENT =====
        self.payos_tab = QWidget()
        self.payos_tab_layout = QVBoxLayout(self.payos_tab)
        
        # Loading indicator
        self.loading_label = QLabel(I18N.t("â³ Creating payment...", "â³ Äang táº¡o thanh toÃ¡n..."))
        self.loading_label.setStyleSheet("font-size: 16px; color: #666; padding: 30px;")
        self.loading_label.setAlignment(Qt.AlignCenter)
        self.payos_tab_layout.addWidget(self.loading_label)
        
        # QR and info container (hidden initially)
        self.payos_content = QWidget()
        self.payos_content.setVisible(False)
        payos_content_layout = QVBoxLayout(self.payos_content)
        
        # Auto badge
        auto_badge = QLabel(I18N.t("ðŸš€ AUTO ACTIVATE - No wait!", "ðŸš€ Tá»° Äá»˜NG KÃCH HOáº T - KhÃ´ng cáº§n chá»!"))
        auto_badge.setStyleSheet("""
            font-size: 14px; font-weight: bold; color: white; 
            background-color: #4CAF50; padding: 8px 15px; border-radius: 5px;
        """)
        auto_badge.setAlignment(Qt.AlignCenter)
        payos_content_layout.addWidget(auto_badge)
        
        # QR Code and Bank Info side by side
        qr_bank_layout = QHBoxLayout()
        
        # QR Code from PayOS
        qr_frame = QFrame()
        qr_frame.setStyleSheet("background-color: white; border-radius: 10px; padding: 5px;")
        qr_inner_layout = QVBoxLayout(qr_frame)
        
        self.payos_qr_label = QLabel()
        self.payos_qr_label.setAlignment(Qt.AlignCenter)
        self.payos_qr_label.setMinimumSize(200, 200)
        qr_inner_layout.addWidget(self.payos_qr_label)
        
        qr_hint = QLabel(I18N.t("Scan QR to pay", "QuÃ©t mÃ£ Ä‘á»ƒ thanh toÃ¡n"))
        qr_hint.setStyleSheet("font-size: 11px; color: #666; font-style: italic;")
        qr_hint.setAlignment(Qt.AlignCenter)
        qr_inner_layout.addWidget(qr_hint)
        
        qr_bank_layout.addWidget(qr_frame)
        
        # Bank info tá»« PayOS
        self.bank_info_label = QLabel()
        self.bank_info_label.setTextFormat(Qt.RichText)
        self.bank_info_label.setStyleSheet("padding: 10px; background-color: #E3F2FD; border-radius: 8px; font-size: 12px;")
        self.bank_info_label.setWordWrap(True)
        qr_bank_layout.addWidget(self.bank_info_label, 1)
        
        payos_content_layout.addLayout(qr_bank_layout)
        
        # Amount VND display
        self.amount_vnd_label = QLabel()
        self.amount_vnd_label.setStyleSheet("""
            font-size: 18px; font-weight: bold; color: #E91E63; 
            padding: 10px; background-color: #FCE4EC; border-radius: 5px;
        """)
        self.amount_vnd_label.setAlignment(Qt.AlignCenter)
        payos_content_layout.addWidget(self.amount_vnd_label)
        
        # Open checkout button
        self.open_checkout_btn = QPushButton(I18N.t("ðŸŒ Open Payment Page", "ðŸŒ Má»Ÿ Trang Thanh ToÃ¡n"))
        self.open_checkout_btn.setStyleSheet("""
            QPushButton {
                background-color: #2196F3;
                color: white;
                font-weight: bold;
                padding: 12px 20px;
                border: none;
                border-radius: 5px;
                font-size: 14px;
            }
            QPushButton:hover {
                background-color: #1976D2;
            }
        """)
        self.open_checkout_btn.clicked.connect(self.open_checkout_url)
        payos_content_layout.addWidget(self.open_checkout_btn)
        
        # Check payment status button
        self.check_status_btn = QPushButton(I18N.t("ðŸ”„ Check Payment Status", "ðŸ”„ Kiá»ƒm Tra Tráº¡ng ThÃ¡i"))
        self.check_status_btn.setStyleSheet("""
            QPushButton {
                background-color: #FF9800;
                color: white;
                font-weight: bold;
                padding: 10px 20px;
                border: none;
                border-radius: 5px;
                font-size: 13px;
            }
            QPushButton:hover {
                background-color: #F57C00;
            }
        """)
        self.check_status_btn.clicked.connect(self.check_payment_status)
        payos_content_layout.addWidget(self.check_status_btn)
        
        self.payos_tab_layout.addWidget(self.payos_content)
        
        self.payment_tabs.addTab(self.payos_tab, I18N.t("ðŸ¦ Bank", "ðŸ¦ NgÃ¢n HÃ ng"))
        
        # ===== TAB 2: CRYPTO (NOWPayments - Auto) =====
        self.crypto_tab = QWidget()
        self.crypto_tab_layout = QVBoxLayout(self.crypto_tab)
        
        # Loading label for crypto
        self.crypto_loading_label = QLabel(I18N.t("â³ Creating crypto payment...", "â³ Äang táº¡o thanh toÃ¡n crypto..."))
        self.crypto_loading_label.setAlignment(Qt.AlignCenter)
        self.crypto_loading_label.setStyleSheet("font-size: 14px; color: #FF9800; padding: 20px;")
        self.crypto_tab_layout.addWidget(self.crypto_loading_label)
        
        # Crypto payment content (hidden initially)
        self.crypto_content = QWidget()
        self.crypto_content.setVisible(False)
        crypto_content_layout = QVBoxLayout(self.crypto_content)
        
        # Crypto amount info
        self.crypto_amount_label = QLabel()
        self.crypto_amount_label.setStyleSheet("""
            font-size: 14px; font-weight: bold; color: #26A17B; 
            padding: 10px; background-color: #E8F5E9; border-radius: 5px;
        """)
        self.crypto_amount_label.setAlignment(Qt.AlignCenter)
        crypto_content_layout.addWidget(self.crypto_amount_label)
        
        # QR Code and Wallet Info side by side
        qr_crypto_layout = QHBoxLayout()
        
        # QR Code for crypto address
        crypto_qr_frame = QFrame()
        crypto_qr_frame.setStyleSheet("background-color: white; border-radius: 10px; padding: 5px;")
        crypto_qr_inner_layout = QVBoxLayout(crypto_qr_frame)
        
        self.crypto_qr_label = QLabel()
        self.crypto_qr_label.setAlignment(Qt.AlignCenter)
        self.crypto_qr_label.setMinimumSize(180, 180)
        crypto_qr_inner_layout.addWidget(self.crypto_qr_label)
        
        crypto_qr_hint = QLabel(I18N.t("Scan to pay", "QuÃ©t mÃ£ Ä‘á»ƒ thanh toÃ¡n"))
        crypto_qr_hint.setStyleSheet("font-size: 11px; color: #666; font-style: italic;")
        crypto_qr_hint.setAlignment(Qt.AlignCenter)
        crypto_qr_inner_layout.addWidget(crypto_qr_hint)
        
        qr_crypto_layout.addWidget(crypto_qr_frame)
        
        # Crypto wallet info - dynamic
        self.crypto_info_label = QLabel()
        self.crypto_info_label.setTextFormat(Qt.RichText)
        self.crypto_info_label.setStyleSheet("padding: 10px; background-color: #E8F5E9; border-radius: 8px; font-size: 12px;")
        self.crypto_info_label.setWordWrap(True)
        qr_crypto_layout.addWidget(self.crypto_info_label, 1)
        
        crypto_content_layout.addLayout(qr_crypto_layout)
        
        # Copy wallet address button
        self.copy_crypto_btn = QPushButton(I18N.t("ðŸ“‹ Copy Wallet Address", "ðŸ“‹ Sao ChÃ©p Äá»‹a Chá»‰ VÃ­"))
        self.copy_crypto_btn.setStyleSheet("""
            QPushButton {
                background-color: #26A17B;
                color: white;
                font-weight: bold;
                padding: 10px 15px;
                border: none;
                border-radius: 5px;
                font-size: 13px;
            }
            QPushButton:hover {
                background-color: #1E8E6B;
            }
        """)
        self.copy_crypto_btn.clicked.connect(self.copy_crypto_address)
        crypto_content_layout.addWidget(self.copy_crypto_btn)
        
        # Check crypto payment status button
        self.check_crypto_btn = QPushButton(I18N.t("ðŸ”„ Check Payment Status", "ðŸ”„ Kiá»ƒm Tra Tráº¡ng ThÃ¡i"))
        self.check_crypto_btn.setStyleSheet("""
            QPushButton {
                background-color: #FF9800;
                color: white;
                font-weight: bold;
                padding: 10px 15px;
                border: none;
                border-radius: 5px;
                font-size: 13px;
            }
            QPushButton:hover {
                background-color: #F57C00;
            }
        """)
        self.check_crypto_btn.clicked.connect(self.check_crypto_payment_status)
        crypto_content_layout.addWidget(self.check_crypto_btn)
        
        self.crypto_tab_layout.addWidget(self.crypto_content)
        
        self.payment_tabs.addTab(self.crypto_tab, I18N.t("ðŸ’Ž Crypto", "ðŸ’Ž Crypto"))
        
        layout.addWidget(self.payment_tabs)
        
        # USD rate is fetched together with payment creation (no separate call needed)
        
        # Create crypto payment when switching to crypto tab
        self.payment_tabs.currentChanged.connect(self.on_payment_tab_changed)
        
        # Contact info (for crypto payments)
        contact_group = QGroupBox(I18N.t("ðŸ“ž Support Contact", "ðŸ“ž LiÃªn Há»‡ Há»— Trá»£"))
        contact_layout = QVBoxLayout()
        
        contact_info = QLabel(I18N.t(
            """ðŸ‘¤ <b>Admin Hiáº¿n VÅ© CFDs</b><br>
            ðŸ“± <b>Zalo/Telegram:</b> <span style='font-size: 14px; color: #4CAF50; font-weight: bold;'>0396560888</span>""",
            """ðŸ‘¤ <b>Admin Hiáº¿n VÅ© CFDs</b><br>
            ðŸ“± <b>Zalo/Telegram:</b> <span style='font-size: 14px; color: #4CAF50; font-weight: bold;'>0396560888</span>"""
        ))
        contact_info.setTextFormat(Qt.RichText)
        contact_info.setStyleSheet("padding: 10px; background-color: #E8F5E9; border-radius: 8px; font-size: 12px;")
        contact_info.setWordWrap(True)
        contact_layout.addWidget(contact_info)
        
        contact_group.setLayout(contact_layout)
        layout.addWidget(contact_group)
        
        # Buttons
        btn_layout = QHBoxLayout()
        
        back_btn = QPushButton(I18N.t("â† Back", "â† Quay Láº¡i"))
        back_btn.setStyleSheet("""
            QPushButton {
                background-color: #607D8B;
                color: white;
                font-weight: bold;
                padding: 10px 25px;
                border: none;
                border-radius: 5px;
                font-size: 13px;
            }
            QPushButton:hover {
                background-color: #455A64;
            }
        """)
        back_btn.clicked.connect(self.reject)
        
        btn_layout.addWidget(back_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        
        self.setLayout(layout)
        
        # Auto create PayOS payment when dialog opens
        QTimer.singleShot(500, self.create_payos_payment)
    
    def create_payos_payment(self):
        """Táº¡o payment qua PayOS API"""
        import requests
        try:
            from license_client import get_license_client
            client = get_license_client(server_url=LICENSE_SERVER_URL)
            
            # Láº¥y valid token (tá»± Ä‘á»™ng refresh náº¿u cáº§n)
            token = client.get_valid_token()
            
            print(f"[PayOS Debug] Client: {client}")
            print(f"[PayOS Debug] Access token: {token[:30] if token else 'None'}...")
            print(f"[PayOS Debug] Server URL: {LICENSE_SERVER_URL}")
            print(f"[PayOS Debug] Is authenticated: {client.is_authenticated}")
            
            if not token:
                # Thá»­ kiá»ƒm tra xem user Ä‘Ã£ authenticated chÆ°a (cÃ³ thá»ƒ token chÆ°a load tá»« cache)
                if client.is_authenticated:
                    # User Ä‘Ã£ login nhÆ°ng khÃ´ng cÃ³ access token - thá»­ dÃ¹ng license_key Ä‘á»ƒ táº¡o session má»›i
                    print("[PayOS Debug] User authenticated but no token - trying to refresh session...")
                    # Reload cache Ä‘á»ƒ láº¥y token
                    client._load_cached_license()
                    token = client.get_valid_token()
                
                if not token:
                    self.loading_label.setText(I18N.t("âŒ Please login first", "âŒ Vui lÃ²ng Ä‘Äƒng nháº­p trÆ°á»›c"))
                    self.loading_label.setStyleSheet("font-size: 14px; color: #F44336; padding: 20px;")
                    return
            
            # Map duration to plan_id
            plan_map = {
                '1 Month': 1, '1 ThÃ¡ng': 1,
                '3 Months': 2, '3 ThÃ¡ng': 2,
                '6 Months': 3, '6 ThÃ¡ng': 3,
                '12 Months': 4, '12 ThÃ¡ng': 4, '1 Year': 4, '1 NÄƒm': 4
            }
            plan_id = plan_map.get(self.plan['duration'], 1)
            print(f"[PayOS Debug] Plan: {self.plan['duration']} -> plan_id: {plan_id}")
            
            # Call API
            headers = {'Authorization': f'Bearer {token}'}
            print(f"[PayOS Debug] Calling: {LICENSE_SERVER_URL}/payment/create/")
            
            response = requests.post(
                f"{LICENSE_SERVER_URL}/payment/create/",
                json={'plan_id': plan_id},
                headers=headers,
                timeout=30
            )
            
            print(f"[PayOS Debug] Response status: {response.status_code}")
            print(f"[PayOS Debug] Response: {response.text[:500]}")
            
            if response.status_code == 200:
                data = response.json()
                if data.get('success'):
                    self.payment_data = data
                    self.order_code = data.get('order_code')
                    self.checkout_url = data.get('checkout_url')
                    
                    # Generate QR from qr_code string
                    qr_string = data.get('qr_code', '')
                    amount_vnd = data.get('amount_vnd', 0)
                    amount_usd = data.get('amount_usd', 0)
                    usd_rate = data.get('usd_rate', 25500)
                    
                    # Create QR image
                    self.generate_qr_image(qr_string)
                    
                    # Update bank info with rate
                    self.bank_info_label.setText(I18N.t(
                        f"""<b>ðŸ¦ Bank Transfer Info</b><br><br>
                        <b>Order Code:</b> <span style='color: #E91E63;'>{self.order_code}</span><br><br>
                        <b>Price:</b> <span style='color: #2196F3;'>${amount_usd:.0f}</span><br>
                        <b>Rate:</b> <span style='color: #FF9800;'>1 USD = {usd_rate:,.0f} VND</span><br><br>
                        <b>Amount to pay:</b><br>
                        <span style='font-size: 20px; font-weight: bold; color: #E91E63;'>{amount_vnd:,.0f} VND</span><br><br>
                        <span style='color: #4CAF50; font-size: 11px;'>âœ… Auto-activate after payment!</span>""",
                        f"""<b>ðŸ¦ ThÃ´ng Tin Chuyá»ƒn Khoáº£n</b><br><br>
                        <b>MÃ£ Ä‘Æ¡n:</b> <span style='color: #E91E63;'>{self.order_code}</span><br><br>
                        <b>GiÃ¡ gá»‘c:</b> <span style='color: #2196F3;'>${amount_usd:.0f}</span><br>
                        <b>Tá»· giÃ¡:</b> <span style='color: #FF9800;'>1 USD = {usd_rate:,.0f} VND</span><br><br>
                        <b>Sá»‘ tiá»n cáº§n chuyá»ƒn:</b><br>
                        <span style='font-size: 20px; font-weight: bold; color: #E91E63;'>{amount_vnd:,.0f} VND</span><br><br>
                        <span style='color: #4CAF50; font-size: 11px;'>âœ… Tá»± Ä‘á»™ng kÃ­ch hoáº¡t sau thanh toÃ¡n!</span>"""
                    ))
                    
                    self.amount_vnd_label.setText(I18N.t(
                        f"ðŸ’° ${amount_usd:.0f} Ã— {usd_rate:,.0f} = {amount_vnd:,.0f} VND",
                        f"ðŸ’° ${amount_usd:.0f} Ã— {usd_rate:,.0f} = {amount_vnd:,.0f} VND"
                    ))
                    
                    # Show content, hide loading
                    self.loading_label.setVisible(False)
                    self.payos_content.setVisible(True)
                else:
                    self.loading_label.setText(I18N.t(
                        f"âŒ Error: {data.get('error', 'Unknown')}",
                        f"âŒ Lá»—i: {data.get('error', 'KhÃ´ng xÃ¡c Ä‘á»‹nh')}"
                    ))
            else:
                self.loading_label.setText(I18N.t(
                    f"âŒ Server error: {response.status_code}",
                    f"âŒ Lá»—i server: {response.status_code}"
                ))
                
        except Exception as e:
            print(f"[PayOS] Error: {e}")
            self.loading_label.setText(I18N.t(
                f"âŒ Connection error",
                f"âŒ Lá»—i káº¿t ná»‘i server"
            ))
    
    def generate_qr_image(self, qr_string):
        """Táº¡o QR image tá»« string"""
        try:
            import qrcode
            qr = qrcode.QRCode(version=1, box_size=5, border=2)
            qr.add_data(qr_string)
            qr.make(fit=True)
            
            img = qr.make_image(fill_color="black", back_color="white")
            
            # Convert to QPixmap
            from io import BytesIO
            buffer = BytesIO()
            img.save(buffer, format='PNG')
            buffer.seek(0)
            
            pixmap = QPixmap()
            pixmap.loadFromData(buffer.read())
            self.payos_qr_label.setPixmap(pixmap.scaled(200, 200, Qt.KeepAspectRatio, Qt.SmoothTransformation))
            
        except ImportError:
            # Fallback: show text if qrcode not installed
            self.payos_qr_label.setText(I18N.t("Open payment page\nto scan QR", "Má»Ÿ trang thanh toÃ¡n\nÄ‘á»ƒ quÃ©t QR"))
            self.payos_qr_label.setStyleSheet("font-size: 12px; color: #666; padding: 50px;")
        except Exception as e:
            print(f"[QR] Error: {e}")
            self.payos_qr_label.setText("QR Error")
    
    def open_checkout_url(self):
        """Má»Ÿ trang thanh toÃ¡n PayOS"""
        if hasattr(self, 'checkout_url') and self.checkout_url:
            import webbrowser
            webbrowser.open(self.checkout_url)
        else:
            QMessageBox.warning(self, "Error", I18N.t("No checkout URL available", "KhÃ´ng cÃ³ link thanh toÃ¡n"))
    
    def check_payment_status(self):
        """Kiá»ƒm tra tráº¡ng thÃ¡i thanh toÃ¡n"""
        import requests
        if not self.order_code:
            QMessageBox.warning(self, "Error", I18N.t("No order to check", "KhÃ´ng cÃ³ Ä‘Æ¡n hÃ ng Ä‘á»ƒ kiá»ƒm tra"))
            return
        
        try:
            from license_client import get_license_client
            client = get_license_client()
            token = client.get_valid_token()
            
            headers = {'Authorization': f'Bearer {token}'}
            response = requests.get(
                f"{LICENSE_SERVER_URL}/payment/status/{self.order_code}/",
                headers=headers,
                timeout=30
            )
            
            if response.status_code == 200:
                data = response.json()
                status = data.get('status', 'unknown')
                
                if status == 'completed':
                    QMessageBox.information(self, 
                        I18N.t("âœ… Payment Successful!", "âœ… Thanh ToÃ¡n ThÃ nh CÃ´ng!"),
                        I18N.t(
                            "Your payment has been received!\nLicense has been activated automatically.\n\nPlease restart the app to see changes.",
                            "Thanh toÃ¡n cá»§a báº¡n Ä‘Ã£ Ä‘Æ°á»£c nháº­n!\nLicense Ä‘Ã£ Ä‘Æ°á»£c kÃ­ch hoáº¡t tá»± Ä‘á»™ng.\n\nVui lÃ²ng khá»Ÿi Ä‘á»™ng láº¡i app Ä‘á»ƒ tháº¥y thay Ä‘á»•i."
                        ))
                    self.accept()
                elif status == 'pending':
                    QMessageBox.information(self, 
                        I18N.t("â³ Pending", "â³ Äang Chá»"),
                        I18N.t("Payment not received yet. Please complete the transfer.", 
                               "ChÆ°a nháº­n Ä‘Æ°á»£c thanh toÃ¡n. Vui lÃ²ng hoÃ n táº¥t chuyá»ƒn khoáº£n."))
                else:
                    QMessageBox.warning(self, 
                        I18N.t("Status", "Tráº¡ng ThÃ¡i"),
                        I18N.t(f"Payment status: {status}", f"Tráº¡ng thÃ¡i: {status}"))
            else:
                QMessageBox.warning(self, "Error", f"Server error: {response.status_code}")
                
        except Exception as e:
            QMessageBox.warning(self, "Error", str(e))
    
    def copy_wallet_address(self):
        """Copy Ä‘á»‹a chá»‰ vÃ­ USDT TRC20 vÃ o clipboard"""
        from PyQt5.QtWidgets import QApplication
        clipboard = QApplication.clipboard()
        clipboard.setText("TJ2Ydkh6wFxZy1KSpL39f18RdXXrx5vHZw")
        QMessageBox.information(self, 
            I18N.t("Copied!", "ÄÃ£ sao chÃ©p!"),
            I18N.t("USDT TRC20 wallet address copied to clipboard", "Äá»‹a chá»‰ vÃ­ USDT TRC20 Ä‘Ã£ Ä‘Æ°á»£c sao chÃ©p"))
    
    def on_payment_tab_changed(self, index):
        """Xá»­ lÃ½ khi chuyá»ƒn tab thanh toÃ¡n"""
        # Tab 1 = Crypto (index 1)
        if index == 1 and not hasattr(self, 'crypto_payment_created'):
            QTimer.singleShot(500, self.create_crypto_payment)
    
    def create_crypto_payment(self):
        """Táº¡o payment crypto qua NOWPayments"""
        import requests
        try:
            from license_client import get_license_client
            client = get_license_client(server_url=LICENSE_SERVER_URL)
            # Láº¥y valid token (tá»± Ä‘á»™ng refresh náº¿u cáº§n)
            token = client.get_valid_token()
            
            if not token:
                # Thá»­ reload cache náº¿u user Ä‘Ã£ authenticated
                if client.is_authenticated:
                    client._load_cached_license()
                    token = client.get_valid_token()
                    
                if not token:
                    self.crypto_loading_label.setText(I18N.t("âŒ Please login first", "âŒ Vui lÃ²ng Ä‘Äƒng nháº­p trÆ°á»›c"))
                    self.crypto_loading_label.setStyleSheet("font-size: 14px; color: #F44336; padding: 20px;")
                    return
            
            # Map duration to plan_id
            plan_map = {
                '1 Month': 1, '1 ThÃ¡ng': 1,
                '3 Months': 2, '3 ThÃ¡ng': 2,
                '6 Months': 3, '6 ThÃ¡ng': 3,
                '12 Months': 4, '12 ThÃ¡ng': 4, '1 Year': 4, '1 NÄƒm': 4
            }
            plan_id = plan_map.get(self.plan['duration'], 1)
            
            headers = {'Authorization': f'Bearer {token}'}
            
            response = requests.post(
                f"{LICENSE_SERVER_URL}/crypto/create/",
                json={'plan_id': plan_id, 'currency': 'usdttrc20'},
                headers=headers,
                timeout=30
            )
            
            print(f"[Crypto Debug] Response: {response.status_code} - {response.text[:500]}")
            
            if response.status_code == 200:
                data = response.json()
                if data.get('success'):
                    self.crypto_payment_created = True
                    self.crypto_payment_data = data
                    self.crypto_order_id = data.get('order_id')
                    self.crypto_pay_address = data.get('pay_address')
                    self.crypto_pay_amount = data.get('pay_amount')
                    
                    # Generate QR for wallet address
                    self.generate_crypto_qr(self.crypto_pay_address)
                    
                    # Update crypto info
                    amount_usd = data.get('amount_usd', 0)
                    pay_currency = data.get('pay_currency', 'USDT')
                    network = data.get('network', 'TRC20')
                    
                    self.crypto_amount_label.setText(I18N.t(
                        f"ðŸ’° Price: ${amount_usd:.0f} = {self.crypto_pay_amount} {pay_currency}",
                        f"ðŸ’° GiÃ¡: ${amount_usd:.0f} = {self.crypto_pay_amount} {pay_currency}"
                    ))
                    
                    self.crypto_info_label.setText(I18N.t(
                        f"""<b>ðŸ’° Currency:</b> <span style='color: #26A17B; font-size: 16px;'>{pay_currency}</span><br><br>
                        <b>ðŸŒ Network:</b><br>
                        <span style='font-size: 16px; font-weight: bold; color: #E91E63;'>{network}</span><br><br>
                        <b>ðŸ’µ Amount to send:</b><br>
                        <span style='font-size: 18px; font-weight: bold; color: #4CAF50;'>{self.crypto_pay_amount} {pay_currency}</span><br><br>
                        <b>ðŸ“ Wallet Address:</b><br>
                        <span style='font-size: 11px; color: #333; font-weight: bold; word-break: break-all;'>{self.crypto_pay_address}</span><br><br>
                        <span style='color: #4CAF50; font-size: 11px;'>âœ… Auto-activate after payment confirmed!</span>""",
                        f"""<b>ðŸ’° Loáº¡i tiá»n:</b> <span style='color: #26A17B; font-size: 16px;'>{pay_currency}</span><br><br>
                        <b>ðŸŒ Máº¡ng lÆ°á»›i:</b><br>
                        <span style='font-size: 16px; font-weight: bold; color: #E91E63;'>{network}</span><br><br>
                        <b>ðŸ’µ Sá»‘ tiá»n gá»­i:</b><br>
                        <span style='font-size: 18px; font-weight: bold; color: #4CAF50;'>{self.crypto_pay_amount} {pay_currency}</span><br><br>
                        <b>ðŸ“ Äá»‹a chá»‰ vÃ­:</b><br>
                        <span style='font-size: 11px; color: #333; font-weight: bold; word-break: break-all;'>{self.crypto_pay_address}</span><br><br>
                        <span style='color: #4CAF50; font-size: 11px;'>âœ… Tá»± Ä‘á»™ng kÃ­ch hoáº¡t sau khi xÃ¡c nháº­n!</span>"""
                    ))
                    
                    # Show content
                    self.crypto_loading_label.setVisible(False)
                    self.crypto_content.setVisible(True)
                else:
                    self.crypto_loading_label.setText(I18N.t(
                        f"âŒ Error: {data.get('error', 'Unknown')}",
                        f"âŒ Lá»—i: {data.get('error', 'KhÃ´ng xÃ¡c Ä‘á»‹nh')}"
                    ))
                    self.crypto_loading_label.setStyleSheet("font-size: 14px; color: #F44336; padding: 20px;")
            else:
                error_text = response.text[:200] if response.text else str(response.status_code)
                self.crypto_loading_label.setText(I18N.t(
                    f"âŒ Server error: {error_text}",
                    f"âŒ Lá»—i server: {error_text}"
                ))
                self.crypto_loading_label.setStyleSheet("font-size: 14px; color: #F44336; padding: 20px;")
                
        except Exception as e:
            import traceback
            traceback.print_exc()
            self.crypto_loading_label.setText(I18N.t(f"âŒ Error: {str(e)}", f"âŒ Lá»—i: {str(e)}"))
            self.crypto_loading_label.setStyleSheet("font-size: 14px; color: #F44336; padding: 20px;")
    
    def generate_crypto_qr(self, address):
        """Táº¡o QR code cho Ä‘á»‹a chá»‰ crypto"""
        try:
            import qrcode
            from io import BytesIO
            
            qr = qrcode.QRCode(version=1, box_size=8, border=2)
            qr.add_data(address)
            qr.make(fit=True)
            
            img = qr.make_image(fill_color="black", back_color="white")
            
            buffer = BytesIO()
            img.save(buffer, format='PNG')
            buffer.seek(0)
            
            pixmap = QPixmap()
            pixmap.loadFromData(buffer.getvalue())
            self.crypto_qr_label.setPixmap(pixmap.scaled(180, 180, Qt.KeepAspectRatio, Qt.SmoothTransformation))
            
        except Exception as e:
            print(f"[Crypto QR] Error: {e}")
            self.crypto_qr_label.setText(address[:20] + "...")
    
    def copy_crypto_address(self):
        """Copy Ä‘á»‹a chá»‰ crypto vÃ o clipboard"""
        from PyQt5.QtWidgets import QApplication
        if hasattr(self, 'crypto_pay_address') and self.crypto_pay_address:
            clipboard = QApplication.clipboard()
            clipboard.setText(self.crypto_pay_address)
            QMessageBox.information(self, 
                I18N.t("Copied!", "ÄÃ£ sao chÃ©p!"),
                I18N.t("Crypto wallet address copied to clipboard", "Äá»‹a chá»‰ vÃ­ crypto Ä‘Ã£ Ä‘Æ°á»£c sao chÃ©p"))
        else:
            QMessageBox.warning(self, "Error", I18N.t("No address available", "ChÆ°a cÃ³ Ä‘á»‹a chá»‰"))
    
    def check_crypto_payment_status(self):
        """Kiá»ƒm tra tráº¡ng thÃ¡i thanh toÃ¡n crypto"""
        import requests
        try:
            if not hasattr(self, 'crypto_order_id'):
                QMessageBox.warning(self, "Error", I18N.t("No payment created", "ChÆ°a táº¡o thanh toÃ¡n"))
                return
            
            from license_client import get_license_client
            client = get_license_client()
            token = client.get_valid_token()
            
            headers = {'Authorization': f'Bearer {token}'}
            response = requests.get(
                f"{LICENSE_SERVER_URL}/crypto/status/{self.crypto_order_id}/",
                headers=headers,
                timeout=15
            )
            
            if response.status_code == 200:
                data = response.json()
                status = data.get('status', 'pending')
                np_status = data.get('nowpayments_status', '')
                actually_paid = data.get('actually_paid', 0)
                
                if status == 'completed':
                    QMessageBox.information(self, 
                        I18N.t("âœ… Payment Completed!", "âœ… Thanh ToÃ¡n ThÃ nh CÃ´ng!"),
                        I18N.t(
                            "Your payment has been confirmed and license activated!",
                            "Thanh toÃ¡n Ä‘Ã£ Ä‘Æ°á»£c xÃ¡c nháº­n vÃ  license Ä‘Ã£ kÃ­ch hoáº¡t!"
                        ))
                    self.accept()
                elif status == 'pending':
                    status_text = np_status if np_status else 'waiting'
                    paid_text = f"\nReceived: {actually_paid}" if actually_paid else ""
                    QMessageBox.information(self,
                        I18N.t("â³ Payment Pending", "â³ Äang Chá» Thanh ToÃ¡n"),
                        I18N.t(
                            f"Status: {status_text}{paid_text}\n\nPlease wait for blockchain confirmation.",
                            f"Tráº¡ng thÃ¡i: {status_text}{paid_text}\n\nVui lÃ²ng chá» xÃ¡c nháº­n trÃªn blockchain."
                        ))
                else:
                    QMessageBox.warning(self,
                        I18N.t("Payment Status", "Tráº¡ng ThÃ¡i"),
                        I18N.t(f"Status: {status}", f"Tráº¡ng thÃ¡i: {status}"))
            else:
                QMessageBox.warning(self, "Error", f"Server error: {response.status_code}")
                
        except Exception as e:
            QMessageBox.warning(self, "Error", str(e))


class LoginDialog(QDialog):
    """Dialog Ä‘Äƒng nháº­p tÃ i khoáº£n há»‡ thá»‘ng"""
    
    # Signal Ä‘á»ƒ thÃ´ng bÃ¡o login thÃ nh cÃ´ng
    login_success = pyqtSignal(dict)
    
    # File Ä‘á»ƒ lÆ°u thÃ´ng tin remember me
    REMEMBER_FILE = os.path.join(os.path.dirname(os.path.abspath(__file__)), '.login_remember.json')
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle(I18N.t("ðŸ”‘ Login", "ðŸ”‘ ÄÄƒng nháº­p"))
        self.setMinimumWidth(450)
        self.setModal(True)
        self.license_client = None
        self.went_to_register = False  # Flag to track if user went to register
        self.logged_in_user = None  # Store logged in user info
        self.logged_in_license = None  # Store license info
        self.init_ui()
        self._init_license_client()
        self._load_remembered_login()  # Load saved credentials
        
    def _init_license_client(self):
        """Initialize license client"""
        try:
            from license_client import get_license_client
            self.license_client = get_license_client(
                server_url=LICENSE_SERVER_URL
            )
        except Exception as e:
            print(f"[LoginDialog] Cannot init license client: {e}")
        
    def init_ui(self):
        layout = QVBoxLayout()
        
        # Language switch button at top right (dropdown menu like main app)
        lang_layout = QHBoxLayout()
        lang_layout.addStretch()
        
        # Create language menu button with dropdown
        self.lang_btn = QPushButton()
        self._update_lang_btn_text()
        self.lang_btn.setStyleSheet("""
            QPushButton {
                background-color: #607D8B;
                color: white;
                padding: 5px 12px;
                border: none;
                border-radius: 3px;
                font-size: 12px;
            }
            QPushButton:hover {
                background-color: #455A64;
            }
            QPushButton::menu-indicator {
                subcontrol-position: right center;
                subcontrol-origin: padding;
                right: 5px;
            }
        """)
        
        # Create dropdown menu for language selection
        self.lang_menu = QMenu(self)
        self.lang_menu.setStyleSheet("""
            QMenu {
                background-color: white;
                border: 1px solid #ddd;
                border-radius: 4px;
                padding: 5px;
            }
            QMenu::item {
                padding: 8px 20px;
                border-radius: 3px;
            }
            QMenu::item:selected {
                background-color: #2196F3;
                color: white;
            }
            QMenu::item:checked {
                font-weight: bold;
            }
        """)
        
        # Create action group for exclusive selection
        self.lang_group = QActionGroup(self)
        
        self.lang_en = QAction("ðŸ‡¬ðŸ‡§ English", self, checkable=True)
        self.lang_vi = QAction("ðŸ‡»ðŸ‡³ Tiáº¿ng Viá»‡t", self, checkable=True)
        
        self.lang_group.addAction(self.lang_en)
        self.lang_group.addAction(self.lang_vi)
        
        self.lang_menu.addAction(self.lang_en)
        self.lang_menu.addAction(self.lang_vi)
        
        # Set current language checked
        if AppState.language() == 'vi':
            self.lang_vi.setChecked(True)
        else:
            self.lang_en.setChecked(True)
        
        # Connect actions
        self.lang_en.triggered.connect(lambda: self._apply_language('en'))
        self.lang_vi.triggered.connect(lambda: self._apply_language('vi'))
        
        self.lang_btn.setMenu(self.lang_menu)
        lang_layout.addWidget(self.lang_btn)
        layout.addLayout(lang_layout)
        
        # Header
        self.header = QLabel(I18N.t("ðŸ”‘ Login to Your Account", "ðŸ”‘ ÄÄƒng nháº­p TÃ i khoáº£n"))
        self.header.setStyleSheet("font-size: 18px; font-weight: bold; color: #2196F3; margin-bottom: 10px;")
        self.header.setAlignment(Qt.AlignCenter)
        layout.addWidget(self.header)
        
        # ========== LOGIN FORM (Shown before login) ==========
        self.login_form_widget = QWidget()
        login_form_layout = QVBoxLayout(self.login_form_widget)
        login_form_layout.setContentsMargins(0, 0, 0, 0)
        
        # Form
        self.form_group = QGroupBox(I18N.t("Account Information", "ThÃ´ng tin TÃ i khoáº£n"))
        form_layout = QFormLayout()
        
        # Email/Username
        self.email_input = QLineEdit()
        self.email_input.setPlaceholderText(I18N.t("Enter email or username", "Nháº­p email hoáº·c tÃªn Ä‘Äƒng nháº­p"))
        self.email_input.setStyleSheet("padding: 8px; border: 1px solid #ddd; border-radius: 4px;")
        form_layout.addRow(I18N.t("Email/Username:", "Email/TÃªn Ä‘Äƒng nháº­p:"), self.email_input)
        
        # Password
        self.password_input = QLineEdit()
        self.password_input.setEchoMode(QLineEdit.Password)
        self.password_input.setPlaceholderText(I18N.t("Enter password", "Nháº­p máº­t kháº©u"))
        self.password_input.setStyleSheet("padding: 8px; border: 1px solid #ddd; border-radius: 4px;")
        form_layout.addRow(I18N.t("Password:", "Máº­t kháº©u:"), self.password_input)
        
        # Remember me checkbox
        self.remember_cb = QCheckBox(I18N.t("Remember me", "Ghi nhá»› Ä‘Äƒng nháº­p"))
        form_layout.addRow("", self.remember_cb)
        
        self.form_group.setLayout(form_layout)
        login_form_layout.addWidget(self.form_group)
        
        # Buttons
        btn_layout = QHBoxLayout()
        
        self.login_btn = QPushButton(I18N.t("ðŸ”‘ Login", "ðŸ”‘ ÄÄƒng nháº­p"))
        self.login_btn.setStyleSheet("""
            QPushButton {
                background-color: #4CAF50;
                color: white;
                font-weight: bold;
                padding: 10px 20px;
                border: none;
                border-radius: 5px;
                font-size: 14px;
            }
            QPushButton:hover {
                background-color: #45a049;
            }
        """)
        self.login_btn.clicked.connect(self.do_login)
        
        self.cancel_btn = QPushButton(I18N.t("Cancel", "Há»§y"))
        self.cancel_btn.setStyleSheet("""
            QPushButton {
                background-color: #f44336;
                color: white;
                font-weight: bold;
                padding: 10px 20px;
                border: none;
                border-radius: 5px;
                font-size: 14px;
            }
            QPushButton:hover {
                background-color: #d32f2f;
            }
        """)
        self.cancel_btn.clicked.connect(self.reject)
        
        btn_layout.addWidget(self.login_btn)
        btn_layout.addWidget(self.cancel_btn)
        login_form_layout.addLayout(btn_layout)
        
        # Pricing/Renewal button
        self.pricing_btn = QPushButton(I18N.t("ðŸ’° View Pricing / Renew License", "ðŸ’° Xem Báº£ng GiÃ¡ / Gia Háº¡n"))
        self.pricing_btn.setStyleSheet("""
            QPushButton {
                background-color: #FF9800;
                color: white;
                font-weight: bold;
                padding: 10px 20px;
                border: none;
                border-radius: 5px;
                font-size: 13px;
            }
            QPushButton:hover {
                background-color: #F57C00;
            }
        """)
        self.pricing_btn.clicked.connect(self.open_pricing)
        login_form_layout.addWidget(self.pricing_btn)
        
        # Forgot password link
        self.forgot_link = QLabel(I18N.t("<a href='#'>Forgot password?</a>", "<a href='#'>QuÃªn máº­t kháº©u?</a>"))
        self.forgot_link.setOpenExternalLinks(False)
        self.forgot_link.linkActivated.connect(self.forgot_password)
        self.forgot_link.setAlignment(Qt.AlignCenter)
        self.forgot_link.setStyleSheet("margin-top: 10px;")
        login_form_layout.addWidget(self.forgot_link)
        
        # Register link
        self.register_link = QLabel(I18N.t("<a href='#'>Don't have an account? Register here</a>", "<a href='#'>ChÆ°a cÃ³ tÃ i khoáº£n? ÄÄƒng kÃ½ ngay</a>"))
        self.register_link.setOpenExternalLinks(False)
        self.register_link.linkActivated.connect(self.open_register)
        self.register_link.setAlignment(Qt.AlignCenter)
        login_form_layout.addWidget(self.register_link)
        
        layout.addWidget(self.login_form_widget)
        
        # ========== LOGGED IN PANEL (Shown after successful login) ==========
        self.logged_in_widget = QWidget()
        logged_in_layout = QVBoxLayout(self.logged_in_widget)
        logged_in_layout.setContentsMargins(0, 0, 0, 0)
        
        # Success icon and message
        self.success_icon = QLabel("âœ…")
        self.success_icon.setStyleSheet("font-size: 48px;")
        self.success_icon.setAlignment(Qt.AlignCenter)
        logged_in_layout.addWidget(self.success_icon)
        
        # User info group
        self.user_info_group = QGroupBox(I18N.t("Account Information", "ThÃ´ng tin TÃ i khoáº£n"))
        user_info_layout = QFormLayout()
        
        self.user_name_label = QLabel("--")
        self.user_name_label.setStyleSheet("font-weight: bold; font-size: 14px; color: #2196F3;")
        user_info_layout.addRow(I18N.t("User:", "NgÆ°á»i dÃ¹ng:"), self.user_name_label)
        
        self.license_type_label = QLabel("--")
        self.license_type_label.setStyleSheet("font-weight: bold;")
        user_info_layout.addRow(I18N.t("License:", "License:"), self.license_type_label)
        
        self.days_remaining_label = QLabel("--")
        user_info_layout.addRow(I18N.t("Days Remaining:", "CÃ²n láº¡i:"), self.days_remaining_label)
        
        self.user_info_group.setLayout(user_info_layout)
        logged_in_layout.addWidget(self.user_info_group)
        
        # Start button - big and prominent (always enabled, will check license on click)
        self.start_btn = QPushButton(I18N.t("ðŸš€ Start Trading Bot", "ðŸš€ Khá»Ÿi Ä‘á»™ng Trading Bot"))
        self.start_btn.setStyleSheet("""
            QPushButton {
                background-color: #4CAF50;
                color: white;
                font-weight: bold;
                padding: 15px 30px;
                border: none;
                border-radius: 8px;
                font-size: 16px;
                min-height: 50px;
            }
            QPushButton:hover {
                background-color: #45a049;
            }
        """)
        self.start_btn.clicked.connect(self._on_start_clicked)
        logged_in_layout.addWidget(self.start_btn)
        
        # Pricing button for logged in users
        self.pricing_btn_logged = QPushButton(I18N.t("ðŸ’° View Pricing / Renew License", "ðŸ’° Xem Báº£ng GiÃ¡ / Gia Háº¡n"))
        self.pricing_btn_logged.setStyleSheet("""
            QPushButton {
                background-color: #FF9800;
                color: white;
                font-weight: bold;
                padding: 10px 20px;
                border: none;
                border-radius: 5px;
                font-size: 13px;
            }
            QPushButton:hover {
                background-color: #F57C00;
            }
        """)
        self.pricing_btn_logged.clicked.connect(self.open_pricing)
        logged_in_layout.addWidget(self.pricing_btn_logged)
        
        # Logout button
        self.logout_btn = QPushButton(I18N.t("ðŸšª Logout", "ðŸšª ÄÄƒng xuáº¥t"))
        self.logout_btn.setStyleSheet("""
            QPushButton {
                background-color: #9E9E9E;
                color: white;
                font-weight: bold;
                padding: 10px 20px;
                border: none;
                border-radius: 5px;
                font-size: 13px;
            }
            QPushButton:hover {
                background-color: #757575;
            }
        """)
        self.logout_btn.clicked.connect(self._on_logout_clicked)
        logged_in_layout.addWidget(self.logout_btn)
        
        layout.addWidget(self.logged_in_widget)
        
        # Initially hide logged in panel
        self.logged_in_widget.hide()
        
        self.setLayout(layout)
        
    def do_login(self):
        email = self.email_input.text().strip()
        password = self.password_input.text()
        
        if not email or not password:
            QMessageBox.warning(self, 
                I18N.t("Validation Error", "Lá»—i xÃ¡c thá»±c"),
                I18N.t("Please enter email and password", "Vui lÃ²ng nháº­p email vÃ  máº­t kháº©u"))
            return
        
        # Disable button and show loading
        self.login_btn.setEnabled(False)
        self.login_btn.setText(I18N.t("â³ Logging in...", "â³ Äang Ä‘Äƒng nháº­p..."))
        QApplication.processEvents()
        
        try:
            # === PHÆ¯Æ NG THá»¨C 1: THá»¬ LICENSE SERVER TRÆ¯á»šC ===
            server_success = False
            use_local_fallback = False
            
            if self.license_client:
                try:
                    success, data = self.license_client.login(email, password)
                    
                    if success:
                        # Login successful with server
                        license_info = data.get('license') or {}
                        user_data = data.get('user', {})
                        license_status = data.get('license_status', 'active')
                        
                        # Xá»­ lÃ½ days_remaining dá»±a trÃªn license_status
                        if license_status == 'expired':
                            days_remaining = 0
                        elif license_status == 'no_license':
                            days_remaining = 0
                            license_info = {'license_type': 'none', 'days_remaining': 0}
                        else:
                            days_remaining = license_info.get('days_remaining', 0) if license_info else 0
                        
                        # Store login info
                        self.logged_in_user = user_data
                        self.logged_in_license = license_info
                        
                        # Activate license on this device (even if expired, for tracking)
                        if license_info and license_info.get('license_key'):
                            self.license_client.activate(license_info['license_key'])
                        
                        # Save or clear remembered login based on checkbox
                        self._save_remembered_login(email, password, self.remember_cb.isChecked(), user_data)
                        
                        # Show logged in panel instead of accepting immediately
                        self._show_logged_in_panel(email, license_info, days_remaining)
                        
                        server_success = True
                        return
                    else:
                        # Check if this is a connection error -> try local fallback
                        if data.get('error') == 'connection_error':
                            use_local_fallback = True
                            print("ðŸ”„ Server unavailable, trying local authentication...")
                        else:
                            # Server responded but login failed
                            raw_msg = data.get('message', data.get('error', 'Unknown error'))
                            error_translations = {
                                'Invalid username or password': 'TÃªn Ä‘Äƒng nháº­p hoáº·c máº­t kháº©u khÃ´ng Ä‘Ãºng',
                                'Invalid username/email/phone or password': 'TÃªn Ä‘Äƒng nháº­p/email/sá»‘ Ä‘iá»‡n thoáº¡i hoáº·c máº­t kháº©u khÃ´ng Ä‘Ãºng',
                                'Account is disabled': 'TÃ i khoáº£n Ä‘Ã£ bá»‹ vÃ´ hiá»‡u hÃ³a',
                                'No active license found': 'KhÃ´ng tÃ¬m tháº¥y license Ä‘ang hoáº¡t Ä‘á»™ng',
                                'License has expired': 'License Ä‘Ã£ háº¿t háº¡n',
                                'Username/Email/Phone and password are required': 'Vui lÃ²ng nháº­p tÃªn Ä‘Äƒng nháº­p/email/sá»‘ Ä‘iá»‡n thoáº¡i vÃ  máº­t kháº©u',
                            }
                            vi_msg = error_translations.get(raw_msg, raw_msg)
                            error_msg = I18N.t(raw_msg, vi_msg)
                            
                            # Check if license expired or not found - STILL ALLOW LOGIN
                            # User can login but will be restricted from using services
                            if raw_msg in ['No active license found', 'License has expired']:
                                # Save login info for user (so they can access pricing)
                                self._save_remembered_login(email, password, self.remember_cb.isChecked(), {})
                                
                                # Store login info with expired license
                                self.logged_in_user = {}
                                self.logged_in_license = {'license_type': 'expired', 'days_remaining': 0}
                                
                                # Show logged in panel with expired license
                                self._show_logged_in_panel(email, {'license_type': 'expired'}, 0)
                                return
                            else:
                                QMessageBox.warning(self,
                                    I18N.t("âŒ Login Failed", "âŒ ÄÄƒng nháº­p tháº¥t báº¡i"),
                                    str(error_msg))
                            return
                except Exception as e:
                    print(f"âš ï¸ Server login error: {e}, trying local fallback...")
                    use_local_fallback = True
            else:
                use_local_fallback = True
            
            # === PHÆ¯Æ NG THá»¨C 2: FALLBACK SANG LOCAL LICENSE GUARD ===
            if use_local_fallback:
                try:
                    from license_guard import get_license_guard
                    guard = get_license_guard()
                    
                    success, message, result = guard.validate_online(email, password)
                    
                    if success:
                        # Local authentication successful
                        user_info = guard.user_info or {}
                        license_type = guard.license_type or "trial"
                        
                        # Save remembered login
                        self._save_remembered_login(email, password, self.remember_cb.isChecked(), user_info)
                        
                        # Store login info
                        self.logged_in_user = user_info
                        self.logged_in_license = {'license_type': license_type, 'days_remaining': -1}  # -1 = offline mode
                        
                        # Show logged in panel (offline mode)
                        self._show_logged_in_panel(email, {'license_type': f'{license_type} (Offline)'}, -1)
                        return
                    else:
                        QMessageBox.warning(self,
                            I18N.t("âŒ Login Failed", "âŒ ÄÄƒng nháº­p tháº¥t báº¡i"),
                            message)
                        return
                except ImportError:
                    QMessageBox.critical(self,
                        I18N.t("Error", "Lá»—i"),
                        I18N.t("Cannot connect to server and local authentication not available.",
                               "KhÃ´ng thá»ƒ káº¿t ná»‘i server vÃ  xÃ¡c thá»±c cá»¥c bá»™ khÃ´ng kháº£ dá»¥ng."))
                except Exception as e:
                    QMessageBox.critical(self,
                        I18N.t("Error", "Lá»—i"),
                        I18N.t(f"Local login error: {str(e)}", f"Lá»—i Ä‘Äƒng nháº­p cá»¥c bá»™: {str(e)}"))
                    
        except Exception as e:
            QMessageBox.critical(self,
                I18N.t("Error", "Lá»—i"),
                I18N.t(f"Login error: {str(e)}", f"Lá»—i Ä‘Äƒng nháº­p: {str(e)}"))
        finally:
            self.login_btn.setEnabled(True)
            self.login_btn.setText(I18N.t("ðŸ”‘ Login", "ðŸ”‘ ÄÄƒng nháº­p"))
    
    def _show_logged_in_panel(self, email: str, license_info: dict, days_remaining: int):
        """Show the logged in panel with user info"""
        # Update header
        self.header.setText(I18N.t("âœ… Login Successful", "âœ… ÄÄƒng nháº­p thÃ nh cÃ´ng"))
        self.header.setStyleSheet("font-size: 18px; font-weight: bold; color: #4CAF50; margin-bottom: 10px;")
        
        # Update user info labels
        self.user_name_label.setText(email)
        
        license_type = license_info.get('license_type', 'N/A').upper()
        self.license_type_label.setText(license_type)
        
        if days_remaining == -1:
            # Offline mode - allow start
            self.days_remaining_label.setText(I18N.t("âš ï¸ Offline Mode", "âš ï¸ Cháº¿ Ä‘á»™ Offline"))
            self.days_remaining_label.setStyleSheet("color: #FF9800; font-weight: bold;")
            self.start_btn.setEnabled(True)
            self.start_btn.setText(I18N.t("ðŸš€ Start Trading Bot", "ðŸš€ Khá»Ÿi Ä‘á»™ng Trading Bot"))
            self.start_btn.setStyleSheet("""
                QPushButton {
                    background-color: #4CAF50;
                    color: white;
                    font-weight: bold;
                    padding: 15px 30px;
                    border: none;
                    border-radius: 8px;
                    font-size: 16px;
                    min-height: 50px;
                }
                QPushButton:hover {
                    background-color: #45a049;
                }
            """)
        elif days_remaining <= 0:
            # License expired - Keep Start button enabled but show warning style
            self.days_remaining_label.setText(I18N.t("âŒ Expired", "âŒ Háº¿t háº¡n"))
            self.days_remaining_label.setStyleSheet("color: #f44336; font-weight: bold;")
            
            # Keep start button enabled with warning style (will check on click)
            self.start_btn.setEnabled(True)
            self.start_btn.setText(I18N.t("ðŸš€ Start Trading Bot", "ðŸš€ Khá»Ÿi Ä‘á»™ng Trading Bot"))
            self.start_btn.setStyleSheet("""
                QPushButton {
                    background-color: #FF9800;
                    color: white;
                    font-weight: bold;
                    padding: 15px 30px;
                    border: none;
                    border-radius: 8px;
                    font-size: 16px;
                    min-height: 50px;
                }
                QPushButton:hover {
                    background-color: #F57C00;
                }
            """)
        else:
            # License active
            self.days_remaining_label.setText(f"{days_remaining} " + I18N.t("days", "ngÃ y"))
            self.days_remaining_label.setStyleSheet("color: #4CAF50; font-weight: bold;")
            self.start_btn.setEnabled(True)
            self.start_btn.setText(I18N.t("ðŸš€ Start Trading Bot", "ðŸš€ Khá»Ÿi Ä‘á»™ng Trading Bot"))
            self.start_btn.setStyleSheet("""
                QPushButton {
                    background-color: #4CAF50;
                    color: white;
                    font-weight: bold;
                    padding: 15px 30px;
                    border: none;
                    border-radius: 8px;
                    font-size: 16px;
                    min-height: 50px;
                }
                QPushButton:hover {
                    background-color: #45a049;
                }
            """)
        
        # Hide login form, show logged in panel
        self.login_form_widget.hide()
        self.logged_in_widget.show()
        
        # Adjust dialog size
        self.adjustSize()
    
    def _on_start_clicked(self):
        """Handle Start button click - refresh license and proceed to main app if valid"""
        # Show loading
        self.start_btn.setEnabled(False)
        self.start_btn.setText(I18N.t("â³ Checking license...", "â³ Äang kiá»ƒm tra license..."))
        QApplication.processEvents()
        
        try:
            # Refresh license status from server
            if self.license_client:
                print("ðŸ”„ Refreshing license status before start...")
                refresh_success, is_active = self.license_client.refresh_license_status()
                
                if refresh_success:
                    # Update displayed info with fresh data
                    license_data = self.license_client.license_data
                    if license_data:
                        days_remaining = license_data.get('days_remaining', 0)
                        expire_date = license_data.get('expire_date', '')
                        license_type = license_data.get('license_type', 'N/A')
                        
                        # Update stored license info
                        self.logged_in_license = license_data
                        
                        # Update UI
                        self.license_type_label.setText(license_type.upper())
                        
                        if days_remaining > 0:
                            self.days_remaining_label.setText(f"{days_remaining} " + I18N.t("days", "ngÃ y"))
                            self.days_remaining_label.setStyleSheet("color: #4CAF50; font-weight: bold;")
                        else:
                            self.days_remaining_label.setText(I18N.t("âŒ Expired", "âŒ Háº¿t háº¡n"))
                            self.days_remaining_label.setStyleSheet("color: #f44336; font-weight: bold;")
                        
                        print(f"âœ… License refreshed: days_remaining={days_remaining}, is_active={is_active}")
                
                # Check if license is active
                if not self.license_client.is_license_active:
                    # License expired - show message and don't proceed
                    QMessageBox.warning(self,
                        I18N.t("âš ï¸ License Expired", "âš ï¸ License Háº¿t Háº¡n"),
                        I18N.t(
                            "Your license has expired!\n\nPlease renew your license to use the app.\n\nClick 'View Pricing' to renew.",
                            "License cá»§a báº¡n Ä‘Ã£ háº¿t háº¡n!\n\nVui lÃ²ng gia háº¡n license Ä‘á»ƒ sá»­ dá»¥ng app.\n\nNháº¥n 'Xem Báº£ng GiÃ¡' Ä‘á»ƒ gia háº¡n."
                        )
                    )
                    # Reset button
                    self.start_btn.setEnabled(True)
                    self.start_btn.setText(I18N.t("ðŸš€ Start Trading Bot", "ðŸš€ Khá»Ÿi Ä‘á»™ng Trading Bot"))
                    return
            
            # License valid - proceed to main app
            self.accept()
            
        except Exception as e:
            print(f"âš ï¸ Error checking license: {e}")
            # On error, still allow to proceed (offline grace)
            self.accept()
    
    def _on_logout_clicked(self):
        """Handle Logout button click"""
        # Clear license client cache
        if self.license_client:
            try:
                self.license_client.clear_cache()
            except Exception as e:
                print(f"[LoginDialog] Error clearing license cache: {e}")
        
        # Clear remembered login
        self._clear_remembered_login()
        
        # Clear stored user info
        self.logged_in_user = None
        self.logged_in_license = None
        
        # Reset UI to login form
        self.header.setText(I18N.t("ðŸ”‘ Login to Your Account", "ðŸ”‘ ÄÄƒng nháº­p TÃ i khoáº£n"))
        self.header.setStyleSheet("font-size: 18px; font-weight: bold; color: #2196F3; margin-bottom: 10px;")
        
        # Clear input fields
        self.email_input.clear()
        self.password_input.clear()
        self.remember_cb.setChecked(False)
        
        # Show login form, hide logged in panel
        self.logged_in_widget.hide()
        self.login_form_widget.show()
        
        # Reset start button text, style and enable it
        self.start_btn.setEnabled(True)
        self.start_btn.setText(I18N.t("ðŸš€ Start Trading Bot", "ðŸš€ Khá»Ÿi Ä‘á»™ng Trading Bot"))
        self.start_btn.setStyleSheet("""
            QPushButton {
                background-color: #4CAF50;
                color: white;
                font-weight: bold;
                padding: 15px 30px;
                border: none;
                border-radius: 8px;
                font-size: 16px;
                min-height: 50px;
            }
            QPushButton:hover {
                background-color: #45a049;
            }
        """)
        
        # Adjust dialog size
        self.adjustSize()
        
        QMessageBox.information(self,
            I18N.t("Logged Out", "ÄÃ£ Ä‘Äƒng xuáº¥t"),
            I18N.t("You have been logged out successfully.", "Báº¡n Ä‘Ã£ Ä‘Äƒng xuáº¥t thÃ nh cÃ´ng."))
        
    def forgot_password(self):
        """Má»Ÿ dialog quÃªn máº­t kháº©u"""
        forgot_dialog = ForgotPasswordDialog(self)
        forgot_dialog.exec_()
    
    def open_register(self):
        self.went_to_register = True  # Flag to indicate user went to register
        self.reject()  # Close login dialog
        register_dialog = RegisterDialog(self.parent())
        register_dialog.exec_()
    
    def open_pricing(self):
        """Má»Ÿ dialog báº£ng giÃ¡ gia háº¡n license"""
        pricing_dialog = PricingDialog(self)
        pricing_dialog.exec_()
    
    def _update_lang_btn_text(self):
        """Update language button text based on current language"""
        if AppState.language() == 'vi':
            self.lang_btn.setText("ðŸŒ NgÃ´n ngá»¯ â–¼")
        else:
            self.lang_btn.setText("ðŸŒ Language â–¼")
    
    def _apply_language(self, lang_code: str):
        """Apply language change - affects entire app"""
        print(f"[LoginDialog] Switching language to: {lang_code}")
        AppState.set_language(lang_code)
        
        # Update button text
        self._update_lang_btn_text()
        
        # Update checked state
        if lang_code == 'vi':
            self.lang_vi.setChecked(True)
        else:
            self.lang_en.setChecked(True)
        
        # Refresh dialog UI
        self._refresh_ui()
        
        # Also try to refresh main app if it exists
        try:
            main_window = self.parent()
            if main_window and hasattr(main_window, 'update_menu_for_user'):
                if hasattr(main_window, 'logged_in_user'):
                    main_window.update_menu_for_user(main_window.logged_in_user)
            
            # Update main window tabs language
            if main_window and hasattr(main_window, 'update_ui_language'):
                main_window.update_ui_language()
                print(f"[LoginDialog] âœ… Main window UI language updated")
        except Exception as e:
            print(f"[LoginDialog] Cannot update main window: {e}")
    
    def _toggle_language(self):
        """Toggle between English and Vietnamese (legacy method)"""
        current_lang = AppState.language()
        new_lang = 'vi' if current_lang == 'en' else 'en'
        self._apply_language(new_lang)
    
    def _refresh_ui(self):
        """Refresh UI texts after language change"""
        self.setWindowTitle(I18N.t("ðŸ”‘ Login", "ðŸ”‘ ÄÄƒng nháº­p"))
        self.header.setText(I18N.t("ðŸ”‘ Login to Your Account", "ðŸ”‘ ÄÄƒng nháº­p TÃ i khoáº£n"))
        self.form_group.setTitle(I18N.t("Account Information", "ThÃ´ng tin TÃ i khoáº£n"))
        self.email_input.setPlaceholderText(I18N.t("Enter email or username", "Nháº­p email hoáº·c tÃªn Ä‘Äƒng nháº­p"))
        self.password_input.setPlaceholderText(I18N.t("Enter password", "Nháº­p máº­t kháº©u"))
        self.remember_cb.setText(I18N.t("Remember me", "Ghi nhá»› Ä‘Äƒng nháº­p"))
        self.login_btn.setText(I18N.t("ðŸ”‘ Login", "ðŸ”‘ ÄÄƒng nháº­p"))
        self.cancel_btn.setText(I18N.t("Cancel", "Há»§y"))
        self.pricing_btn.setText(I18N.t("ðŸ’° View Pricing / Renew License", "ðŸ’° Xem Báº£ng GiÃ¡ / Gia Háº¡n"))
        self.forgot_link.setText(I18N.t("<a href='#'>Forgot password?</a>", "<a href='#'>QuÃªn máº­t kháº©u?</a>"))
        self.register_link.setText(I18N.t("<a href='#'>Don't have an account? Register here</a>", "<a href='#'>ChÆ°a cÃ³ tÃ i khoáº£n? ÄÄƒng kÃ½ ngay</a>"))
        
        # Logged in panel texts
        self.user_info_group.setTitle(I18N.t("Account Information", "ThÃ´ng tin TÃ i khoáº£n"))
        self.start_btn.setText(I18N.t("ðŸš€ Start Trading Bot", "ðŸš€ Khá»Ÿi Ä‘á»™ng Trading Bot"))
        self.pricing_btn_logged.setText(I18N.t("ðŸ’° View Pricing / Renew License", "ðŸ’° Xem Báº£ng GiÃ¡ / Gia Háº¡n"))
        self.logout_btn.setText(I18N.t("ðŸšª Logout", "ðŸšª ÄÄƒng xuáº¥t"))
    
    def _load_remembered_login(self):
        """Load saved login credentials if remember me was checked"""
        try:
            if os.path.exists(self.REMEMBER_FILE):
                import base64
                with open(self.REMEMBER_FILE, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                if data.get('remember', False):
                    # Decode saved credentials (basic obfuscation, not real encryption)
                    email = base64.b64decode(data.get('e', '')).decode('utf-8') if data.get('e') else ''
                    password = base64.b64decode(data.get('p', '')).decode('utf-8') if data.get('p') else ''
                    
                    self.email_input.setText(email)
                    self.password_input.setText(password)
                    self.remember_cb.setChecked(True)
        except Exception as e:
            print(f"[LoginDialog] Cannot load remembered login: {e}")
    
    def _save_remembered_login(self, email: str, password: str, remember: bool, user_data: dict = None):
        """Save login credentials if remember me is checked"""
        try:
            import base64
            if remember:
                # Save with basic obfuscation (not real encryption for simplicity)
                data = {
                    'remember': True,
                    'e': base64.b64encode(email.encode('utf-8')).decode('utf-8'),
                    'p': base64.b64encode(password.encode('utf-8')).decode('utf-8'),
                    'email': email,  # Plain email for AI Server tracking
                    'name': user_data.get('name', email.split('@')[0]) if user_data else email.split('@')[0],
                    'phone': user_data.get('phone', 'N/A') if user_data else 'N/A'
                }
            else:
                # Clear saved credentials
                data = {'remember': False}
            
            with open(self.REMEMBER_FILE, 'w', encoding='utf-8') as f:
                json.dump(data, f)
        except Exception as e:
            print(f"[LoginDialog] Cannot save remembered login: {e}")
    
    def _clear_remembered_login(self):
        """Clear saved login credentials"""
        try:
            if os.path.exists(self.REMEMBER_FILE):
                os.remove(self.REMEMBER_FILE)
        except Exception as e:
            print(f"[LoginDialog] Cannot clear remembered login: {e}")


class ForgotPasswordDialog(QDialog):
    """Dialog quÃªn máº­t kháº©u - KhÃ´i phá»¥c máº­t kháº©u qua email"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle(I18N.t("ðŸ”“ Forgot Password", "ðŸ”“ QuÃªn máº­t kháº©u"))
        self.setMinimumWidth(450)
        self.setModal(True)
        self.license_client = None
        self.verified_email = None  # Email Ä‘Ã£ xÃ¡c thá»±c
        self.init_ui()
        self._init_license_client()
    
    def _init_license_client(self):
        """Initialize license client"""
        try:
            from license_client import get_license_client
            self.license_client = get_license_client(
                server_url=LICENSE_SERVER_URL
            )
        except Exception as e:
            print(f"[ForgotPasswordDialog] Cannot init license client: {e}")
    
    def init_ui(self):
        self.main_layout = QVBoxLayout()
        
        # Header
        header = QLabel(I18N.t("ðŸ”“ Reset Your Password", "ðŸ”“ Äáº·t láº¡i máº­t kháº©u"))
        header.setStyleSheet("font-size: 18px; font-weight: bold; color: #FF9800; margin-bottom: 10px;")
        header.setAlignment(Qt.AlignCenter)
        self.main_layout.addWidget(header)
        
        # Stacked widget for multi-step flow
        self.stacked = QStackedWidget()
        
        # Step 1: Enter email
        self.step1_widget = self._create_step1_email()
        self.stacked.addWidget(self.step1_widget)
        
        # Step 2: Enter verification code
        self.step2_widget = self._create_step2_code()
        self.stacked.addWidget(self.step2_widget)
        
        # Step 3: Enter new password
        self.step3_widget = self._create_step3_password()
        self.stacked.addWidget(self.step3_widget)
        
        self.main_layout.addWidget(self.stacked)
        self.setLayout(self.main_layout)
    
    def _create_step1_email(self):
        """Step 1: Nháº­p email"""
        widget = QWidget()
        layout = QVBoxLayout()
        
        # Instructions
        info = QLabel(I18N.t(
            "Enter your registered email address.\nWe will send a verification code to reset your password.",
            "Nháº­p Ä‘á»‹a chá»‰ email Ä‘Ã£ Ä‘Äƒng kÃ½.\nChÃºng tÃ´i sáº½ gá»­i mÃ£ xÃ¡c nháº­n Ä‘á»ƒ Ä‘áº·t láº¡i máº­t kháº©u."
        ))
        info.setStyleSheet("color: #666; margin-bottom: 15px;")
        info.setWordWrap(True)
        layout.addWidget(info)
        
        # Email input
        form_group = QGroupBox(I18N.t("Email Address", "Äá»‹a chá»‰ Email"))
        form_layout = QFormLayout()
        
        self.email_input = QLineEdit()
        self.email_input.setPlaceholderText(I18N.t("Enter your email", "Nháº­p email cá»§a báº¡n"))
        self.email_input.setStyleSheet("padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;")
        form_layout.addRow(I18N.t("Email:", "Email:"), self.email_input)
        
        form_group.setLayout(form_layout)
        layout.addWidget(form_group)
        
        # Buttons
        btn_layout = QHBoxLayout()
        
        self.send_code_btn = QPushButton(I18N.t("ðŸ“§ Send Verification Code", "ðŸ“§ Gá»­i mÃ£ xÃ¡c nháº­n"))
        self.send_code_btn.setStyleSheet("""
            QPushButton {
                background-color: #FF9800;
                color: white;
                font-weight: bold;
                padding: 12px 20px;
                border: none;
                border-radius: 5px;
                font-size: 14px;
            }
            QPushButton:hover {
                background-color: #F57C00;
            }
            QPushButton:disabled {
                background-color: #ccc;
            }
        """)
        self.send_code_btn.clicked.connect(self._send_verification_code)
        
        cancel_btn = QPushButton(I18N.t("Cancel", "Há»§y"))
        cancel_btn.setStyleSheet("""
            QPushButton {
                background-color: #9e9e9e;
                color: white;
                padding: 12px 20px;
                border: none;
                border-radius: 5px;
                font-size: 14px;
            }
            QPushButton:hover {
                background-color: #757575;
            }
        """)
        cancel_btn.clicked.connect(self.reject)
        
        btn_layout.addWidget(self.send_code_btn)
        btn_layout.addWidget(cancel_btn)
        layout.addLayout(btn_layout)
        
        widget.setLayout(layout)
        return widget
    
    def _create_step2_code(self):
        """Step 2: Nháº­p mÃ£ xÃ¡c nháº­n"""
        widget = QWidget()
        layout = QVBoxLayout()
        
        # Instructions
        self.code_info = QLabel(I18N.t(
            "A verification code has been sent to your email.\nPlease enter the 6-digit code below.",
            "MÃ£ xÃ¡c nháº­n Ä‘Ã£ Ä‘Æ°á»£c gá»­i Ä‘áº¿n email cá»§a báº¡n.\nVui lÃ²ng nháº­p mÃ£ 6 chá»¯ sá»‘ bÃªn dÆ°á»›i."
        ))
        self.code_info.setStyleSheet("color: #666; margin-bottom: 15px;")
        self.code_info.setWordWrap(True)
        layout.addWidget(self.code_info)
        
        # Code input
        form_group = QGroupBox(I18N.t("Verification Code", "MÃ£ xÃ¡c nháº­n"))
        form_layout = QFormLayout()
        
        self.code_input = QLineEdit()
        self.code_input.setPlaceholderText(I18N.t("Enter 6-digit code", "Nháº­p mÃ£ 6 chá»¯ sá»‘"))
        self.code_input.setMaxLength(6)
        self.code_input.setStyleSheet("padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 18px; letter-spacing: 5px; text-align: center;")
        self.code_input.setAlignment(Qt.AlignCenter)
        form_layout.addRow(I18N.t("Code:", "MÃ£:"), self.code_input)
        
        form_group.setLayout(form_layout)
        layout.addWidget(form_group)
        
        # Resend link
        resend_layout = QHBoxLayout()
        resend_label = QLabel(I18N.t("Didn't receive the code?", "KhÃ´ng nháº­n Ä‘Æ°á»£c mÃ£?"))
        resend_label.setStyleSheet("color: #666;")
        
        self.resend_btn = QPushButton(I18N.t("Resend", "Gá»­i láº¡i"))
        self.resend_btn.setStyleSheet("color: #2196F3; background: none; border: none; text-decoration: underline; cursor: pointer;")
        self.resend_btn.clicked.connect(self._resend_code)
        
        resend_layout.addWidget(resend_label)
        resend_layout.addWidget(self.resend_btn)
        resend_layout.addStretch()
        layout.addLayout(resend_layout)
        
        # Buttons
        btn_layout = QHBoxLayout()
        
        self.verify_code_btn = QPushButton(I18N.t("âœ“ Verify Code", "âœ“ XÃ¡c nháº­n mÃ£"))
        self.verify_code_btn.setStyleSheet("""
            QPushButton {
                background-color: #4CAF50;
                color: white;
                font-weight: bold;
                padding: 12px 20px;
                border: none;
                border-radius: 5px;
                font-size: 14px;
            }
            QPushButton:hover {
                background-color: #45a049;
            }
            QPushButton:disabled {
                background-color: #ccc;
            }
        """)
        self.verify_code_btn.clicked.connect(self._verify_code)
        
        back_btn = QPushButton(I18N.t("â† Back", "â† Quay láº¡i"))
        back_btn.setStyleSheet("""
            QPushButton {
                background-color: #9e9e9e;
                color: white;
                padding: 12px 20px;
                border: none;
                border-radius: 5px;
                font-size: 14px;
            }
            QPushButton:hover {
                background-color: #757575;
            }
        """)
        back_btn.clicked.connect(lambda: self.stacked.setCurrentIndex(0))
        
        btn_layout.addWidget(self.verify_code_btn)
        btn_layout.addWidget(back_btn)
        layout.addLayout(btn_layout)
        
        widget.setLayout(layout)
        return widget
    
    def _create_step3_password(self):
        """Step 3: Äáº·t máº­t kháº©u má»›i"""
        widget = QWidget()
        layout = QVBoxLayout()
        
        # Success icon
        success_icon = QLabel("âœ…")
        success_icon.setStyleSheet("font-size: 40px; margin-bottom: 10px;")
        success_icon.setAlignment(Qt.AlignCenter)
        layout.addWidget(success_icon)
        
        # Instructions
        info = QLabel(I18N.t(
            "Email verified successfully!\nPlease enter your new password below.",
            "Email Ä‘Ã£ Ä‘Æ°á»£c xÃ¡c nháº­n!\nVui lÃ²ng nháº­p máº­t kháº©u má»›i bÃªn dÆ°á»›i."
        ))
        info.setStyleSheet("color: #4CAF50; margin-bottom: 15px; font-weight: bold;")
        info.setWordWrap(True)
        info.setAlignment(Qt.AlignCenter)
        layout.addWidget(info)
        
        # Password inputs
        form_group = QGroupBox(I18N.t("New Password", "Máº­t kháº©u má»›i"))
        form_layout = QFormLayout()
        
        self.new_password_input = QLineEdit()
        self.new_password_input.setEchoMode(QLineEdit.Password)
        self.new_password_input.setPlaceholderText(I18N.t("Enter new password (min 8 chars)", "Nháº­p máº­t kháº©u má»›i (tá»‘i thiá»ƒu 8 kÃ½ tá»±)"))
        self.new_password_input.setStyleSheet("padding: 10px; border: 1px solid #ddd; border-radius: 4px;")
        form_layout.addRow(I18N.t("New Password:", "Máº­t kháº©u má»›i:"), self.new_password_input)
        
        self.confirm_password_input = QLineEdit()
        self.confirm_password_input.setEchoMode(QLineEdit.Password)
        self.confirm_password_input.setPlaceholderText(I18N.t("Confirm new password", "XÃ¡c nháº­n máº­t kháº©u má»›i"))
        self.confirm_password_input.setStyleSheet("padding: 10px; border: 1px solid #ddd; border-radius: 4px;")
        form_layout.addRow(I18N.t("Confirm:", "XÃ¡c nháº­n:"), self.confirm_password_input)
        
        form_group.setLayout(form_layout)
        layout.addWidget(form_group)
        
        # Buttons
        btn_layout = QHBoxLayout()
        
        self.reset_password_btn = QPushButton(I18N.t("ðŸ”‘ Reset Password", "ðŸ”‘ Äáº·t láº¡i máº­t kháº©u"))
        self.reset_password_btn.setStyleSheet("""
            QPushButton {
                background-color: #4CAF50;
                color: white;
                font-weight: bold;
                padding: 12px 20px;
                border: none;
                border-radius: 5px;
                font-size: 14px;
            }
            QPushButton:hover {
                background-color: #45a049;
            }
            QPushButton:disabled {
                background-color: #ccc;
            }
        """)
        self.reset_password_btn.clicked.connect(self._reset_password)
        
        btn_layout.addWidget(self.reset_password_btn)
        layout.addLayout(btn_layout)
        
        widget.setLayout(layout)
        return widget
    
    def _send_verification_code(self):
        """Gá»­i mÃ£ xÃ¡c nháº­n Ä‘áº¿n email"""
        email = self.email_input.text().strip()
        
        if not email:
            QMessageBox.warning(self,
                I18N.t("Validation Error", "Lá»—i xÃ¡c thá»±c"),
                I18N.t("Please enter your email address.", "Vui lÃ²ng nháº­p Ä‘á»‹a chá»‰ email."))
            return
        
        # Basic email validation
        import re
        if not re.match(r'^[\w\.-]+@[\w\.-]+\.\w+$', email):
            QMessageBox.warning(self,
                I18N.t("Invalid Email", "Email khÃ´ng há»£p lá»‡"),
                I18N.t("Please enter a valid email address.", "Vui lÃ²ng nháº­p Ä‘á»‹a chá»‰ email há»£p lá»‡."))
            return
        
        if not self.license_client:
            QMessageBox.warning(self,
                I18N.t("Error", "Lá»—i"),
                I18N.t("Cannot connect to server.", "KhÃ´ng thá»ƒ káº¿t ná»‘i Ä‘áº¿n server."))
            return
        
        # Disable button and show loading
        self.send_code_btn.setEnabled(False)
        self.send_code_btn.setText(I18N.t("â³ Sending...", "â³ Äang gá»­i..."))
        QApplication.processEvents()
        
        try:
            # Gá»­i kÃ¨m ngÃ´n ngá»¯ hiá»‡n táº¡i Ä‘á»ƒ server gá»­i email Ä‘Ãºng ngÃ´n ngá»¯
            current_lang = AppState.language()
            success, data = self.license_client._api_request('auth/forgot-password/', data={
                'email': email,
                'language': current_lang
            })
            
            if success:
                self.verified_email = email
                QMessageBox.information(self,
                    I18N.t("âœ… Code Sent", "âœ… ÄÃ£ gá»­i mÃ£"),
                    I18N.t(f"A verification code has been sent to {email}.\nPlease check your inbox (and spam folder).",
                           f"MÃ£ xÃ¡c nháº­n Ä‘Ã£ Ä‘Æ°á»£c gá»­i Ä‘áº¿n {email}.\nVui lÃ²ng kiá»ƒm tra há»™p thÆ° (vÃ  thÆ° rÃ¡c)."))
                # Move to step 2
                self.stacked.setCurrentIndex(1)
            else:
                error_msg = data.get('message', data.get('error', 'Unknown error'))
                QMessageBox.warning(self,
                    I18N.t("âŒ Error", "âŒ Lá»—i"),
                    str(error_msg))
        except Exception as e:
            QMessageBox.critical(self,
                I18N.t("Error", "Lá»—i"),
                I18N.t(f"Error: {str(e)}", f"Lá»—i: {str(e)}"))
        finally:
            self.send_code_btn.setEnabled(True)
            self.send_code_btn.setText(I18N.t("ðŸ“§ Send Verification Code", "ðŸ“§ Gá»­i mÃ£ xÃ¡c nháº­n"))
    
    def _resend_code(self):
        """Gá»­i láº¡i mÃ£ xÃ¡c nháº­n"""
        self._send_verification_code()
    
    def _verify_code(self):
        """XÃ¡c nháº­n mÃ£"""
        code = self.code_input.text().strip()
        
        if not code or len(code) != 6:
            QMessageBox.warning(self,
                I18N.t("Validation Error", "Lá»—i xÃ¡c thá»±c"),
                I18N.t("Please enter the 6-digit verification code.", "Vui lÃ²ng nháº­p mÃ£ xÃ¡c nháº­n 6 chá»¯ sá»‘."))
            return
        
        if not self.license_client or not self.verified_email:
            QMessageBox.warning(self,
                I18N.t("Error", "Lá»—i"),
                I18N.t("Session expired. Please start over.", "PhiÃªn Ä‘Ã£ háº¿t háº¡n. Vui lÃ²ng thá»­ láº¡i."))
            self.stacked.setCurrentIndex(0)
            return
        
        # Disable button and show loading
        self.verify_code_btn.setEnabled(False)
        self.verify_code_btn.setText(I18N.t("â³ Verifying...", "â³ Äang xÃ¡c nháº­n..."))
        QApplication.processEvents()
        
        try:
            success, data = self.license_client._api_request('auth/verify-reset-code/', data={
                'email': self.verified_email,
                'code': code
            })
            
            if success:
                # Move to step 3
                self.stacked.setCurrentIndex(2)
            else:
                error_msg = data.get('message', data.get('error', 'Invalid code'))
                QMessageBox.warning(self,
                    I18N.t("âŒ Invalid Code", "âŒ MÃ£ khÃ´ng Ä‘Ãºng"),
                    I18N.t(f"The verification code is incorrect or expired.\n{error_msg}",
                           f"MÃ£ xÃ¡c nháº­n khÃ´ng Ä‘Ãºng hoáº·c Ä‘Ã£ háº¿t háº¡n.\n{error_msg}"))
        except Exception as e:
            QMessageBox.critical(self,
                I18N.t("Error", "Lá»—i"),
                I18N.t(f"Error: {str(e)}", f"Lá»—i: {str(e)}"))
        finally:
            self.verify_code_btn.setEnabled(True)
            self.verify_code_btn.setText(I18N.t("âœ“ Verify Code", "âœ“ XÃ¡c nháº­n mÃ£"))
    
    def _reset_password(self):
        """Äáº·t láº¡i máº­t kháº©u má»›i"""
        new_password = self.new_password_input.text()
        confirm_password = self.confirm_password_input.text()
        
        if not new_password:
            QMessageBox.warning(self,
                I18N.t("Validation Error", "Lá»—i xÃ¡c thá»±c"),
                I18N.t("Please enter a new password.", "Vui lÃ²ng nháº­p máº­t kháº©u má»›i."))
            return
        
        if len(new_password) < 8:
            QMessageBox.warning(self,
                I18N.t("Weak Password", "Máº­t kháº©u yáº¿u"),
                I18N.t("Password must be at least 8 characters.", "Máº­t kháº©u pháº£i cÃ³ Ã­t nháº¥t 8 kÃ½ tá»±."))
            return
        
        if new_password != confirm_password:
            QMessageBox.warning(self,
                I18N.t("Password Mismatch", "Máº­t kháº©u khÃ´ng khá»›p"),
                I18N.t("Passwords do not match.", "Máº­t kháº©u khÃ´ng khá»›p."))
            return
        
        if not self.license_client or not self.verified_email:
            QMessageBox.warning(self,
                I18N.t("Error", "Lá»—i"),
                I18N.t("Session expired. Please start over.", "PhiÃªn Ä‘Ã£ háº¿t háº¡n. Vui lÃ²ng thá»­ láº¡i."))
            self.stacked.setCurrentIndex(0)
            return
        
        code = self.code_input.text().strip()
        
        # Disable button and show loading
        self.reset_password_btn.setEnabled(False)
        self.reset_password_btn.setText(I18N.t("â³ Resetting...", "â³ Äang Ä‘áº·t láº¡i..."))
        QApplication.processEvents()
        
        try:
            success, data = self.license_client._api_request('auth/reset-password/', data={
                'email': self.verified_email,
                'code': code,
                'new_password': new_password,
                'new_password_confirm': new_password
            })
            
            if success:
                QMessageBox.information(self,
                    I18N.t("âœ… Password Reset Successful", "âœ… Äáº·t láº¡i máº­t kháº©u thÃ nh cÃ´ng"),
                    I18N.t("Your password has been reset successfully!\nYou can now login with your new password.",
                           "Máº­t kháº©u Ä‘Ã£ Ä‘Æ°á»£c Ä‘áº·t láº¡i thÃ nh cÃ´ng!\nBáº¡n cÃ³ thá»ƒ Ä‘Äƒng nháº­p báº±ng máº­t kháº©u má»›i."))
                self.accept()
            else:
                error_msg = data.get('message', data.get('error', 'Unknown error'))
                QMessageBox.warning(self,
                    I18N.t("âŒ Error", "âŒ Lá»—i"),
                    str(error_msg))
        except Exception as e:
            QMessageBox.critical(self,
                I18N.t("Error", "Lá»—i"),
                I18N.t(f"Error: {str(e)}", f"Lá»—i: {str(e)}"))
        finally:
            self.reset_password_btn.setEnabled(True)
            self.reset_password_btn.setText(I18N.t("ðŸ”‘ Reset Password", "ðŸ”‘ Äáº·t láº¡i máº­t kháº©u"))


class RegisterDialog(QDialog):
    """Dialog Ä‘Äƒng kÃ½ tÃ i khoáº£n má»›i"""
    
    # Signal Ä‘á»ƒ thÃ´ng bÃ¡o Ä‘Äƒng kÃ½ thÃ nh cÃ´ng
    register_success = pyqtSignal(dict)
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle(I18N.t("ðŸ“ Register", "ðŸ“ ÄÄƒng kÃ½"))
        self.setMinimumWidth(450)
        self.setModal(True)
        self.license_client = None
        self.init_ui()
        self._init_license_client()
    
    def _init_license_client(self):
        """Initialize license client"""
        try:
            from license_client import get_license_client
            self.license_client = get_license_client(
                server_url=LICENSE_SERVER_URL
            )
        except Exception as e:
            print(f"[RegisterDialog] Cannot init license client: {e}")
        
    def init_ui(self):
        layout = QVBoxLayout()
        
        # Header
        header = QLabel(I18N.t("ðŸ“ Create New Account", "ðŸ“ Táº¡o TÃ i khoáº£n Má»›i"))
        header.setStyleSheet("font-size: 18px; font-weight: bold; color: #2196F3; margin-bottom: 10px;")
        header.setAlignment(Qt.AlignCenter)
        layout.addWidget(header)
        
        # Scroll area for form
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setFrameShape(QFrame.NoFrame)
        
        form_widget = QWidget()
        form_layout = QVBoxLayout(form_widget)
        
        # Personal Information
        personal_group = QGroupBox(I18N.t("ðŸ‘¤ Personal Information", "ðŸ‘¤ ThÃ´ng tin CÃ¡ nhÃ¢n"))
        personal_layout = QFormLayout()
        
        self.fullname_input = QLineEdit()
        self.fullname_input.setPlaceholderText(I18N.t("Enter your full name", "Nháº­p há» vÃ  tÃªn"))
        self.fullname_input.setStyleSheet("padding: 8px; border: 1px solid #ddd; border-radius: 4px;")
        personal_layout.addRow(I18N.t("Full Name:", "Há» vÃ  tÃªn:"), self.fullname_input)
        
        self.email_input = QLineEdit()
        self.email_input.setPlaceholderText(I18N.t("Enter your email", "Nháº­p email cá»§a báº¡n"))
        self.email_input.setStyleSheet("padding: 8px; border: 1px solid #ddd; border-radius: 4px;")
        personal_layout.addRow(I18N.t("Email:", "Email:"), self.email_input)
        
        self.phone_input = QLineEdit()
        self.phone_input.setPlaceholderText(I18N.t("Enter phone number (optional)", "Nháº­p sá»‘ Ä‘iá»‡n thoáº¡i (tÃ¹y chá»n)"))
        self.phone_input.setStyleSheet("padding: 8px; border: 1px solid #ddd; border-radius: 4px;")
        personal_layout.addRow(I18N.t("Phone:", "Äiá»‡n thoáº¡i:"), self.phone_input)
        
        personal_group.setLayout(personal_layout)
        form_layout.addWidget(personal_group)
        
        # Account Information
        account_group = QGroupBox(I18N.t("ðŸ” Account Security", "ðŸ” Báº£o máº­t TÃ i khoáº£n"))
        account_layout = QFormLayout()
        
        self.username_input = QLineEdit()
        self.username_input.setPlaceholderText(I18N.t("Choose a username", "Chá»n tÃªn Ä‘Äƒng nháº­p"))
        self.username_input.setStyleSheet("padding: 8px; border: 1px solid #ddd; border-radius: 4px;")
        account_layout.addRow(I18N.t("Username:", "TÃªn Ä‘Äƒng nháº­p:"), self.username_input)
        
        self.password_input = QLineEdit()
        self.password_input.setEchoMode(QLineEdit.Password)
        self.password_input.setPlaceholderText(I18N.t("Create password (min 8 characters)", "Táº¡o máº­t kháº©u (tá»‘i thiá»ƒu 8 kÃ½ tá»±)"))
        self.password_input.setStyleSheet("padding: 8px; border: 1px solid #ddd; border-radius: 4px;")
        account_layout.addRow(I18N.t("Password:", "Máº­t kháº©u:"), self.password_input)
        
        self.confirm_password_input = QLineEdit()
        self.confirm_password_input.setEchoMode(QLineEdit.Password)
        self.confirm_password_input.setPlaceholderText(I18N.t("Confirm your password", "XÃ¡c nháº­n máº­t kháº©u"))
        self.confirm_password_input.setStyleSheet("padding: 8px; border: 1px solid #ddd; border-radius: 4px;")
        account_layout.addRow(I18N.t("Confirm Password:", "XÃ¡c nháº­n máº­t kháº©u:"), self.confirm_password_input)
        
        account_group.setLayout(account_layout)
        form_layout.addWidget(account_group)
        
        # Trading Preferences
        trading_group = QGroupBox(I18N.t("ðŸ“Š Trading Preferences", "ðŸ“Š TÃ¹y chá»n Giao dá»‹ch"))
        trading_layout = QFormLayout()
        
        self.experience_combo = QComboBox()
        self.experience_combo.addItems([
            I18N.t("Beginner (< 1 year)", "Má»›i báº¯t Ä‘áº§u (< 1 nÄƒm)"),
            I18N.t("Intermediate (1-3 years)", "Trung bÃ¬nh (1-3 nÄƒm)"),
            I18N.t("Advanced (3-5 years)", "NÃ¢ng cao (3-5 nÄƒm)"),
            I18N.t("Expert (> 5 years)", "ChuyÃªn gia (> 5 nÄƒm)")
        ])
        self.experience_combo.setStyleSheet("padding: 8px; border: 1px solid #ddd; border-radius: 4px;")
        trading_layout.addRow(I18N.t("Experience Level:", "TrÃ¬nh Ä‘á»™ kinh nghiá»‡m:"), self.experience_combo)
        
        self.trading_style_combo = QComboBox()
        self.trading_style_combo.addItems([
            I18N.t("Scalping", "Scalping (LÆ°á»›t sÃ³ng)"),
            I18N.t("Day Trading", "Day Trading (Giao dá»‹ch trong ngÃ y)"),
            I18N.t("Swing Trading", "Swing Trading (Giao dá»‹ch trung háº¡n)"),
            I18N.t("Position Trading", "Position Trading (Giao dá»‹ch dÃ i háº¡n)")
        ])
        self.trading_style_combo.setStyleSheet("padding: 8px; border: 1px solid #ddd; border-radius: 4px;")
        trading_layout.addRow(I18N.t("Trading Style:", "Phong cÃ¡ch giao dá»‹ch:"), self.trading_style_combo)
        
        trading_group.setLayout(trading_layout)
        form_layout.addWidget(trading_group)
        
        # Terms and Conditions
        terms_layout = QHBoxLayout()
        self.terms_cb = QCheckBox()
        terms_label = QLabel(I18N.t(
            "I agree to the <a href='terms'>Terms of Service</a> and <a href='privacy'>Privacy Policy</a>",
            "TÃ´i Ä‘á»“ng Ã½ vá»›i <a href='terms'>Äiá»u khoáº£n Dá»‹ch vá»¥</a> vÃ  <a href='privacy'>ChÃ­nh sÃ¡ch Báº£o máº­t</a>"
        ))
        terms_label.setOpenExternalLinks(False)
        terms_label.linkActivated.connect(self.show_legal_document)
        terms_layout.addWidget(self.terms_cb)
        terms_layout.addWidget(terms_label, 1)
        form_layout.addLayout(terms_layout)
        
        scroll.setWidget(form_widget)
        layout.addWidget(scroll)
        
        # Buttons
        btn_layout = QHBoxLayout()
        
        self.register_btn = QPushButton(I18N.t("ðŸ“ Register", "ðŸ“ ÄÄƒng kÃ½"))
        self.register_btn.setStyleSheet("""
            QPushButton {
                background-color: #2196F3;
                color: white;
                font-weight: bold;
                padding: 10px 20px;
                border: none;
                border-radius: 5px;
                font-size: 14px;
            }
            QPushButton:hover {
                background-color: #1976D2;
            }
        """)
        self.register_btn.clicked.connect(self.do_register)
        
        self.cancel_btn = QPushButton(I18N.t("Cancel", "Há»§y"))
        self.cancel_btn.setStyleSheet("""
            QPushButton {
                background-color: #9e9e9e;
                color: white;
                font-weight: bold;
                padding: 10px 20px;
                border: none;
                border-radius: 5px;
                font-size: 14px;
            }
            QPushButton:hover {
                background-color: #757575;
            }
        """)
        self.cancel_btn.clicked.connect(self.reject)
        
        btn_layout.addWidget(self.register_btn)
        btn_layout.addWidget(self.cancel_btn)
        layout.addLayout(btn_layout)
        
        # Login link
        login_link = QLabel(I18N.t("<a href='#'>Already have an account? Login here</a>", "<a href='#'>ÄÃ£ cÃ³ tÃ i khoáº£n? ÄÄƒng nháº­p táº¡i Ä‘Ã¢y</a>"))
        login_link.setOpenExternalLinks(False)
        login_link.linkActivated.connect(self.open_login)
        login_link.setAlignment(Qt.AlignCenter)
        login_link.setStyleSheet("margin-top: 10px;")
        layout.addWidget(login_link)
        
        self.setLayout(layout)
        
    def do_register(self):
        # Validate inputs
        fullname = self.fullname_input.text().strip()
        email = self.email_input.text().strip()
        username = self.username_input.text().strip()
        password = self.password_input.text()
        confirm_password = self.confirm_password_input.text()
        
        if not fullname or not email or not username or not password:
            QMessageBox.warning(self,
                I18N.t("Validation Error", "Lá»—i xÃ¡c thá»±c"),
                I18N.t("Please fill in all required fields", "Vui lÃ²ng Ä‘iá»n Ä‘áº§y Ä‘á»§ thÃ´ng tin báº¯t buá»™c"))
            return
        
        if password != confirm_password:
            QMessageBox.warning(self,
                I18N.t("Password Mismatch", "Máº­t kháº©u khÃ´ng khá»›p"),
                I18N.t("Passwords do not match. Please try again.", "Máº­t kháº©u khÃ´ng khá»›p. Vui lÃ²ng thá»­ láº¡i."))
            return
        
        if len(password) < 8:
            QMessageBox.warning(self,
                I18N.t("Weak Password", "Máº­t kháº©u yáº¿u"),
                I18N.t("Password must be at least 8 characters long.", "Máº­t kháº©u pháº£i cÃ³ Ã­t nháº¥t 8 kÃ½ tá»±."))
            return
        
        if not self.terms_cb.isChecked():
            QMessageBox.warning(self,
                I18N.t("Terms Required", "YÃªu cáº§u Äiá»u khoáº£n"),
                I18N.t("You must agree to the Terms of Service and Privacy Policy.", "Báº¡n pháº£i Ä‘á»“ng Ã½ vá»›i Äiá»u khoáº£n Dá»‹ch vá»¥ vÃ  ChÃ­nh sÃ¡ch Báº£o máº­t."))
            return
        
        # Connect to License Server
        if not self.license_client:
            QMessageBox.warning(self, 
                I18N.t("Error", "Lá»—i"),
                I18N.t("License client not initialized. Please restart the app.", 
                       "KhÃ´ng thá»ƒ khá»Ÿi táº¡o license client. Vui lÃ²ng khá»Ÿi Ä‘á»™ng láº¡i á»©ng dá»¥ng."))
            return
        
        # Disable button and show loading
        self.register_btn.setEnabled(False)
        self.register_btn.setText(I18N.t("â³ Registering...", "â³ Äang Ä‘Äƒng kÃ½..."))
        QApplication.processEvents()
        
        try:
            # Parse full name into first and last name
            name_parts = fullname.split(' ', 1)
            first_name = name_parts[0]
            last_name = name_parts[1] if len(name_parts) > 1 else ''
            phone = self.phone_input.text().strip()
            
            print(f"[RegisterDialog] ðŸ“¤ Sending register request for {username}...")
            success, data = self.license_client.register(
                username=username,
                password=password,
                email=email,
                first_name=first_name,
                last_name=last_name,
                phone=phone,
                language=AppState.language()  # Gá»­i ngÃ´n ngá»¯ hiá»‡n táº¡i
            )
            print(f"[RegisterDialog] ðŸ“¥ Got response: success={success}, data={data}")
            
            if success:
                # Registration successful - Check if activation code is required
                require_activation = data.get('require_activation', False)
                email_sent = data.get('email_sent', False)
                
                if require_activation:
                    # Show message about activation code
                    if email_sent:
                        QMessageBox.information(self,
                            I18N.t("âœ… Registration Successful", "âœ… ÄÄƒng kÃ½ thÃ nh cÃ´ng"),
                            I18N.t(f"Welcome to Trading Bot!\n\nðŸ“§ An activation code has been sent to your email: {email}\n\nPlease check your inbox (and spam folder) for the 6-character activation code.\n\nEnter the code in the next screen to activate your Trial license.",
                                   f"ChÃ o má»«ng báº¡n Ä‘áº¿n vá»›i Trading Bot!\n\nðŸ“§ MÃ£ kÃ­ch hoáº¡t Ä‘Ã£ Ä‘Æ°á»£c gá»­i Ä‘áº¿n email: {email}\n\nVui lÃ²ng kiá»ƒm tra há»™p thÆ° (vÃ  thÆ° rÃ¡c) Ä‘á»ƒ láº¥y mÃ£ kÃ­ch hoáº¡t 6 kÃ½ tá»±.\n\nNháº­p mÃ£ vÃ o mÃ n hÃ¬nh tiáº¿p theo Ä‘á»ƒ kÃ­ch hoáº¡t License Trial."))
                    
                    # Close register dialog and open activation code dialog
                    self.accept()
                    
                    # Open activation code dialog
                    activation_dialog = ActivationCodeDialog(username, self.parent())
                    activation_dialog.exec_()
                else:
                    # Old flow - License granted directly
                    message = data.get('message', 'ÄÄƒng kÃ½ thÃ nh cÃ´ng!')
                    
                    if email_sent:
                        QMessageBox.information(self,
                            I18N.t("âœ… Registration Successful", "âœ… ÄÄƒng kÃ½ thÃ nh cÃ´ng"),
                            I18N.t(f"Welcome to Trading Bot!\n\nðŸ“§ A verification email has been sent to your email address.\n\nPlease check your inbox and click the verification link to activate your account.\n\nAfter verification, please wait for Admin to grant your license.",
                                   f"ChÃ o má»«ng báº¡n Ä‘áº¿n vá»›i Trading Bot!\n\nðŸ“§ Email xÃ¡c thá»±c Ä‘Ã£ Ä‘Æ°á»£c gá»­i Ä‘áº¿n Ä‘á»‹a chá»‰ email cá»§a báº¡n.\n\nVui lÃ²ng kiá»ƒm tra há»™p thÆ° vÃ  nháº¥n vÃ o link xÃ¡c thá»±c Ä‘á»ƒ kÃ­ch hoáº¡t tÃ i khoáº£n.\n\nSau khi xÃ¡c thá»±c, vui lÃ²ng chá» Admin cáº¥p License."))
                    else:
                        QMessageBox.information(self,
                            I18N.t("âœ… Registration Successful", "âœ… ÄÄƒng kÃ½ thÃ nh cÃ´ng"),
                            I18N.t(f"Welcome to Trading Bot!\n\nYour account has been created.\n\nPlease wait for Admin to review and grant your license.\n\nYou will be notified when your license is ready.",
                                   f"ChÃ o má»«ng báº¡n Ä‘áº¿n vá»›i Trading Bot!\n\nTÃ i khoáº£n cá»§a báº¡n Ä‘Ã£ Ä‘Æ°á»£c táº¡o.\n\nVui lÃ²ng chá» Admin xÃ©t duyá»‡t vÃ  cáº¥p License.\n\nBáº¡n sáº½ Ä‘Æ°á»£c thÃ´ng bÃ¡o khi License sáºµn sÃ ng."))
                    
                    self.accept()
            else:
                # Registration failed
                if data is None:
                    data = {}
                error_msg = data.get('message', data.get('error', 'Unknown error'))
                
                # Check for specific errors
                if 'username' in str(data):
                    error_msg = I18N.t("Username already exists. Please choose another.", 
                                       "TÃªn Ä‘Äƒng nháº­p Ä‘Ã£ tá»“n táº¡i. Vui lÃ²ng chá»n tÃªn khÃ¡c.")
                elif 'email' in str(data):
                    error_msg = I18N.t("Email already registered. Please use another email or login.", 
                                       "Email Ä‘Ã£ Ä‘Æ°á»£c Ä‘Äƒng kÃ½. Vui lÃ²ng sá»­ dá»¥ng email khÃ¡c hoáº·c Ä‘Äƒng nháº­p.")
                elif data.get('error') == 'connection_error':
                    error_msg = I18N.t("Cannot connect to server. Please check your internet connection.",
                                       "KhÃ´ng thá»ƒ káº¿t ná»‘i Ä‘áº¿n mÃ¡y chá»§. Vui lÃ²ng kiá»ƒm tra káº¿t ná»‘i internet.")
                
                QMessageBox.warning(self,
                    I18N.t("âŒ Registration Failed", "âŒ ÄÄƒng kÃ½ tháº¥t báº¡i"),
                    str(error_msg))
                    
        except Exception as e:
            QMessageBox.critical(self,
                I18N.t("Error", "Lá»—i"),
                I18N.t(f"Registration error: {str(e)}", f"Lá»—i Ä‘Äƒng kÃ½: {str(e)}"))
        finally:
            self.register_btn.setEnabled(True)
            self.register_btn.setText(I18N.t("ðŸ“ Register", "ðŸ“ ÄÄƒng kÃ½"))
    
    def open_login(self):
        self.reject()  # Close register dialog
        login_dialog = LoginDialog(self.parent())
        login_dialog.exec_()
    
    def show_legal_document(self, link):
        """Show Terms of Service or Privacy Policy dialog"""
        if link == 'terms':
            dialog = TermsOfServiceDialog(self)
            dialog.exec_()
        elif link == 'privacy':
            dialog = PrivacyPolicyDialog(self)
            dialog.exec_()


class ActivationCodeDialog(QDialog):
    """Dialog nháº­p mÃ£ kÃ­ch hoáº¡t 6 kÃ½ tá»± Ä‘á»ƒ kÃ­ch hoáº¡t tÃ i khoáº£n Trial"""
    
    # Signal Ä‘á»ƒ thÃ´ng bÃ¡o kÃ­ch hoáº¡t thÃ nh cÃ´ng vá»›i thÃ´ng tin license
    activation_success = pyqtSignal(dict)
    
    def __init__(self, username: str, parent=None):
        super().__init__(parent)
        self.username = username
        self.setWindowTitle(I18N.t("ðŸ”‘ Activate Account", "ðŸ”‘ KÃ­ch hoáº¡t TÃ i khoáº£n"))
        self.setMinimumWidth(400)
        self.setModal(True)
        self.license_client = None
        self.init_ui()
        self._init_license_client()
    
    def _init_license_client(self):
        """Initialize license client"""
        try:
            from license_client import get_license_client
            self.license_client = get_license_client(
                server_url=LICENSE_SERVER_URL
            )
        except Exception as e:
            print(f"[ActivationCodeDialog] Cannot init license client: {e}")
    
    def init_ui(self):
        layout = QVBoxLayout()
        layout.setSpacing(15)
        
        # Header
        header = QLabel(I18N.t("ðŸ”‘ Enter Activation Code", "ðŸ”‘ Nháº­p MÃ£ KÃ­ch Hoáº¡t"))
        header.setStyleSheet("font-size: 20px; font-weight: bold; color: #4CAF50; margin-bottom: 5px;")
        header.setAlignment(Qt.AlignCenter)
        layout.addWidget(header)
        
        # Description
        desc = QLabel(I18N.t(
            "Your account has been created!\n\nPlease enter the 6-character activation code to activate your Trial license.",
            "TÃ i khoáº£n cá»§a báº¡n Ä‘Ã£ Ä‘Æ°á»£c táº¡o!\n\nVui lÃ²ng nháº­p mÃ£ kÃ­ch hoáº¡t 6 kÃ½ tá»± Ä‘á»ƒ kÃ­ch hoáº¡t License Trial."))
        desc.setStyleSheet("color: #666; margin-bottom: 10px;")
        desc.setAlignment(Qt.AlignCenter)
        desc.setWordWrap(True)
        layout.addWidget(desc)
        
        # Username display
        user_label = QLabel(I18N.t(f"ðŸ‘¤ Username: {self.username}", f"ðŸ‘¤ TÃªn Ä‘Äƒng nháº­p: {self.username}"))
        user_label.setStyleSheet("font-size: 14px; font-weight: bold; color: #1976D2; background: #E3F2FD; padding: 10px; border-radius: 5px;")
        user_label.setAlignment(Qt.AlignCenter)
        layout.addWidget(user_label)
        
        # Code input group
        code_group = QGroupBox(I18N.t("Activation Code", "MÃ£ KÃ­ch Hoáº¡t"))
        code_layout = QVBoxLayout()
        
        self.code_input = QLineEdit()
        self.code_input.setPlaceholderText("ABC123")
        self.code_input.setMaxLength(6)
        self.code_input.setAlignment(Qt.AlignCenter)
        self.code_input.setStyleSheet("""
            QLineEdit {
                padding: 15px;
                font-size: 24px;
                font-weight: bold;
                letter-spacing: 8px;
                text-transform: uppercase;
                border: 2px solid #4CAF50;
                border-radius: 8px;
                background: #F1F8E9;
            }
            QLineEdit:focus {
                border-color: #2E7D32;
                background: white;
            }
        """)
        self.code_input.textChanged.connect(self._on_code_changed)
        code_layout.addWidget(self.code_input)
        
        # Hint
        hint = QLabel(I18N.t("Enter 6-character code (letters and numbers)", "Nháº­p mÃ£ 6 kÃ½ tá»± (chá»¯ vÃ  sá»‘)"))
        hint.setStyleSheet("color: #888; font-size: 11px;")
        hint.setAlignment(Qt.AlignCenter)
        code_layout.addWidget(hint)
        
        code_group.setLayout(code_layout)
        layout.addWidget(code_group)
        
        # Buttons
        btn_layout = QHBoxLayout()
        
        self.activate_btn = QPushButton(I18N.t("âœ… Activate", "âœ… KÃ­ch hoáº¡t"))
        self.activate_btn.setEnabled(False)
        self.activate_btn.setStyleSheet("""
            QPushButton {
                background-color: #4CAF50;
                color: white;
                font-weight: bold;
                padding: 12px 25px;
                border: none;
                border-radius: 5px;
                font-size: 14px;
            }
            QPushButton:hover {
                background-color: #388E3C;
            }
            QPushButton:disabled {
                background-color: #BDBDBD;
            }
        """)
        self.activate_btn.clicked.connect(self.do_activate)
        
        self.cancel_btn = QPushButton(I18N.t("Later", "Äá»ƒ sau"))
        self.cancel_btn.setStyleSheet("""
            QPushButton {
                background-color: #9E9E9E;
                color: white;
                font-weight: bold;
                padding: 12px 25px;
                border: none;
                border-radius: 5px;
                font-size: 14px;
            }
            QPushButton:hover {
                background-color: #757575;
            }
        """)
        self.cancel_btn.clicked.connect(self.reject)
        
        btn_layout.addWidget(self.activate_btn)
        btn_layout.addWidget(self.cancel_btn)
        layout.addLayout(btn_layout)
        
        # Note
        note = QLabel(I18N.t(
            "ðŸ’¡ Don't have an activation code? Contact Admin to get one.",
            "ðŸ’¡ ChÆ°a cÃ³ mÃ£ kÃ­ch hoáº¡t? LiÃªn há»‡ Admin Ä‘á»ƒ Ä‘Æ°á»£c cáº¥p mÃ£."))
        note.setStyleSheet("color: #FF9800; font-size: 11px; margin-top: 10px;")
        note.setAlignment(Qt.AlignCenter)
        note.setWordWrap(True)
        layout.addWidget(note)
        
        self.setLayout(layout)
        
        # Focus on code input
        self.code_input.setFocus()
    
    def _on_code_changed(self, text):
        """Enable activate button when code has 6 characters"""
        # Convert to uppercase
        self.code_input.blockSignals(True)
        self.code_input.setText(text.upper())
        self.code_input.blockSignals(False)
        
        # Enable button when 6 chars
        self.activate_btn.setEnabled(len(text) == 6)
    
    def do_activate(self):
        """KÃ­ch hoáº¡t báº±ng mÃ£"""
        code = self.code_input.text().strip().upper()
        
        if len(code) != 6:
            QMessageBox.warning(self,
                I18N.t("Invalid Code", "MÃ£ khÃ´ng há»£p lá»‡"),
                I18N.t("Please enter a 6-character activation code.", "Vui lÃ²ng nháº­p mÃ£ kÃ­ch hoáº¡t 6 kÃ½ tá»±."))
            return
        
        if not self.license_client:
            QMessageBox.warning(self,
                I18N.t("Error", "Lá»—i"),
                I18N.t("Cannot connect to license server.", "KhÃ´ng thá»ƒ káº¿t ná»‘i Ä‘áº¿n mÃ¡y chá»§ license."))
            return
        
        # Disable button and show loading
        self.activate_btn.setEnabled(False)
        self.activate_btn.setText(I18N.t("â³ Activating...", "â³ Äang kÃ­ch hoáº¡t..."))
        QApplication.processEvents()
        
        try:
            success, data = self.license_client.activate_by_code(self.username, code)
            
            if success:
                # Activation successful
                license_info = data.get('license', {})
                days = license_info.get('days_remaining', 7)
                license_type = license_info.get('license_type', 'trial')
                
                QMessageBox.information(self,
                    I18N.t("âœ… Activation Successful", "âœ… KÃ­ch hoáº¡t thÃ nh cÃ´ng"),
                    I18N.t(f"ðŸŽ‰ Congratulations!\n\nYour account has been activated!\n\nðŸ“‹ License Type: {license_type.upper()}\nâ° Days Remaining: {days} days\n\nNow please login with your password.",
                           f"ðŸŽ‰ ChÃºc má»«ng!\n\nTÃ i khoáº£n cá»§a báº¡n Ä‘Ã£ Ä‘Æ°á»£c kÃ­ch hoáº¡t!\n\nðŸ“‹ Loáº¡i License: {license_type.upper()}\nâ° Thá»i háº¡n: {days} ngÃ y\n\nBÃ¢y giá» hÃ£y Ä‘Äƒng nháº­p báº±ng máº­t kháº©u cá»§a báº¡n."))
                
                # Emit signal
                self.activation_success.emit(data)
                
                # Close this dialog
                self.accept()
                
                # Auto open LoginDialog with username pre-filled
                login_dialog = LoginDialog(self.parent())
                login_dialog.email_input.setText(self.username)
                login_dialog.password_input.setFocus()
                
                # Show login dialog
                if login_dialog.exec_() == QDialog.Accepted:
                    # Login successful - the main app will continue
                    pass
            else:
                # Activation failed
                error_msg = data.get('error', data.get('message', 'Unknown error'))
                if 'not found' in str(error_msg).lower():
                    error_msg = I18N.t("Invalid activation code. Please check and try again.",
                                       "MÃ£ kÃ­ch hoáº¡t khÃ´ng há»£p lá»‡. Vui lÃ²ng kiá»ƒm tra vÃ  thá»­ láº¡i.")
                elif 'used' in str(error_msg).lower():
                    error_msg = I18N.t("This activation code has already been used.",
                                       "MÃ£ kÃ­ch hoáº¡t nÃ y Ä‘Ã£ Ä‘Æ°á»£c sá»­ dá»¥ng.")
                elif 'expired' in str(error_msg).lower() or 'invalid' in str(error_msg).lower():
                    error_msg = I18N.t("This activation code is expired or invalid.",
                                       "MÃ£ kÃ­ch hoáº¡t Ä‘Ã£ háº¿t háº¡n hoáº·c khÃ´ng há»£p lá»‡.")
                
                QMessageBox.warning(self,
                    I18N.t("âŒ Activation Failed", "âŒ KÃ­ch hoáº¡t tháº¥t báº¡i"),
                    str(error_msg))
                    
        except Exception as e:
            QMessageBox.critical(self,
                I18N.t("Error", "Lá»—i"),
                I18N.t(f"Activation error: {str(e)}", f"Lá»—i kÃ­ch hoáº¡t: {str(e)}"))
        finally:
            self.activate_btn.setEnabled(True)
            self.activate_btn.setText(I18N.t("âœ… Activate", "âœ… KÃ­ch hoáº¡t"))


class AccountProfileDialog(QDialog):
    """Dialog xem vÃ  chá»‰nh sá»­a thÃ´ng tin tÃ i khoáº£n"""
    
    profile_updated = pyqtSignal(dict)
    
    def __init__(self, username: str, parent=None, license_client=None):
        super().__init__(parent)
        self.username = username
        self.setWindowTitle(I18N.t("ðŸ‘¤ Account Profile", "ðŸ‘¤ ThÃ´ng tin TÃ i khoáº£n"))
        self.setMinimumWidth(500)
        self.setModal(True)
        self.license_client = license_client  # Use provided client or init new one
        self.user_data = {}
        self.init_ui()
        if not self.license_client:
            self._init_license_client()
        self._load_profile()
    
    def _init_license_client(self):
        """Initialize license client"""
        try:
            from license_client import get_license_client
            self.license_client = get_license_client(
                server_url=LICENSE_SERVER_URL
            )
            print(f"[AccountProfileDialog] âœ… License client initialized with token: {self.license_client._access_token[:30] if self.license_client._access_token else 'None'}...")
        except Exception as e:
            print(f"[AccountProfileDialog] âŒ Cannot init license client: {e}")
    
    def _load_profile(self):
        """Load profile tá»« server - Báº®T BUá»˜C pháº£i káº¿t ná»‘i server"""
        print(f"\n[AccountProfileDialog] === LOADING PROFILE ===")
        print(f"[AccountProfileDialog] Username: {self.username}")
        print(f"[AccountProfileDialog] License Client available: {self.license_client is not None}")
        if self.license_client:
            print(f"[AccountProfileDialog] Token: {self.license_client._access_token[:30] if self.license_client._access_token else 'None'}...")
        
        # Check license client
        if not self.license_client:
            print(f"[AccountProfileDialog] [ERROR] No license client!")
            self._show_login_required_dialog(
                I18N.t("License Client Error", "Lá»—i KhÃ¡ch hÃ ng License"),
                I18N.t("Cannot initialize license client. Please login again.",
                       "KhÃ´ng thá»ƒ khá»Ÿi táº¡o khÃ¡ch hÃ ng license. Vui lÃ²ng Ä‘Äƒng nháº­p láº¡i.")
            )
            return
        
        # Check if token exists
        if not self.license_client._access_token:
            print(f"[AccountProfileDialog] [ERROR] No access token - user must login first!")
            self._show_login_required_dialog(
                I18N.t("Login Required", "YÃªu cáº§u ÄÄƒng nháº­p"),
                I18N.t("Please login first to view your profile.",
                       "Vui lÃ²ng Ä‘Äƒng nháº­p trÆ°á»›c Ä‘á»ƒ xem há»“ sÆ¡ cá»§a báº¡n.")
            )
            return
        
        # Try to fetch profile with auto-refresh
        print(f"[AccountProfileDialog] [FETCH] Fetching profile from server...")
        success, data = self.license_client.get_profile()
        
        if success:
            print(f"[AccountProfileDialog] [OK] Profile loaded successfully!")
            self._populate_profile_from_server(data)
        else:
            # Failed to load profile
            error_code = data.get('error', 'unknown')
            error_msg = data.get('message', 'Unknown error')
            print(f"[AccountProfileDialog] [ERROR] Failed: {error_code} - {error_msg}")
            
            self._show_login_required_dialog(
                I18N.t("Cannot Load Profile", "KhÃ´ng thá»ƒ Táº£i Profile"),
                I18N.t(f"Failed to load profile from server: {error_msg}\n\nPlease login again to get a fresh token.",
                       f"KhÃ´ng thá»ƒ táº£i profile tá»« server: {error_msg}\n\nVui lÃ²ng Ä‘Äƒng nháº­p láº¡i Ä‘á»ƒ láº¥y token má»›i.")
            )
    
    def _show_login_required_dialog(self, title, message):
        """Show dialog yÃªu cáº§u user login láº¡i"""
        print(f"[AccountProfileDialog] Showing login required dialog: {title}")
        
        result = QMessageBox.critical(self,
            title,
            f"{message}\n\nVui lÃ²ng Ä‘Ã³ng dialog nÃ y vÃ  logout rá»“i login láº¡i.",
            QMessageBox.Ok)
        
        # Close this dialog after user clicks OK
        self.reject()
    
    def _populate_profile_from_server(self, data):
        """Populate profile from server data"""
        self.user_data = data.get('user', {})
        # Xá»­ lÃ½ cáº£ 'license' (singular) vÃ  'licenses' (list)
        license_data = data.get('license') or (data.get('licenses', [{}])[0] if data.get('licenses') else {})
        
        # Populate fields
        self.username_input.setText(self.user_data.get('username', ''))
        self.email_input.setText(self.user_data.get('email', ''))
        self.firstname_input.setText(self.user_data.get('first_name', ''))
        self.lastname_input.setText(self.user_data.get('last_name', ''))
        self.phone_input.setText(str(self.user_data.get('phone', '') or ''))
        
        # License info
        if license_data:
            license_type = license_data.get('license_type', 'N/A').upper()
            days_remaining = license_data.get('days_remaining', 0)
            expire_date = license_data.get('expire_date', 'N/A')
            if expire_date and len(str(expire_date)) > 10:
                expire_date = str(expire_date)[:10]
            self.license_info.setText(
                I18N.t(f"ðŸ“‹ License: {license_type} | â° Days: {days_remaining} | ðŸ“… Expires: {expire_date}",
                       f"ðŸ“‹ License: {license_type} | â° CÃ²n: {days_remaining} ngÃ y | ðŸ“… Háº¿t háº¡n: {expire_date}")
            )
        else:
            self.license_info.setText(I18N.t("âš ï¸ No active license", "âš ï¸ KhÃ´ng cÃ³ license hoáº¡t Ä‘á»™ng"))
        
        # Join date
        date_joined = self.user_data.get('date_joined', '')
        if date_joined:
            self.join_date_label.setText(
                I18N.t(f"ðŸ“… Member since: {date_joined[:10]}", f"ðŸ“… Tham gia: {date_joined[:10]}")
            )
    

    
    
    def init_ui(self):
        layout = QVBoxLayout()
        
        # Header
        header = QLabel(I18N.t("ðŸ‘¤ Account Profile", "ðŸ‘¤ ThÃ´ng tin TÃ i khoáº£n"))
        header.setStyleSheet("font-size: 20px; font-weight: bold; color: #1976D2; margin-bottom: 10px;")
        header.setAlignment(Qt.AlignCenter)
        layout.addWidget(header)
        
        # License info banner
        self.license_info = QLabel(I18N.t("Loading license info...", "Äang táº£i thÃ´ng tin license..."))
        self.license_info.setStyleSheet("""
            QLabel {
                background: #E3F2FD;
                color: #1565C0;
                padding: 10px;
                border-radius: 5px;
                font-weight: bold;
            }
        """)
        self.license_info.setAlignment(Qt.AlignCenter)
        layout.addWidget(self.license_info)
        
        # Form group - Account Info
        account_group = QGroupBox(I18N.t("ðŸ” Account Information", "ðŸ” ThÃ´ng tin TÃ i khoáº£n"))
        account_layout = QFormLayout()
        
        self.username_input = QLineEdit()
        self.username_input.setReadOnly(True)
        self.username_input.setStyleSheet("padding: 8px; background: #f5f5f5; border: 1px solid #ddd; border-radius: 4px;")
        account_layout.addRow(I18N.t("Username:", "TÃªn Ä‘Äƒng nháº­p:"), self.username_input)
        
        self.join_date_label = QLabel("")
        self.join_date_label.setStyleSheet("color: #666; font-style: italic;")
        account_layout.addRow("", self.join_date_label)
        
        account_group.setLayout(account_layout)
        layout.addWidget(account_group)
        
        # Form group - Personal Info
        personal_group = QGroupBox(I18N.t("ðŸ“ Personal Information", "ðŸ“ ThÃ´ng tin CÃ¡ nhÃ¢n"))
        personal_layout = QFormLayout()
        
        self.firstname_input = QLineEdit()
        self.firstname_input.setPlaceholderText(I18N.t("Enter first name", "Nháº­p tÃªn"))
        self.firstname_input.setStyleSheet("padding: 8px; border: 1px solid #ddd; border-radius: 4px;")
        personal_layout.addRow(I18N.t("First Name:", "TÃªn:"), self.firstname_input)
        
        self.lastname_input = QLineEdit()
        self.lastname_input.setPlaceholderText(I18N.t("Enter last name", "Nháº­p há»"))
        self.lastname_input.setStyleSheet("padding: 8px; border: 1px solid #ddd; border-radius: 4px;")
        personal_layout.addRow(I18N.t("Last Name:", "Há»:"), self.lastname_input)
        
        self.email_input = QLineEdit()
        self.email_input.setPlaceholderText(I18N.t("Enter email", "Nháº­p email"))
        self.email_input.setStyleSheet("padding: 8px; border: 1px solid #ddd; border-radius: 4px;")
        personal_layout.addRow(I18N.t("Email:", "Email:"), self.email_input)
        
        self.phone_input = QLineEdit()
        self.phone_input.setPlaceholderText(I18N.t("Enter phone number", "Nháº­p sá»‘ Ä‘iá»‡n thoáº¡i"))
        self.phone_input.setStyleSheet("padding: 8px; border: 1px solid #ddd; border-radius: 4px;")
        personal_layout.addRow(I18N.t("Phone:", "Äiá»‡n thoáº¡i:"), self.phone_input)
        
        personal_group.setLayout(personal_layout)
        layout.addWidget(personal_group)
        
        # Change Password Group
        password_group = QGroupBox(I18N.t("ðŸ”‘ Change Password", "ðŸ”‘ Äá»•i Máº­t kháº©u"))
        password_layout = QFormLayout()
        
        self.old_password_input = QLineEdit()
        self.old_password_input.setEchoMode(QLineEdit.Password)
        self.old_password_input.setPlaceholderText(I18N.t("Current password", "Máº­t kháº©u hiá»‡n táº¡i"))
        self.old_password_input.setStyleSheet("padding: 8px; border: 1px solid #ddd; border-radius: 4px;")
        password_layout.addRow(I18N.t("Current:", "Hiá»‡n táº¡i:"), self.old_password_input)
        
        self.new_password_input = QLineEdit()
        self.new_password_input.setEchoMode(QLineEdit.Password)
        self.new_password_input.setPlaceholderText(I18N.t("New password (min 8 chars)", "Máº­t kháº©u má»›i (tá»‘i thiá»ƒu 8 kÃ½ tá»±)"))
        self.new_password_input.setStyleSheet("padding: 8px; border: 1px solid #ddd; border-radius: 4px;")
        password_layout.addRow(I18N.t("New:", "Má»›i:"), self.new_password_input)
        
        self.confirm_password_input = QLineEdit()
        self.confirm_password_input.setEchoMode(QLineEdit.Password)
        self.confirm_password_input.setPlaceholderText(I18N.t("Confirm new password", "XÃ¡c nháº­n máº­t kháº©u má»›i"))
        self.confirm_password_input.setStyleSheet("padding: 8px; border: 1px solid #ddd; border-radius: 4px;")
        password_layout.addRow(I18N.t("Confirm:", "XÃ¡c nháº­n:"), self.confirm_password_input)
        
        self.change_password_btn = QPushButton(I18N.t("ðŸ”‘ Change Password", "ðŸ”‘ Äá»•i Máº­t kháº©u"))
        self.change_password_btn.setStyleSheet("""
            QPushButton {
                background-color: #FF9800;
                color: white;
                font-weight: bold;
                padding: 8px 15px;
                border: none;
                border-radius: 4px;
            }
            QPushButton:hover {
                background-color: #F57C00;
            }
        """)
        self.change_password_btn.clicked.connect(self._change_password)
        password_layout.addRow("", self.change_password_btn)
        
        password_group.setLayout(password_layout)
        layout.addWidget(password_group)
        
        # Buttons
        btn_layout = QHBoxLayout()
        
        self.save_btn = QPushButton(I18N.t("ðŸ’¾ Save Changes", "ðŸ’¾ LÆ°u thay Ä‘á»•i"))
        self.save_btn.setStyleSheet("""
            QPushButton {
                background-color: #4CAF50;
                color: white;
                font-weight: bold;
                padding: 10px 20px;
                border: none;
                border-radius: 5px;
                font-size: 14px;
            }
            QPushButton:hover {
                background-color: #45a049;
            }
        """)
        self.save_btn.clicked.connect(self._save_profile)
        
        self.cancel_btn = QPushButton(I18N.t("Cancel", "Há»§y"))
        self.cancel_btn.setStyleSheet("""
            QPushButton {
                background-color: #9e9e9e;
                color: white;
                font-weight: bold;
                padding: 10px 20px;
                border: none;
                border-radius: 5px;
                font-size: 14px;
            }
            QPushButton:hover {
                background-color: #757575;
            }
        """)
        self.cancel_btn.clicked.connect(self.reject)
        
        btn_layout.addWidget(self.save_btn)
        btn_layout.addWidget(self.cancel_btn)
        layout.addLayout(btn_layout)
        
        self.setLayout(layout)
    
    def _save_profile(self):
        """LÆ°u thÃ´ng tin profile"""
        if not self.license_client:
            QMessageBox.warning(self,
                I18N.t("Error", "Lá»—i"),
                I18N.t("Cannot connect to server.", "KhÃ´ng thá»ƒ káº¿t ná»‘i Ä‘áº¿n server."))
            return
        
        self.save_btn.setEnabled(False)
        self.save_btn.setText(I18N.t("â³ Saving...", "â³ Äang lÆ°u..."))
        QApplication.processEvents()
        
        try:
            success, data = self.license_client.update_profile(
                first_name=self.firstname_input.text().strip(),
                last_name=self.lastname_input.text().strip(),
                email=self.email_input.text().strip(),
                phone=self.phone_input.text().strip()
            )
            
            if success:
                QMessageBox.information(self,
                    I18N.t("âœ… Success", "âœ… ThÃ nh cÃ´ng"),
                    I18N.t("Profile updated successfully!", "ÄÃ£ cáº­p nháº­t thÃ´ng tin thÃ nh cÃ´ng!"))
                self.profile_updated.emit(data.get('user', {}))
            else:
                error_msg = data.get('message', data.get('error', 'Unknown error'))
                QMessageBox.warning(self,
                    I18N.t("âŒ Error", "âŒ Lá»—i"),
                    str(error_msg))
        except Exception as e:
            QMessageBox.critical(self,
                I18N.t("Error", "Lá»—i"),
                I18N.t(f"Error: {str(e)}", f"Lá»—i: {str(e)}"))
        finally:
            self.save_btn.setEnabled(True)
            self.save_btn.setText(I18N.t("ðŸ’¾ Save Changes", "ðŸ’¾ LÆ°u thay Ä‘á»•i"))
    
    def _change_password(self):
        """Äá»•i máº­t kháº©u"""
        old_password = self.old_password_input.text()
        new_password = self.new_password_input.text()
        confirm_password = self.confirm_password_input.text()
        
        if not old_password or not new_password:
            QMessageBox.warning(self,
                I18N.t("Validation Error", "Lá»—i xÃ¡c thá»±c"),
                I18N.t("Please enter current and new password.", "Vui lÃ²ng nháº­p máº­t kháº©u hiá»‡n táº¡i vÃ  máº­t kháº©u má»›i."))
            return
        
        if new_password != confirm_password:
            QMessageBox.warning(self,
                I18N.t("Password Mismatch", "Máº­t kháº©u khÃ´ng khá»›p"),
                I18N.t("New passwords do not match.", "Máº­t kháº©u má»›i khÃ´ng khá»›p."))
            return
        
        if len(new_password) < 8:
            QMessageBox.warning(self,
                I18N.t("Weak Password", "Máº­t kháº©u yáº¿u"),
                I18N.t("Password must be at least 8 characters.", "Máº­t kháº©u pháº£i cÃ³ Ã­t nháº¥t 8 kÃ½ tá»±."))
            return
        
        if not self.license_client:
            QMessageBox.warning(self,
                I18N.t("Error", "Lá»—i"),
                I18N.t("Cannot connect to server.", "KhÃ´ng thá»ƒ káº¿t ná»‘i Ä‘áº¿n server."))
            return
        
        self.change_password_btn.setEnabled(False)
        self.change_password_btn.setText(I18N.t("â³ Changing...", "â³ Äang Ä‘á»•i..."))
        QApplication.processEvents()
        
        try:
            success, data = self.license_client.change_password(old_password, new_password)
            
            if success:
                QMessageBox.information(self,
                    I18N.t("âœ… Success", "âœ… ThÃ nh cÃ´ng"),
                    I18N.t("Password changed successfully!", "ÄÃ£ Ä‘á»•i máº­t kháº©u thÃ nh cÃ´ng!"))
                # Clear password fields
                self.old_password_input.clear()
                self.new_password_input.clear()
                self.confirm_password_input.clear()
            else:
                error_msg = data.get('message', data.get('error', 'Unknown error'))
                if 'incorrect' in str(error_msg).lower() or 'wrong' in str(error_msg).lower():
                    error_msg = I18N.t("Current password is incorrect.", "Máº­t kháº©u hiá»‡n táº¡i khÃ´ng Ä‘Ãºng.")
                QMessageBox.warning(self,
                    I18N.t("âŒ Error", "âŒ Lá»—i"),
                    str(error_msg))
        except Exception as e:
            QMessageBox.critical(self,
                I18N.t("Error", "Lá»—i"),
                I18N.t(f"Error: {str(e)}", f"Lá»—i: {str(e)}"))
        finally:
            self.change_password_btn.setEnabled(True)
            self.change_password_btn.setText(I18N.t("ðŸ”‘ Change Password", "ðŸ”‘ Äá»•i Máº­t kháº©u"))


class TermsOfServiceDialog(QDialog):
    """Dialog hiá»ƒn thá»‹ Äiá»u khoáº£n Dá»‹ch vá»¥"""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle(I18N.t("ðŸ“œ Terms of Service", "ðŸ“œ Äiá»u khoáº£n Dá»‹ch vá»¥"))
        self.setMinimumSize(600, 500)
        self.setModal(True)
        self.init_ui()
        
    def init_ui(self):
        layout = QVBoxLayout()
        
        # Header
        header = QLabel(I18N.t("ðŸ“œ Terms of Service", "ðŸ“œ Äiá»u khoáº£n Dá»‹ch vá»¥"))
        header.setStyleSheet("font-size: 20px; font-weight: bold; color: #1976D2; margin-bottom: 10px;")
        header.setAlignment(Qt.AlignCenter)
        layout.addWidget(header)
        
        # Last updated
        updated = QLabel(I18N.t("Last Updated: December 1, 2025", "Cáº­p nháº­t láº§n cuá»‘i: 01/12/2025"))
        updated.setStyleSheet("color: #666; font-style: italic; margin-bottom: 10px;")
        updated.setAlignment(Qt.AlignCenter)
        layout.addWidget(updated)
        
        # Content
        content = QTextEdit()
        content.setReadOnly(True)
        content.setStyleSheet("""
            QTextEdit {
                background-color: #fafafa;
                border: 1px solid #ddd;
                border-radius: 5px;
                padding: 10px;
                font-size: 13px;
                line-height: 1.6;
            }
        """)
        
        if AppState.language() == 'vi':
            terms_text = self.get_terms_vi()
        else:
            terms_text = self.get_terms_en()
        
        content.setHtml(terms_text)
        layout.addWidget(content)
        
        # Close button
        close_btn = QPushButton(I18N.t("Close", "ÄÃ³ng"))
        close_btn.setStyleSheet("""
            QPushButton {
                background-color: #2196F3;
                color: white;
                font-weight: bold;
                padding: 10px 30px;
                border: none;
                border-radius: 5px;
                font-size: 14px;
            }
            QPushButton:hover {
                background-color: #1976D2;
            }
        """)
        close_btn.clicked.connect(self.accept)
        layout.addWidget(close_btn, alignment=Qt.AlignCenter)
        
        self.setLayout(layout)
    
    def get_terms_en(self):
        return """
        <h2>ChatGPT AI Trading Bot - Terms of Service</h2>
        
        <h3>1. Acceptance of Terms</h3>
        <p>By accessing and using the ChatGPT AI Trading Bot ("Service"), you agree to be bound by these Terms of Service. If you do not agree to these terms, please do not use the Service.</p>
        
        <h3>2. Description of Service</h3>
        <p>The ChatGPT AI Trading Bot is an automated trading assistance tool that provides:</p>
        <ul>
            <li>Market data analysis and visualization</li>
            <li>Technical indicator calculations</li>
            <li>Pattern recognition and detection</li>
            <li>Trading signal generation</li>
            <li>Automated order execution (when enabled)</li>
            <li>Risk management tools</li>
        </ul>
        
        <h3>3. Risk Disclaimer</h3>
        <p><strong>IMPORTANT:</strong> Trading in financial markets involves substantial risk of loss and is not suitable for all investors. Past performance is not indicative of future results.</p>
        <ul>
            <li>You may lose some or all of your invested capital</li>
            <li>Do not trade with money you cannot afford to lose</li>
            <li>The Service does not guarantee profits or prevent losses</li>
            <li>AI-generated signals are for informational purposes only</li>
            <li>You are solely responsible for your trading decisions</li>
        </ul>
        
        <h3>4. User Responsibilities</h3>
        <p>As a user, you agree to:</p>
        <ul>
            <li>Provide accurate and truthful registration information</li>
            <li>Maintain the security of your account credentials</li>
            <li>Comply with all applicable laws and regulations</li>
            <li>Use the Service only for lawful purposes</li>
            <li>Not attempt to reverse engineer or modify the software</li>
            <li>Not share your account with unauthorized users</li>
        </ul>
        
        <h3>5. Intellectual Property</h3>
        <p>All content, features, and functionality of the Service are owned by VU HIEN CFDs and are protected by international copyright, trademark, and other intellectual property laws.</p>
        
        <h3>6. Limitation of Liability</h3>
        <p>To the maximum extent permitted by law:</p>
        <ul>
            <li>The Service is provided "AS IS" without warranties of any kind</li>
            <li>We are not liable for any trading losses or damages</li>
            <li>We are not responsible for third-party broker actions</li>
            <li>Technical issues or downtime do not create liability</li>
        </ul>
        
        <h3>7. Account Termination</h3>
        <p>We reserve the right to suspend or terminate accounts that:</p>
        <ul>
            <li>Violate these Terms of Service</li>
            <li>Engage in fraudulent activities</li>
            <li>Abuse the Service or other users</li>
            <li>Attempt unauthorized access to systems</li>
        </ul>
        
        <h3>8. Modifications</h3>
        <p>We may modify these Terms at any time. Continued use of the Service after changes constitutes acceptance of the new terms.</p>
        
        <h3>9. Contact Information</h3>
        <p><strong>VU HIEN CFDs</strong><br>
        Telegram/Zalo: +84 39 65 60 888<br>
        Email: vuhien2444cfds@gmail.com</p>
        
        <h3>10. Governing Law</h3>
        <p>These Terms shall be governed by the laws of Vietnam. Any disputes shall be resolved through arbitration in Ho Chi Minh City.</p>
        """
    
    def get_terms_vi(self):
        return """
        <h2>ChatGPT AI Trading Bot - Äiá»u khoáº£n Dá»‹ch vá»¥</h2>
        
        <h3>1. Cháº¥p nháº­n Äiá»u khoáº£n</h3>
        <p>Báº±ng viá»‡c truy cáº­p vÃ  sá»­ dá»¥ng ChatGPT AI Trading Bot ("Dá»‹ch vá»¥"), báº¡n Ä‘á»“ng Ã½ tuÃ¢n thá»§ cÃ¡c Äiá»u khoáº£n Dá»‹ch vá»¥ nÃ y. Náº¿u khÃ´ng Ä‘á»“ng Ã½, vui lÃ²ng khÃ´ng sá»­ dá»¥ng Dá»‹ch vá»¥.</p>
        
        <h3>2. MÃ´ táº£ Dá»‹ch vá»¥</h3>
        <p>ChatGPT AI Trading Bot lÃ  cÃ´ng cá»¥ há»— trá»£ giao dá»‹ch tá»± Ä‘á»™ng cung cáº¥p:</p>
        <ul>
            <li>PhÃ¢n tÃ­ch vÃ  hiá»ƒn thá»‹ dá»¯ liá»‡u thá»‹ trÆ°á»ng</li>
            <li>TÃ­nh toÃ¡n cÃ¡c chá»‰ bÃ¡o ká»¹ thuáº­t</li>
            <li>Nháº­n diá»‡n vÃ  phÃ¡t hiá»‡n mÃ´ hÃ¬nh</li>
            <li>Táº¡o tÃ­n hiá»‡u giao dá»‹ch</li>
            <li>Thá»±c hiá»‡n lá»‡nh tá»± Ä‘á»™ng (khi Ä‘Æ°á»£c báº­t)</li>
            <li>CÃ´ng cá»¥ quáº£n lÃ½ rá»§i ro</li>
        </ul>
        
        <h3>3. Cáº£nh bÃ¡o Rá»§i ro</h3>
        <p><strong>QUAN TRá»ŒNG:</strong> Giao dá»‹ch trÃªn thá»‹ trÆ°á»ng tÃ i chÃ­nh cÃ³ rá»§i ro thua lá»— Ä‘Ã¡ng ká»ƒ vÃ  khÃ´ng phÃ¹ há»£p vá»›i táº¥t cáº£ nhÃ  Ä‘áº§u tÆ°. Káº¿t quáº£ trong quÃ¡ khá»© khÃ´ng Ä‘áº£m báº£o káº¿t quáº£ tÆ°Æ¡ng lai.</p>
        <ul>
            <li>Báº¡n cÃ³ thá»ƒ máº¥t má»™t pháº§n hoáº·c toÃ n bá»™ vá»‘n Ä‘áº§u tÆ°</li>
            <li>KhÃ´ng giao dá»‹ch vá»›i sá»‘ tiá»n báº¡n khÃ´ng thá»ƒ cháº¥p nháº­n máº¥t</li>
            <li>Dá»‹ch vá»¥ khÃ´ng Ä‘áº£m báº£o lá»£i nhuáº­n hoáº·c ngÄƒn ngá»«a thua lá»—</li>
            <li>TÃ­n hiá»‡u AI chá»‰ mang tÃ­nh cháº¥t tham kháº£o</li>
            <li>Báº¡n hoÃ n toÃ n chá»‹u trÃ¡ch nhiá»‡m vá» quyáº¿t Ä‘á»‹nh giao dá»‹ch cá»§a mÃ¬nh</li>
        </ul>
        
        <h3>4. TrÃ¡ch nhiá»‡m cá»§a NgÆ°á»i dÃ¹ng</h3>
        <p>LÃ  ngÆ°á»i dÃ¹ng, báº¡n Ä‘á»“ng Ã½:</p>
        <ul>
            <li>Cung cáº¥p thÃ´ng tin Ä‘Äƒng kÃ½ chÃ­nh xÃ¡c vÃ  trung thá»±c</li>
            <li>Báº£o máº­t thÃ´ng tin Ä‘Äƒng nháº­p tÃ i khoáº£n</li>
            <li>TuÃ¢n thá»§ táº¥t cáº£ luáº­t phÃ¡p vÃ  quy Ä‘á»‹nh hiá»‡n hÃ nh</li>
            <li>Chá»‰ sá»­ dá»¥ng Dá»‹ch vá»¥ cho má»¥c Ä‘Ã­ch há»£p phÃ¡p</li>
            <li>KhÃ´ng cá»‘ gáº¯ng dá»‹ch ngÆ°á»£c hoáº·c sá»­a Ä‘á»•i pháº§n má»m</li>
            <li>KhÃ´ng chia sáº» tÃ i khoáº£n vá»›i ngÆ°á»i dÃ¹ng khÃ´ng Ä‘Æ°á»£c phÃ©p</li>
        </ul>
        
        <h3>5. Sá»Ÿ há»¯u TrÃ­ tuá»‡</h3>
        <p>Táº¥t cáº£ ná»™i dung, tÃ­nh nÄƒng vÃ  chá»©c nÄƒng cá»§a Dá»‹ch vá»¥ thuá»™c sá»Ÿ há»¯u cá»§a VU HIEN CFDs vÃ  Ä‘Æ°á»£c báº£o vá»‡ bá»Ÿi luáº­t báº£n quyá»n, thÆ°Æ¡ng hiá»‡u vÃ  sá»Ÿ há»¯u trÃ­ tuá»‡ quá»‘c táº¿.</p>
        
        <h3>6. Giá»›i háº¡n TrÃ¡ch nhiá»‡m</h3>
        <p>Trong pháº¡m vi phÃ¡p luáº­t cho phÃ©p:</p>
        <ul>
            <li>Dá»‹ch vá»¥ Ä‘Æ°á»£c cung cáº¥p "NGUYÃŠN TRáº NG" khÃ´ng cÃ³ báº¥t ká»³ báº£o Ä‘áº£m nÃ o</li>
            <li>ChÃºng tÃ´i khÃ´ng chá»‹u trÃ¡ch nhiá»‡m vá» báº¥t ká»³ thua lá»— giao dá»‹ch nÃ o</li>
            <li>ChÃºng tÃ´i khÃ´ng chá»‹u trÃ¡ch nhiá»‡m vá» hÃ nh Ä‘á»™ng cá»§a sÃ n mÃ´i giá»›i</li>
            <li>Sá»± cá»‘ ká»¹ thuáº­t hoáº·c giÃ¡n Ä‘oáº¡n khÃ´ng táº¡o ra trÃ¡ch nhiá»‡m phÃ¡p lÃ½</li>
        </ul>
        
        <h3>7. Cháº¥m dá»©t TÃ i khoáº£n</h3>
        <p>ChÃºng tÃ´i cÃ³ quyá»n Ä‘Ã¬nh chá»‰ hoáº·c cháº¥m dá»©t tÃ i khoáº£n:</p>
        <ul>
            <li>Vi pháº¡m Äiá»u khoáº£n Dá»‹ch vá»¥ nÃ y</li>
            <li>Tham gia hoáº¡t Ä‘á»™ng gian láº­n</li>
            <li>Láº¡m dá»¥ng Dá»‹ch vá»¥ hoáº·c ngÆ°á»i dÃ¹ng khÃ¡c</li>
            <li>Cá»‘ gáº¯ng truy cáº­p trÃ¡i phÃ©p vÃ o há»‡ thá»‘ng</li>
        </ul>
        
        <h3>8. Sá»­a Ä‘á»•i</h3>
        <p>ChÃºng tÃ´i cÃ³ thá»ƒ sá»­a Ä‘á»•i cÃ¡c Äiá»u khoáº£n nÃ y báº¥t cá»© lÃºc nÃ o. Viá»‡c tiáº¿p tá»¥c sá»­ dá»¥ng Dá»‹ch vá»¥ sau khi thay Ä‘á»•i Ä‘á»“ng nghÄ©a vá»›i viá»‡c cháº¥p nháº­n Ä‘iá»u khoáº£n má»›i.</p>
        
        <h3>9. ThÃ´ng tin LiÃªn há»‡</h3>
        <p><strong>VU HIEN CFDs</strong><br>
        Telegram/Zalo: +84 39 65 60 888<br>
        Email: vuhien2444cfds@gmail.com</p>
        
        <h3>10. Luáº­t Ã¡p dá»¥ng</h3>
        <p>CÃ¡c Äiá»u khoáº£n nÃ y Ä‘Æ°á»£c Ä‘iá»u chá»‰nh bá»Ÿi phÃ¡p luáº­t Viá»‡t Nam. Má»i tranh cháº¥p sáº½ Ä‘Æ°á»£c giáº£i quyáº¿t thÃ´ng qua trá»ng tÃ i táº¡i TP. Há»“ ChÃ­ Minh.</p>
        """


class PrivacyPolicyDialog(QDialog):
    """Dialog hiá»ƒn thá»‹ ChÃ­nh sÃ¡ch Báº£o máº­t"""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle(I18N.t("ðŸ”’ Privacy Policy", "ðŸ”’ ChÃ­nh sÃ¡ch Báº£o máº­t"))
        self.setMinimumSize(600, 500)
        self.setModal(True)
        self.init_ui()
        
    def init_ui(self):
        layout = QVBoxLayout()
        
        # Header
        header = QLabel(I18N.t("ðŸ”’ Privacy Policy", "ðŸ”’ ChÃ­nh sÃ¡ch Báº£o máº­t"))
        header.setStyleSheet("font-size: 20px; font-weight: bold; color: #4CAF50; margin-bottom: 10px;")
        header.setAlignment(Qt.AlignCenter)
        layout.addWidget(header)
        
        # Last updated
        updated = QLabel(I18N.t("Last Updated: December 1, 2025", "Cáº­p nháº­t láº§n cuá»‘i: 01/12/2025"))
        updated.setStyleSheet("color: #666; font-style: italic; margin-bottom: 10px;")
        updated.setAlignment(Qt.AlignCenter)
        layout.addWidget(updated)
        
        # Content
        content = QTextEdit()
        content.setReadOnly(True)
        content.setStyleSheet("""
            QTextEdit {
                background-color: #fafafa;
                border: 1px solid #ddd;
                border-radius: 5px;
                padding: 10px;
                font-size: 13px;
                line-height: 1.6;
            }
        """)
        
        if AppState.language() == 'vi':
            privacy_text = self.get_privacy_vi()
        else:
            privacy_text = self.get_privacy_en()
        
        content.setHtml(privacy_text)
        layout.addWidget(content)
        
        # Close button
        close_btn = QPushButton(I18N.t("Close", "ÄÃ³ng"))
        close_btn.setStyleSheet("""
            QPushButton {
                background-color: #4CAF50;
                color: white;
                font-weight: bold;
                padding: 10px 30px;
                border: none;
                border-radius: 5px;
                font-size: 14px;
            }
            QPushButton:hover {
                background-color: #45a049;
            }
        """)
        close_btn.clicked.connect(self.accept)
        layout.addWidget(close_btn, alignment=Qt.AlignCenter)
        
        self.setLayout(layout)
    
    def get_privacy_en(self):
        return """
        <h2>ChatGPT AI Trading Bot - Privacy Policy</h2>
        
        <h3>1. Introduction</h3>
        <p>VU HIEN CFDs ("we", "our", "us") is committed to protecting your privacy. This Privacy Policy explains how we collect, use, disclose, and safeguard your information when you use our ChatGPT AI Trading Bot.</p>
        
        <h3>2. Information We Collect</h3>
        
        <h4>2.1 Personal Information</h4>
        <ul>
            <li><strong>Account Information:</strong> Name, email address, phone number, username</li>
            <li><strong>Trading Preferences:</strong> Experience level, trading style preferences</li>
            <li><strong>MT5 Credentials:</strong> Account number, server (stored locally, encrypted)</li>
        </ul>
        
        <h4>2.2 Automatically Collected Information</h4>
        <ul>
            <li><strong>Usage Data:</strong> Features used, trading signals generated</li>
            <li><strong>Device Information:</strong> Operating system, software version</li>
            <li><strong>Log Data:</strong> Error logs, performance metrics</li>
        </ul>
        
        <h4>2.3 Trading Data</h4>
        <ul>
            <li>Historical trade records</li>
            <li>Position and order information</li>
            <li>Account balance and equity data</li>
            <li>Risk management settings</li>
        </ul>
        
        <h3>3. How We Use Your Information</h3>
        <p>We use collected information to:</p>
        <ul>
            <li>Provide and maintain the trading bot service</li>
            <li>Process and execute trading signals</li>
            <li>Improve and optimize our algorithms</li>
            <li>Send important service notifications</li>
            <li>Provide customer support</li>
            <li>Analyze usage patterns to enhance features</li>
            <li>Ensure security and prevent fraud</li>
        </ul>
        
        <h3>4. Data Storage and Security</h3>
        <ul>
            <li><strong>Local Storage:</strong> MT5 credentials are stored locally on your device only</li>
            <li><strong>Encryption:</strong> Sensitive data is encrypted using industry-standard AES-256</li>
            <li><strong>No Cloud Storage:</strong> Trading credentials are never uploaded to external servers</li>
            <li><strong>Secure Transmission:</strong> All data transmissions use SSL/TLS encryption</li>
        </ul>
        
        <h3>5. Data Sharing</h3>
        <p>We do NOT sell, trade, or rent your personal information. We may share data only:</p>
        <ul>
            <li>With your explicit consent</li>
            <li>To comply with legal obligations</li>
            <li>To protect our rights and safety</li>
            <li>With service providers under strict confidentiality agreements</li>
        </ul>
        
        <h3>6. Your Rights</h3>
        <p>You have the right to:</p>
        <ul>
            <li><strong>Access:</strong> Request a copy of your personal data</li>
            <li><strong>Correction:</strong> Update or correct inaccurate information</li>
            <li><strong>Deletion:</strong> Request deletion of your account and data</li>
            <li><strong>Portability:</strong> Export your data in a standard format</li>
            <li><strong>Opt-out:</strong> Unsubscribe from marketing communications</li>
        </ul>
        
        <h3>7. Data Retention</h3>
        <ul>
            <li>Account data: Retained while account is active</li>
            <li>Trading history: Retained for 3 years for analysis</li>
            <li>Log files: Retained for 90 days</li>
            <li>Deleted data: Permanently removed within 30 days</li>
        </ul>
        
        <h3>8. Children's Privacy</h3>
        <p>Our Service is not intended for users under 18 years of age. We do not knowingly collect personal information from minors.</p>
        
        <h3>9. Third-Party Services</h3>
        <p>The bot connects to:</p>
        <ul>
            <li><strong>MetaTrader 5:</strong> For trading execution (governed by broker's privacy policy)</li>
            <li><strong>Economic Calendar APIs:</strong> For news data (no personal data shared)</li>
        </ul>
        
        <h3>10. Updates to This Policy</h3>
        <p>We may update this Privacy Policy periodically. We will notify you of significant changes via email or in-app notification.</p>
        
        <h3>11. Contact Us</h3>
        <p>For privacy-related inquiries:<br>
        <strong>VU HIEN CFDs</strong><br>
        Telegram/Zalo: +84 39 65 60 888<br>
        Email: vuhien2444cfds@gmail.com</p>
        """
    
    def get_privacy_vi(self):
        return """
        <h2>ChatGPT AI Trading Bot - ChÃ­nh sÃ¡ch Báº£o máº­t</h2>
        
        <h3>1. Giá»›i thiá»‡u</h3>
        <p>VU HIEN CFDs ("chÃºng tÃ´i") cam káº¿t báº£o vá»‡ quyá»n riÃªng tÆ° cá»§a báº¡n. ChÃ­nh sÃ¡ch Báº£o máº­t nÃ y giáº£i thÃ­ch cÃ¡ch chÃºng tÃ´i thu tháº­p, sá»­ dá»¥ng, tiáº¿t lá»™ vÃ  báº£o vá»‡ thÃ´ng tin cá»§a báº¡n khi sá»­ dá»¥ng ChatGPT AI Trading Bot.</p>
        
        <h3>2. ThÃ´ng tin ChÃºng tÃ´i Thu tháº­p</h3>
        
        <h4>2.1 ThÃ´ng tin CÃ¡ nhÃ¢n</h4>
        <ul>
            <li><strong>ThÃ´ng tin TÃ i khoáº£n:</strong> Há» tÃªn, email, sá»‘ Ä‘iá»‡n thoáº¡i, tÃªn Ä‘Äƒng nháº­p</li>
            <li><strong>TÃ¹y chá»n Giao dá»‹ch:</strong> TrÃ¬nh Ä‘á»™ kinh nghiá»‡m, phong cÃ¡ch giao dá»‹ch</li>
            <li><strong>ThÃ´ng tin MT5:</strong> Sá»‘ tÃ i khoáº£n, server (lÆ°u cá»¥c bá»™, Ä‘Æ°á»£c mÃ£ hÃ³a)</li>
        </ul>
        
        <h4>2.2 ThÃ´ng tin Thu tháº­p Tá»± Ä‘á»™ng</h4>
        <ul>
            <li><strong>Dá»¯ liá»‡u Sá»­ dá»¥ng:</strong> TÃ­nh nÄƒng Ä‘Ã£ dÃ¹ng, tÃ­n hiá»‡u giao dá»‹ch Ä‘Ã£ táº¡o</li>
            <li><strong>ThÃ´ng tin Thiáº¿t bá»‹:</strong> Há»‡ Ä‘iá»u hÃ nh, phiÃªn báº£n pháº§n má»m</li>
            <li><strong>Dá»¯ liá»‡u Log:</strong> Log lá»—i, chá»‰ sá»‘ hiá»‡u suáº¥t</li>
        </ul>
        
        <h4>2.3 Dá»¯ liá»‡u Giao dá»‹ch</h4>
        <ul>
            <li>Lá»‹ch sá»­ giao dá»‹ch</li>
            <li>ThÃ´ng tin vá»‹ tháº¿ vÃ  lá»‡nh</li>
            <li>Sá»‘ dÆ° vÃ  vá»‘n tÃ i khoáº£n</li>
            <li>CÃ i Ä‘áº·t quáº£n lÃ½ rá»§i ro</li>
        </ul>
        
        <h3>3. CÃ¡ch ChÃºng tÃ´i Sá»­ dá»¥ng ThÃ´ng tin</h3>
        <p>ChÃºng tÃ´i sá»­ dá»¥ng thÃ´ng tin thu tháº­p Ä‘á»ƒ:</p>
        <ul>
            <li>Cung cáº¥p vÃ  duy trÃ¬ dá»‹ch vá»¥ trading bot</li>
            <li>Xá»­ lÃ½ vÃ  thá»±c hiá»‡n tÃ­n hiá»‡u giao dá»‹ch</li>
            <li>Cáº£i thiá»‡n vÃ  tá»‘i Æ°u thuáº­t toÃ¡n</li>
            <li>Gá»­i thÃ´ng bÃ¡o dá»‹ch vá»¥ quan trá»ng</li>
            <li>Cung cáº¥p há»— trá»£ khÃ¡ch hÃ ng</li>
            <li>PhÃ¢n tÃ­ch máº«u sá»­ dá»¥ng Ä‘á»ƒ nÃ¢ng cao tÃ­nh nÄƒng</li>
            <li>Äáº£m báº£o an ninh vÃ  ngÄƒn cháº·n gian láº­n</li>
        </ul>
        
        <h3>4. LÆ°u trá»¯ vÃ  Báº£o máº­t Dá»¯ liá»‡u</h3>
        <ul>
            <li><strong>LÆ°u trá»¯ Cá»¥c bá»™:</strong> ThÃ´ng tin MT5 chá»‰ Ä‘Æ°á»£c lÆ°u trá»¯ trÃªn thiáº¿t bá»‹ cá»§a báº¡n</li>
            <li><strong>MÃ£ hÃ³a:</strong> Dá»¯ liá»‡u nháº¡y cáº£m Ä‘Æ°á»£c mÃ£ hÃ³a báº±ng AES-256 tiÃªu chuáº©n</li>
            <li><strong>KhÃ´ng lÆ°u Cloud:</strong> ThÃ´ng tin Ä‘Äƒng nháº­p khÃ´ng bao giá» Ä‘Æ°á»£c táº£i lÃªn mÃ¡y chá»§ bÃªn ngoÃ i</li>
            <li><strong>Truyá»n táº£i An toÃ n:</strong> Táº¥t cáº£ dá»¯ liá»‡u truyá»n táº£i sá»­ dá»¥ng mÃ£ hÃ³a SSL/TLS</li>
        </ul>
        
        <h3>5. Chia sáº» Dá»¯ liá»‡u</h3>
        <p>ChÃºng tÃ´i KHÃ”NG bÃ¡n, trao Ä‘á»•i hoáº·c cho thuÃª thÃ´ng tin cÃ¡ nhÃ¢n. ChÃºng tÃ´i chá»‰ chia sáº» dá»¯ liá»‡u:</p>
        <ul>
            <li>Vá»›i sá»± Ä‘á»“ng Ã½ rÃµ rÃ ng cá»§a báº¡n</li>
            <li>Äá»ƒ tuÃ¢n thá»§ nghÄ©a vá»¥ phÃ¡p lÃ½</li>
            <li>Äá»ƒ báº£o vá»‡ quyá»n vÃ  an toÃ n cá»§a chÃºng tÃ´i</li>
            <li>Vá»›i nhÃ  cung cáº¥p dá»‹ch vá»¥ theo thá»a thuáº­n báº£o máº­t nghiÃªm ngáº·t</li>
        </ul>
        
        <h3>6. Quyá»n cá»§a Báº¡n</h3>
        <p>Báº¡n cÃ³ quyá»n:</p>
        <ul>
            <li><strong>Truy cáº­p:</strong> YÃªu cáº§u báº£n sao dá»¯ liá»‡u cÃ¡ nhÃ¢n</li>
            <li><strong>Chá»‰nh sá»­a:</strong> Cáº­p nháº­t hoáº·c sá»­a thÃ´ng tin khÃ´ng chÃ­nh xÃ¡c</li>
            <li><strong>XÃ³a:</strong> YÃªu cáº§u xÃ³a tÃ i khoáº£n vÃ  dá»¯ liá»‡u</li>
            <li><strong>Di chuyá»ƒn:</strong> Xuáº¥t dá»¯ liá»‡u á»Ÿ Ä‘á»‹nh dáº¡ng tiÃªu chuáº©n</li>
            <li><strong>Tá»« chá»‘i:</strong> Há»§y Ä‘Äƒng kÃ½ nháº­n thÃ´ng tin marketing</li>
        </ul>
        
        <h3>7. Thá»i gian LÆ°u trá»¯ Dá»¯ liá»‡u</h3>
        <ul>
            <li>Dá»¯ liá»‡u tÃ i khoáº£n: LÆ°u trá»¯ khi tÃ i khoáº£n cÃ²n hoáº¡t Ä‘á»™ng</li>
            <li>Lá»‹ch sá»­ giao dá»‹ch: LÆ°u trá»¯ 3 nÄƒm Ä‘á»ƒ phÃ¢n tÃ­ch</li>
            <li>File log: LÆ°u trá»¯ 90 ngÃ y</li>
            <li>Dá»¯ liá»‡u Ä‘Ã£ xÃ³a: XÃ³a vÄ©nh viá»…n trong 30 ngÃ y</li>
        </ul>
        
        <h3>8. Quyá»n riÃªng tÆ° cá»§a Tráº» em</h3>
        <p>Dá»‹ch vá»¥ khÃ´ng dÃ nh cho ngÆ°á»i dÃ¹ng dÆ°á»›i 18 tuá»•i. ChÃºng tÃ´i khÃ´ng cá»‘ Ã½ thu tháº­p thÃ´ng tin cÃ¡ nhÃ¢n tá»« tráº» vá»‹ thÃ nh niÃªn.</p>
        
        <h3>9. Dá»‹ch vá»¥ BÃªn thá»© ba</h3>
        <p>Bot káº¿t ná»‘i vá»›i:</p>
        <ul>
            <li><strong>MetaTrader 5:</strong> Äá»ƒ thá»±c hiá»‡n giao dá»‹ch (theo chÃ­nh sÃ¡ch cá»§a sÃ n)</li>
            <li><strong>API Lá»‹ch Kinh táº¿:</strong> Äá»ƒ láº¥y tin tá»©c (khÃ´ng chia sáº» dá»¯ liá»‡u cÃ¡ nhÃ¢n)</li>
        </ul>
        
        <h3>10. Cáº­p nháº­t ChÃ­nh sÃ¡ch</h3>
        <p>ChÃºng tÃ´i cÃ³ thá»ƒ cáº­p nháº­t ChÃ­nh sÃ¡ch Báº£o máº­t Ä‘á»‹nh ká»³. ChÃºng tÃ´i sáº½ thÃ´ng bÃ¡o cÃ¡c thay Ä‘á»•i quan trá»ng qua email hoáº·c thÃ´ng bÃ¡o trong á»©ng dá»¥ng.</p>
        
        <h3>11. LiÃªn há»‡</h3>
        <p>Cho cÃ¡c tháº¯c máº¯c vá» báº£o máº­t:<br>
        <strong>VU HIEN CFDs</strong><br>
        Telegram/Zalo: +84 39 65 60 888<br>
        Email: vuhien2444cfds@gmail.com</p>
        """


# Simple console-based trading bot interface
def simple_console_app():
    """Simple console interface for trading bot"""
    print("ðŸ¤– Trading Bot - Console Interface")
    print("=" * 50)
    
    # Show module availability
    print("ðŸ“Š Module Status:")
    print(f"   â€¢ Data Fetcher: {'âœ…' if DATA_FETCHER_AVAILABLE else 'âŒ'}")
    print(f"   â€¢ Indicator Exporter: {'âœ…' if INDICATOR_EXPORTER_AVAILABLE else 'âŒ'}")
    print(f"   â€¢ Pattern Detector: {'âœ…' if PATTERN_DETECTOR_AVAILABLE else 'âŒ'}")
    print(f"   â€¢ News Scraper: {'âœ…' if NEWS_SCRAPER_AVAILABLE else 'âŒ'}")
    print(f"   â€¢ Auto Trading: {'âœ…' if AUTO_TRADING_AVAILABLE else 'âŒ'}")
    print()
    
    while True:
        print("ðŸ”§ Available Options:")
        print("1. Fetch market data")
        print("2. Calculate indicators")
        print("3. Detect patterns")
        print("4. Show data summary")
        print("5. Test auto trading manager")
        print("6. Exit")
        print()
        
        try:
            choice = input("Select option (1-6): ").strip()
            
            if choice == "1":
                print("\nðŸ“¥ Fetching market data...")
                if DATA_FETCHER_AVAILABLE:
                    try:
                        result = fetch_and_save_candles("XAUUSD", "M15", 500, "data")
                        if result:
                            print("âœ… Data fetched successfully!")
                        else:
                            print("âŒ Data fetching failed")
                    except Exception as e:
                        print(f"âŒ Error: {e}")
                else:
                    print("âŒ Data fetcher not available")
            
            elif choice == "2":
                print("\nðŸ“Š Calculating indicators...")
                if INDICATOR_EXPORTER_AVAILABLE:
                    try:
                        stats = calculate_and_save_all(user_id="console_user")
                        if stats and stats.get("success", 0) > 0:
                            print(f"âœ… Calculated indicators for {stats['success']} symbols")
                        else:
                            print("âŒ Indicator calculation failed")
                    except Exception as e:
                        print(f"âŒ Error: {e}")
                else:
                    print("âŒ Indicator exporter not available")
            
            elif choice == "3":
                print("\nðŸ” Detecting patterns...")
                if PATTERN_DETECTOR_AVAILABLE:
                    try:
                        patterns = analyze_patterns("XAUUSD", "M15")
                        if patterns:
                            print(f"âœ… Found {len(patterns)} patterns")
                            for pattern in patterns[:3]:  # Show first 3
                                print(f"   â€¢ {pattern.get('type', 'unknown')} pattern")
                        else:
                            print("âŒ No patterns found")
                    except Exception as e:
                        print(f"âŒ Error: {e}")
                else:
                    print("âŒ Pattern detector not available")
            
            elif choice == "4":
                print("\nðŸ“‹ Data Summary:")
                directories = ["data", "indicator_output", "pattern_signals", "analysis_output"]
                for directory in directories:
                    if os.path.exists(directory):
                        files = [f for f in os.listdir(directory) if f.endswith('.json')]
                        print(f"   {directory}: {len(files)} files")
                    else:
                        print(f"   {directory}: Not found")
            
            elif choice == "5":
                print("\nðŸš€ Testing Auto Trading Manager...")
                if AUTO_TRADING_AVAILABLE:
                    try:
                        manager = AutoTradingManager(symbol="XAUUSD", timeframe="M15")
                        status = manager.get_status()
                        print("ðŸ“Š Manager Status:")
                        for key, value in status.items():
                            print(f"   {key}: {value}")
                        print("âœ… Auto trading manager test completed")
                    except Exception as e:
                        print(f"âŒ Error: {e}")
                else:
                    print("âŒ Auto trading manager not available")
            
            elif choice == "6":
                print("ðŸ‘‹ Goodbye!")
                break
            
            else:
                print("âŒ Invalid option")
                
        except KeyboardInterrupt:
            print("\nðŸ‘‹ Goodbye!")
            break
        except Exception as e:
            print(f"âŒ Error: {e}")
        
        print("\n" + "-" * 30 + "\n")

# Original main function (backup)
def main_original():
    """Original main function"""
    import sys
    import traceback
    from datetime import datetime
    try:
        print("Trading Bot Starting...")
        
        # Load environment if available
        if DOTENV_AVAILABLE:
            load_dotenv()
        
        # ðŸ”„ Load user config and set language BEFORE creating any UI
        try:
            user_cfg = load_user_config(apply_lang=True)
            print(f"âœ… User config loaded, language: {AppState.language()}")
        except Exception as e:
            print(f"âš ï¸ Could not load user config: {e}")
        
        # ðŸ”„ Start auto-save trading history (save on start + every 60 minutes)
        try:
            from trading_history_manager import start_auto_save, is_auto_save_running
            if not is_auto_save_running():
                start_auto_save(interval_minutes=60, save_on_start=True)
                print("âœ… Trading history auto-save started (every 60 minutes)")
        except Exception as e:
            print(f"âš ï¸ Could not start trading history auto-save: {e}")
        
        if GUI_AVAILABLE:
            print("Starting GUI mode...")
            try:
                print("Creating QApplication...")
                app = QApplication(sys.argv)
                
                # Simple UTF-8 setup without complex codec manipulation
                import locale
                try:
                    locale.setlocale(locale.LC_ALL, 'en_US.UTF-8')
                    print("âœ… UTF-8 locale set successfully")
                except:
                    try:
                        locale.setlocale(locale.LC_ALL, 'C.UTF-8') 
                        print("âœ… C.UTF-8 locale set as fallback")
                    except:
                        print("âš ï¸ Using system default locale")
                
                # Set default font with Unicode support for Vietnamese text
                try:
                    # Try Arial Unicode MS first (good Unicode support)
                    unicode_font = QFont("Arial Unicode MS", 10)
                    if not unicode_font.exactMatch():
                        # Fallback to Arial which has decent Vietnamese support
                        unicode_font = QFont("Arial", 10)
                        if not unicode_font.exactMatch():
                            # Last fallback to Segoe UI (default Windows font)
                            unicode_font = QFont("Segoe UI", 10)
                    
                    app.setFont(unicode_font)
                    print(f"âœ… Font set to {unicode_font.family()} 10pt with Unicode support")
                except Exception as e:
                    print(f"âš ï¸ Font setting error: {e}, using system default")
                
                print("Creating main window...")
                # Create main window with tabs
                class MainWindow(QWidget):
                    def update_ui_language(self):
                        """Update UI language for all tabs and widgets"""
                        try:
                            # Update tab titles
                            if hasattr(self, 'tabWidget'):
                                tab_titles = [
                                    ("ðŸ¦ MT5 Account", "ðŸ¦ TÃ i khoáº£n MT5"),
                                    ("ðŸ’¹ Market Data", "ðŸ’¹ Dá»¯ liá»‡u thá»‹ trÆ°á»ng"),
                                    ("ðŸ“ˆ Trend Analysis", "ðŸ“ˆ PhÃ¢n tÃ­ch xu hÆ°á»›ng"),
                                    ("âš™ï¸ Technical Indicators", "âš™ï¸ Chá»‰ bÃ¡o ká»¹ thuáº­t"),
                                    ("ðŸ•¯ï¸ Candlestick Patterns", "ðŸ•¯ï¸ MÃ´ hÃ¬nh náº¿n"),
                                    ("ðŸ“Š Price Patterns", "ðŸ“Š MÃ´ hÃ¬nh giÃ¡"),
                                    ("ðŸ“° Economic News", "ðŸ“° Tin tá»©c kinh táº¿"),
                                    ("ðŸ›¡ï¸ Risk Management", "ðŸ›¡ï¸ Quáº£n lÃ½ rá»§i ro"),
                                    ("ðŸ“¡ Signal", "ðŸ“¡ TÃ­n hiá»‡u"),
                                    ("ðŸ¤– Auto Trading", "ðŸ¤– Giao dá»‹ch tá»± Ä‘á»™ng"),
                                ]
                                for i, (en_title, vi_title) in enumerate(tab_titles):
                                    translated = I18N.t(en_title, vi_title)
                                    self.tabWidget.setTabText(i, translated)
                                print(f"âœ… Tab titles updated to language: {AppState.language()}")
                            
                            # Update menu if exists
                            if hasattr(self, 'main_menu'):
                                for action in self.main_menu.actions():
                                    if action.text() in ("Language", "NgÃ´n ngá»¯"):
                                        action.setText(I18N.t("Language", "NgÃ´n ngá»¯"))
                            
                            # Call retranslate_ui on all tabs if they have the method
                            for tab_name, tab in getattr(self, 'all_tabs', {}).items():
                                if hasattr(tab, 'retranslate_ui') and callable(getattr(tab, 'retranslate_ui')):
                                    try:
                                        tab.retranslate_ui()
                                        print(f"âœ… Updated {tab_name}")
                                    except Exception as e:
                                        print(f"âš ï¸ Could not update {tab_name}: {e}")
                                else:
                                    # Tab doesn't have retranslate_ui, log but continue
                                    print(f"â„¹ï¸ {tab_name} doesn't have retranslate_ui method")
                        except Exception as e:
                            print(f"âŒ Error updating UI language: {e}")
                    
                    def closeEvent(self, event):
                        """Enhanced application close event handler with comprehensive cleanup"""
                        try:
                            print("[CLEANUP] ðŸ§¹ Application closing - comprehensive cleanup starting...")
                            
                            # 0. Stop trading history auto-save
                            try:
                                from trading_history_manager import stop_auto_save, save_trading_history
                                stop_auto_save()
                                # Save final history before exit
                                save_trading_history(save_comprehensive=True)
                                print("[CLEANUP] âœ… Trading history auto-save stopped and saved")
                            except Exception as e:
                                print(f"[CLEANUP] âš ï¸ Trading history cleanup error: {e}")
                            
                            # 0.5. Stop notification monitoring first
                            try:
                                from unified_notification_system import get_unified_notification_system
                                notification_system = get_unified_notification_system()
                                if notification_system.monitoring_enabled:
                                    notification_system.stop_monitoring()
                                    print("[CLEANUP] âœ… Notification monitoring stopped")
                            except Exception as e:
                                print(f"[CLEANUP] âš ï¸ Notification cleanup error: {e}")
                            
                            # 1. Stop all timers first
                            try:
                                for tab_name, tab in getattr(self, 'all_tabs', {}).items():
                                    if hasattr(tab, 'update_timer'):
                                        tab.update_timer.stop()
                                    if hasattr(tab, 'mt5_price_timer'):
                                        tab.mt5_price_timer.stop()
                                    if hasattr(tab, 'settings_refresh_timer'):
                                        tab.settings_refresh_timer.stop()
                                print("[CLEANUP] âœ… All timers stopped")
                            except Exception as e:
                                print(f"[CLEANUP] âš ï¸ Timer cleanup error: {e}")
                            
                            # 2. Force stop auto trading with aggressive cleanup
                            if hasattr(self, 'all_tabs') and 'auto_trading_tab' in self.all_tabs:
                                try:
                                    auto_tab = self.all_tabs['auto_trading_tab']
                                    
                                    # Force shutdown any running auto manager
                                    if hasattr(auto_tab, 'auto_manager') and auto_tab.auto_manager:
                                        print("[CLEANUP] Force stopping auto manager...")
                                        try:
                                            # Set shutdown flags immediately
                                            if hasattr(auto_tab.auto_manager, '_shutdown_event'):
                                                auto_tab.auto_manager._shutdown_event.set()
                                            if hasattr(auto_tab.auto_manager, 'is_running'):
                                                auto_tab.auto_manager.is_running = False
                                            
                                            # Try quick stop
                                            import threading
                                            import time
                                            
                                            def quick_stop():
                                                try:
                                                    auto_tab.auto_manager.stop()
                                                except:
                                                    pass
                                            
                                            stop_thread = threading.Thread(target=quick_stop, daemon=True)
                                            stop_thread.start()
                                            stop_thread.join(timeout=2)  # Very short timeout on app close
                                            
                                        except Exception as e:
                                            print(f"[CLEANUP] Exception during force stop: {e}")
                                        finally:
                                            auto_tab.auto_manager = None
                                    
                                    # Also call the tab's stop method
                                    auto_tab.stop_auto()
                                    print("[CLEANUP] Auto trading stopped")
                                    
                                except Exception as e:
                                    print(f"[CLEANUP] Error stopping auto trading: {e}")
                            
                            # Cleanup RunAggregatorWorker thread in SignalTab
                            if hasattr(self, 'all_tabs') and 'signal_tab' in self.all_tabs:
                                try:
                                    signal_tab = self.all_tabs['signal_tab']
                                    if hasattr(signal_tab, 'cleanup_thread'):
                                        signal_tab.cleanup_thread()
                                except Exception as e:
                                    print(f"[CLEANUP] Error stopping signal tab thread: {e}")
                            
                            # 3. Cleanup all other threads (Signal, Pattern, etc.)
                            try:
                                if hasattr(self, 'all_tabs'):
                                    for tab_name, tab in self.all_tabs.items():
                                        # Stop indicator workers
                                        if hasattr(tab, 'stop_all_workers'):
                                            tab.stop_all_workers()
                                        # Stop any individual workers list
                                        if hasattr(tab, 'workers'):
                                            for worker in getattr(tab, 'workers', []):
                                                try:
                                                    if worker.isRunning():
                                                        worker.quit()
                                                        worker.wait(1000)
                                                except:
                                                    pass
                                        # Existing cleanup
                                        if hasattr(tab, 'cleanup_thread'):
                                            tab.cleanup_thread()
                                        if hasattr(tab, 'worker') and hasattr(tab.worker, 'stop'):
                                            tab.worker.stop()
                                        # NewsTab specific cleanup
                                        if hasattr(tab, 'cleanup_resources'):
                                            tab.cleanup_resources()
                                    print("[CLEANUP] âœ… All tab threads cleaned up")
                            except Exception as e:
                                print(f"[CLEANUP] âš ï¸ Tab thread cleanup error: {e}")
                            
                            # 4. Use graceful shutdown utility for any remaining threads
                            try:
                                if hasattr(self, 'all_tabs'):
                                    graceful_shutdown_threads(list(self.all_tabs.values()))
                            except Exception as e:
                                print(f"[CLEANUP] âš ï¸ Graceful shutdown error: {e}")
                            
                            # 5. Final emergency cleanup
                            try:
                                emergency_cleanup()
                            except Exception as e:
                                print(f"[CLEANUP] âš ï¸ Emergency cleanup error: {e}")
                            
                            print("[CLEANUP] âœ… Application cleanup completed successfully")
                        
                        except Exception as e:
                            print(f"[CLEANUP] Error during application cleanup: {e}")
                            import traceback
                            print(f"[CLEANUP] Traceback: {traceback.format_exc()}")
                        finally:
                            # Always accept the close event
                            event.accept()
                
                main_window = MainWindow()
                main_window.setWindowTitle("ChatGPT AI BOT 4.3.2")
                main_window.setGeometry(100, 100, 1200, 800)

                # Load user config early to restore language preference
                try:
                    _cfg = load_user_config(apply_lang=True)
                    # (load_user_config already sets AppState._lang if key exists)
                except Exception as _e:
                    print(f"âš ï¸ Could not load user config early: {_e}")
                
                # Set robot icon for the application (optional)
                if os.path.exists("robot_icon.png"):
                    app.setWindowIcon(QIcon("robot_icon.png"))
                    main_window.setWindowIcon(QIcon("robot_icon.png"))
                    print("âœ… Robot icon set successfully")
                # Note: Robot icon is optional - app works fine without it
                
                    print("Creating tab widget...")
                # Create a top bar with app title and hamburger menu
                top_bar_widget = QWidget()
                top_bar_layout = QHBoxLayout(top_bar_widget)
                # Minimal margins so the button sits tight in the top-right area
                top_bar_layout.setContentsMargins(6, 4, 6, 0)
                app_title = QLabel("ChatGPT AI BOT 4.3.2")
                app_title.setFont(QFont("Segoe UI", 14, QFont.Bold))
                menu_btn = QToolButton()
                menu_btn.setText("â‰¡")
                menu_btn.setToolButtonStyle(Qt.ToolButtonTextOnly)
                menu_btn.setFixedWidth(28)
                menu_btn.setToolTip("Menu")
                menu_btn.setCursor(Qt.PointingHandCursor)
                menu_btn.setStyleSheet(
                    "QToolButton{font-size:18px;padding:2px 6px;border:1px solid #ddd;border-radius:4px;background:#fafafa;}"
                    "QToolButton:hover{background:#f0f0f0;}"
                )
                # Build hamburger menu
                main_menu = QMenu(main_window)
                
                # Biáº¿n lÆ°u thÃ´ng tin user Ä‘Äƒng nháº­p
                main_window.logged_in_user = None  # Sáº½ Ä‘Æ°á»£c set sau khi login
                main_window.main_menu = main_menu  # LÆ°u reference
                main_window.menu_btn = menu_btn  # LÆ°u reference
                
                # Actions cho menu
                act_strategy = QAction("Trading Strategy", main_window)
                lang_menu = QMenu("Language", main_window)
                lang_group = QActionGroup(main_window)
                lang_en = QAction("English", main_window, checkable=True)
                lang_vi = QAction("Vietnamese", main_window, checkable=True)
                lang_group.addAction(lang_en); lang_group.addAction(lang_vi)
                # default language is EN
                if AppState.language() == 'vi':
                    lang_vi.setChecked(True)
                else:
                    lang_en.setChecked(True)
                lang_menu.addAction(lang_en); lang_menu.addAction(lang_vi)
                act_support = QAction(I18N.t("ðŸ“ž Support", "ðŸ“ž Há»— trá»£"), main_window)
                act_pricing = QAction(I18N.t("ðŸ’° Pricing", "ðŸ’° Báº£ng GiÃ¡"), main_window)
                
                # Function Ä‘á»ƒ má»Ÿ support dialog
                def open_support_dialog():
                    """Má»Ÿ dialog thÃ´ng tin há»— trá»£"""
                    try:
                        support_dialog = QDialog(main_window)
                        support_dialog.setWindowTitle(I18N.t("Support Information", "ThÃ´ng tin Há»— trá»£"))
                        support_dialog.setMinimumSize(600, 580)
                        support_dialog.setStyleSheet("""
                            QDialog {
                                background-color: #f5f5f5;
                            }
                            QLabel {
                                color: #333;
                            }
                            QPushButton {
                                background-color: #2196F3;
                                color: white;
                                border: none;
                                padding: 12px 24px;
                                border-radius: 6px;
                                font-weight: bold;
                                font-size: 15px;
                            }
                            QPushButton:hover {
                                background-color: #1976D2;
                            }
                        """)
                        
                        layout = QVBoxLayout(support_dialog)
                        layout.setSpacing(20)
                        layout.setContentsMargins(35, 35, 35, 35)
                        
                        # Header
                        header_label = QLabel(I18N.t("ðŸ“ž Contact Support", "ðŸ“ž LiÃªn há»‡ Há»— trá»£"))
                        header_label.setStyleSheet("font-size: 26px; font-weight: bold; color: #2196F3; margin-bottom: 15px;")
                        header_label.setAlignment(Qt.AlignCenter)
                        layout.addWidget(header_label)
                        
                        # Separator
                        sep = QFrame()
                        sep.setFrameShape(QFrame.HLine)
                        sep.setFixedHeight(2)
                        sep.setStyleSheet("background-color: #ddd;")
                        layout.addWidget(sep)
                        
                        # Support info content
                        info_widget = QWidget()
                        info_layout = QVBoxLayout(info_widget)
                        info_layout.setSpacing(18)
                        info_layout.setContentsMargins(10, 10, 10, 10)
                        
                        support_info = [
                            (I18N.t("ðŸ‘¤ Admin:", "ðŸ‘¤ Quáº£n trá»‹:"), "Hiáº¿n VÅ© CFDs"),
                            (I18N.t("ðŸ“± Phone/Zalo:", "ðŸ“± SÄT/Zalo:"), "0396560888"),
                            (I18N.t("âœˆï¸ Telegram:", "âœˆï¸ Telegram:"), "@vuvanhien1996"),
                            (I18N.t("ðŸ“§ Email:", "ðŸ“§ Email:"), "vuhien2444cfds@gmail.com"),
                        ]
                        
                        for label_text, value in support_info:
                            row = QHBoxLayout()
                            row.setSpacing(15)
                            label = QLabel(label_text)
                            label.setStyleSheet("font-size: 17px; font-weight: bold; min-width: 150px;")
                            label.setMinimumHeight(30)
                            value_label = QLabel(value)
                            value_label.setStyleSheet("font-size: 17px; color: #444;")
                            value_label.setMinimumHeight(30)
                            value_label.setTextInteractionFlags(Qt.TextSelectableByMouse)
                            row.addWidget(label)
                            row.addWidget(value_label)
                            row.addStretch()
                            info_layout.addLayout(row)
                        
                        layout.addWidget(info_widget)
                        
                        # Separator
                        sep2 = QFrame()
                        sep2.setFrameShape(QFrame.HLine)
                        sep2.setFixedHeight(2)
                        sep2.setStyleSheet("background-color: #ddd;")
                        layout.addWidget(sep2)
                        
                        # Group links
                        links_label = QLabel(I18N.t("ðŸ”— Community Groups", "ðŸ”— NhÃ³m Cá»™ng Ä‘á»“ng"))
                        links_label.setStyleSheet("font-size: 20px; font-weight: bold; color: #2196F3; margin-top: 5px;")
                        layout.addWidget(links_label)
                        
                        # Zalo Group button
                        zalo_btn = QPushButton(I18N.t("ðŸ’¬ Join Zalo Group", "ðŸ’¬ Tham gia NhÃ³m Zalo"))
                        zalo_btn.setCursor(Qt.PointingHandCursor)
                        zalo_btn.setMinimumHeight(50)
                        zalo_btn.setStyleSheet("""
                            QPushButton {
                                background-color: #0068FF;
                                color: white;
                                border: none;
                                padding: 14px 28px;
                                border-radius: 8px;
                                font-weight: bold;
                                font-size: 17px;
                            }
                            QPushButton:hover {
                                background-color: #0052CC;
                            }
                        """)
                        zalo_btn.clicked.connect(lambda: QDesktopServices.openUrl(QUrl("https://zalo.me/g/qdpqda161")))
                        layout.addWidget(zalo_btn)
                        
                        # Telegram Channel button
                        tele_btn = QPushButton(I18N.t("âœˆï¸ Join Telegram Channel", "âœˆï¸ Tham gia KÃªnh Telegram"))
                        tele_btn.setCursor(Qt.PointingHandCursor)
                        tele_btn.setMinimumHeight(50)
                        tele_btn.setStyleSheet("""
                            QPushButton {
                                background-color: #0088cc;
                                color: white;
                                border: none;
                                padding: 14px 28px;
                                border-radius: 8px;
                                font-weight: bold;
                                font-size: 17px;
                            }
                            QPushButton:hover {
                                background-color: #006699;
                            }
                        """)
                        tele_btn.clicked.connect(lambda: QDesktopServices.openUrl(QUrl("https://t.me/+9zaJXYPyvnQ1ZGE9")))
                        layout.addWidget(tele_btn)
                        
                        layout.addStretch()
                        
                        # Close button
                        close_btn = QPushButton(I18N.t("Close", "ÄÃ³ng"))
                        close_btn.setMinimumHeight(45)
                        close_btn.clicked.connect(support_dialog.accept)
                        layout.addWidget(close_btn)
                        
                        support_dialog.exec_()
                    except Exception as e:
                        print(f"[Support] Error opening support dialog: {e}")
                
                act_support.triggered.connect(open_support_dialog)
                
                # Function Ä‘á»ƒ má»Ÿ pricing dialog
                def open_pricing_from_menu():
                    """Má»Ÿ dialog báº£ng giÃ¡"""
                    try:
                        pricing_dialog = PricingDialog(main_window)
                        pricing_dialog.exec_()
                    except Exception as e:
                        print(f"[Pricing] Error opening pricing dialog: {e}")
                
                act_pricing.triggered.connect(open_pricing_from_menu)
                
                # ============ AUTO-UPDATE ACTION ============
                act_check_updates = QAction(I18N.t("ðŸ”„ Check for Updates", "ðŸ”„ Kiá»ƒm tra cáº­p nháº­t"), main_window)
                act_check_updates.setToolTip(I18N.t("Check for new version and update", "Kiá»ƒm tra phiÃªn báº£n má»›i vÃ  cáº­p nháº­t"))
                
                def check_updates_from_menu():
                    """Check for updates from GitHub releases"""
                    try:
                        # Show checking status
                        QMessageBox.information(main_window,
                            I18N.t("Checking Updates", "Äang kiá»ƒm tra cáº­p nháº­t"),
                            I18N.t("Checking for new version...", "Äang kiá»ƒm tra phiÃªn báº£n má»›i..."))
                        
                        # Import update manager here (lazy load)
                        from update_manager import UpdateManager
                        
                        update_manager = UpdateManager()
                        has_update = update_manager.check_updates()
                        
                        if has_update:
                            # Show update dialog
                            reply = QMessageBox.information(main_window,
                                I18N.t("Update Available", "CÃ³ cáº­p nháº­t má»›i"),
                                I18N.t(
                                    f"New version {update_manager.latest_version['version']} is available!\n\n"
                                    f"Release notes:\n{update_manager.latest_version.get('notes', 'N/A')}\n\n"
                                    f"File size: {update_manager.latest_version.get('size_mb', 'Unknown')} MB\n\n"
                                    f"Do you want to download and install it now?",
                                    f"PhiÃªn báº£n {update_manager.latest_version['version']} cÃ³ sáºµn!\n\n"
                                    f"Ghi chÃº phÃ¡t hÃ nh:\n{update_manager.latest_version.get('notes', 'N/A')}\n\n"
                                    f"KÃ­ch thÆ°á»›c file: {update_manager.latest_version.get('size_mb', 'Unknown')} MB\n\n"
                                    f"Báº¡n cÃ³ muá»‘n táº£i vÃ  cÃ i Ä‘áº·t ngay?"
                                ),
                                QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)
                            
                            if reply == QMessageBox.Yes:
                                # Show progress dialog for download
                                from update_manager import UpdateProgressDialog
                                progress_dialog = UpdateProgressDialog(update_manager, update_manager.latest_version, main_window)
                                progress_dialog.exec_()
                        else:
                            # Already on latest version
                            QMessageBox.information(main_window,
                                I18N.t("Already Updated", "ÄÃ£ lÃ  phiÃªn báº£n má»›i nháº¥t"),
                                I18N.t(
                                    f"You are already running the latest version (v{update_manager.CURRENT_VERSION})",
                                    f"Báº¡n Ä‘ang cháº¡y phiÃªn báº£n má»›i nháº¥t (v{update_manager.CURRENT_VERSION})"
                                ))
                    
                    except ModuleNotFoundError:
                        QMessageBox.warning(main_window,
                            I18N.t("Update Module Not Found", "KhÃ´ng tÃ¬m tháº¥y module cáº­p nháº­t"),
                            I18N.t(
                                "The update manager module is not available yet.\n\nPlease check GitHub releases manually.",
                                "Module cáº­p nháº­t chÆ°a sáºµn sÃ ng.\n\nVui lÃ²ng kiá»ƒm tra phiÃªn báº£n trÃªn GitHub."
                            ))
                    
                    except Exception as e:
                        print(f"âŒ Update check error: {e}")
                        import traceback
                        traceback.print_exc()
                        QMessageBox.critical(main_window,
                            I18N.t("Update Error", "Lá»—i cáº­p nháº­t"),
                            I18N.t(
                                f"An error occurred while checking for updates:\n\n{str(e)}",
                                f"Lá»—i khi kiá»ƒm tra cáº­p nháº­t:\n\n{str(e)}"
                            ))
                
                act_check_updates.triggered.connect(check_updates_from_menu)
                
                # Function Ä‘á»ƒ má»Ÿ profile dialog
                def open_profile_dialog():
                    """Má»Ÿ dialog chá»‰nh sá»­a profile"""
                    try:
                        username = main_window.logged_in_user
                        if username:
                            profile_dialog = AccountProfileDialog(username, main_window)
                            profile_dialog.exec_()
                    except Exception as e:
                        print(f"[Profile] Error opening profile dialog: {e}")
                
                # Function Ä‘á»ƒ update menu dá»±a trÃªn tráº¡ng thÃ¡i Ä‘Äƒng nháº­p
                def update_menu_for_user(username=None):
                    main_menu.clear()
                    if username:
                        # ÄÃ£ Ä‘Äƒng nháº­p - hiá»ƒn thá»‹ tÃªn user (cÃ³ thá»ƒ click Ä‘á»ƒ má»Ÿ profile) vÃ  logout
                        main_window.logged_in_user = username
                        
                        # User action - click Ä‘á»ƒ má»Ÿ profile
                        user_action = QAction(f"ðŸ‘¤ {username}", main_window)
                        user_action.setToolTip(I18N.t("Click to view/edit profile", "Nháº¥n Ä‘á»ƒ xem/sá»­a thÃ´ng tin"))
                        user_action.triggered.connect(open_profile_dialog)
                        main_menu.addAction(user_action)
                        main_menu.addSeparator()
                        
                        act_logout = QAction(I18N.t("ðŸšª Logout", "ðŸšª ÄÄƒng xuáº¥t"), main_window)
                        act_logout.triggered.connect(lambda: do_logout())
                        main_menu.addAction(act_logout)
                        main_menu.addSeparator()
                    else:
                        # ChÆ°a Ä‘Äƒng nháº­p - hiá»ƒn thá»‹ login/register (trÆ°á»ng há»£p dá»± phÃ²ng)
                        main_window.logged_in_user = None
                        act_login = QAction(I18N.t("Login", "ÄÄƒng nháº­p"), main_window)
                        act_register = QAction(I18N.t("Register", "ÄÄƒng kÃ½"), main_window)
                        main_menu.addAction(act_login)
                        main_menu.addAction(act_register)
                        main_menu.addSeparator()
                    
                    main_menu.addAction(act_pricing)
                    main_menu.addAction(act_strategy)
                    # ============ ADD CHECK UPDATES TO MENU ============
                    main_menu.addAction(act_check_updates)
                    main_menu.addMenu(lang_menu)
                    main_menu.addSeparator()
                    main_menu.addAction(act_support)
                
                def do_logout():
                    """Xá»­ lÃ½ Ä‘Äƒng xuáº¥t"""
                    reply = QMessageBox.question(main_window,
                        I18N.t("Confirm Logout", "XÃ¡c nháº­n ÄÄƒng xuáº¥t"),
                        I18N.t("Are you sure you want to logout?", "Báº¡n cÃ³ cháº¯c cháº¯n muá»‘n Ä‘Äƒng xuáº¥t?"),
                        QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
                    
                    if reply == QMessageBox.Yes:
                        try:
                            # XÃ³a license cache
                            from license_client import get_license_client
                            license_client = get_license_client(server_url=LICENSE_SERVER_URL)
                            license_client.clear_cache()
                            print("ðŸšª Logged out, cache cleared")
                        except Exception as e:
                            print(f"âš ï¸ Error clearing cache: {e}")
                        
                        QMessageBox.information(main_window,
                            I18N.t("Logged Out", "ÄÃ£ Ä‘Äƒng xuáº¥t"),
                            I18N.t("You have been logged out. The app will now close.", 
                                   "Báº¡n Ä‘Ã£ Ä‘Äƒng xuáº¥t. á»¨ng dá»¥ng sáº½ Ä‘Ã³ng láº¡i."))
                        main_window.close()
                        sys.exit(0)
                
                main_window.update_menu_for_user = update_menu_for_user
                main_window.do_logout = do_logout
                
                # Khá»Ÿi táº¡o menu ban Ä‘áº§u (chÆ°a Ä‘Äƒng nháº­p)
                update_menu_for_user(None)
                
                menu_btn.setMenu(main_menu)
                menu_btn.setPopupMode(QToolButton.InstantPopup)
                # Place menu button to the LEFT of the title
                top_bar_layout.addWidget(menu_btn)
                top_bar_layout.addSpacing(8)
                top_bar_layout.addWidget(app_title)
                top_bar_layout.addStretch(1)

                # Create tab widget with tabs at bottom
                tab_widget = QTabWidget()
                tab_widget.setTabPosition(QTabWidget.South)  # Set tabs at bottom
                tab_widget.setDocumentMode(True)  # Remove frame for cleaner look
                
                # Configure tab bar to expand tabs evenly
                tab_bar = tab_widget.tabBar()
                tab_bar.setExpanding(True)  # Tabs expand to fill width
                tab_bar.setUsesScrollButtons(False)  # Disable scroll buttons
                tab_bar.setElideMode(Qt.ElideNone)  # Don't truncate text
                
                # Style tabs to expand evenly across the width
                tab_widget.setStyleSheet("""
                    QTabWidget::pane {
                        border: none;
                        background: #f5f5f5;
                    }
                    QTabWidget::tab-bar {
                        alignment: center;
                    }
                    QTabBar {
                        background: transparent;
                    }
                    QTabBar::tab {
                        background: #e8e8e8;
                        color: #333;
                        padding: 10px 5px;
                        margin: 0px 1px;
                        border: 1px solid #ccc;
                        border-top: none;
                        border-radius: 0px 0px 4px 4px;
                        font-size: 12px;
                        font-weight: bold;
                    }
                    QTabBar::tab:selected {
                        background: #2196F3;
                        color: white;
                        border-color: #1976D2;
                    }
                    QTabBar::tab:hover:!selected {
                        background: #d5d5d5;
                    }
                """)
            
                print("Creating tabs...")
                # Create Account tab first
                account_tab = AccountTab()
                print("âœ… AccountTab created")
            
                # Create other tabs with account_tab reference
                market_tab = MarketTab(account_tab)
                print("âœ… MarketTab created")
            
                trend_tab = TrendTab(market_tab)
                print("âœ… TrendTab created")
            
                indicator_tab = IndicatorTab(market_tab)
                print("âœ… IndicatorTab created")
            
                # Set indicator tab reference in market tab
                market_tab.set_indicator_tab(indicator_tab)
                print("âœ… IndicatorTab reference set in MarketTab")
            
                pattern_tab = PatternTab(market_tab, indicator_tab)
                print("âœ… PatternTab created")
            
                price_pattern_tab = PricePatternTab(market_tab)
                print("âœ… PricePatternTab created")
            
                news_tab = NewsTab()
                print("âœ… NewsTab created")
            
                # Create Risk Management tab with market_tab reference
                print("ðŸ”„ Creating RiskManagementTab...")
                try:
                    risk_tab = RiskManagementTab(market_tab)
                    print("âœ… RiskManagementTab created")
                except Exception as e:
                    print(f"âŒ Error creating RiskManagementTab: {e}")
                    import traceback
                    traceback.print_exc()
                    # Create a dummy tab to continue
                    risk_tab = QWidget()
                    print("âš ï¸ Using dummy RiskTab to continue")
            
                # Create Signal tab (aggregator UI)
                signal_tab = SignalTab(indicator_tab=indicator_tab, market_tab=market_tab)
                print("âœ… SignalTab created")

                # Create Auto Trading tab with references (including signal_tab for AI model selection)
                auto_trading_tab = AutoTradingTab(news_tab, risk_tab, signal_tab)
                print("[SUCCESS] AutoTradingTab created")
            
                # Store tab references in main_window for graceful shutdown
                main_window.all_tabs = {
                    'account_tab': account_tab,
                    'market_tab': market_tab,
                    'trend_tab': trend_tab,
                    'indicator_tab': indicator_tab,
                    'pattern_tab': pattern_tab,
                    'price_pattern_tab': price_pattern_tab,
                    'news_tab': news_tab,
                    'risk_tab': risk_tab,
                    'signal_tab': signal_tab,
                    'auto_trading_tab': auto_trading_tab
                }
                
                # ðŸ”§ FIX: Add direct tab references for Strategy Manager compatibility
                main_window.market_tab = market_tab
                main_window.risk_tab = risk_tab  # Risk management tab
                main_window.indicator_tab = indicator_tab  # Indicator tab  
                main_window.news_tab = news_tab  # News tab
                main_window.account_tab = account_tab  # Account tab
                main_window.trend_tab = trend_tab  # Trend analysis tab
                main_window.pattern_tab = pattern_tab  # Candlestick pattern tab
                main_window.price_pattern_tab = price_pattern_tab  # Price pattern tab
                main_window.signal_tab = signal_tab  # Signal tab
                
                # Store tabWidget reference for auto trading checkbox detection
                main_window.tabWidget = tab_widget
                print("âœ… Tab references stored for graceful shutdown")
            
                print("Adding tabs to widget...")
                # Add tabs in the requested order - Account tab first
                # Add tabs with immediate translation instead of hardcoded English
                tab_widget.addTab(account_tab, I18N.t("ðŸ¦ MT5 Account", "ðŸ¦ TÃ i khoáº£n MT5"))
                tab_widget.addTab(market_tab, I18N.t("ðŸ’¹ Market Data", "ðŸ’¹ Dá»¯ liá»‡u thá»‹ trÆ°á»ng"))
                tab_widget.addTab(trend_tab, I18N.t("ðŸ“ˆ Trend Analysis", "ðŸ“ˆ PhÃ¢n tÃ­ch xu hÆ°á»›ng"))
                tab_widget.addTab(indicator_tab, I18N.t("âš™ï¸ Technical Indicators", "âš™ï¸ Chá»‰ bÃ¡o ká»¹ thuáº­t"))
                tab_widget.addTab(pattern_tab, I18N.t("ðŸ•¯ï¸ Candlestick Patterns", "ðŸ•¯ï¸ MÃ´ hÃ¬nh náº¿n"))
                tab_widget.addTab(price_pattern_tab, I18N.t("ðŸ“Š Price Patterns", "ðŸ“Š MÃ´ hÃ¬nh giÃ¡"))
                tab_widget.addTab(news_tab, I18N.t("ðŸ“° Economic News", "ðŸ“° Tin tá»©c kinh táº¿"))
                tab_widget.addTab(risk_tab, I18N.t("ðŸ›¡ï¸ Risk Management", "ðŸ›¡ï¸ Quáº£n lÃ½ rá»§i ro"))
                tab_widget.addTab(signal_tab, I18N.t("ðŸ“¡ Signal", "ðŸ“¡ TÃ­n hiá»‡u"))
                tab_widget.addTab(auto_trading_tab, I18N.t("ðŸ¤– Auto Trading", "ðŸ¤– Giao dá»‹ch tá»± Ä‘á»™ng"))
                
                # Debug log tab titles to file instead of console (avoid Unicode issues)
                try:
                    with open("debug_tab_titles.txt", "w", encoding="utf-8") as f:
                        f.write("=== INITIAL TAB TITLES (English) ===\n")
                        for i in range(tab_widget.count()):
                            f.write(f"Tab {i}: '{tab_widget.tabText(i)}'\n")
                        
                        current_lang = AppState.language()
                        f.write(f"\n=== CURRENT LANGUAGE: {current_lang} ===\n")
                        
                        # Apply initial language translation to tab titles
                        tab_widget.setTabText(0, I18N.t("ðŸ¦ MT5 Account", "ðŸ¦ TÃ i khoáº£n MT5"))
                        tab_widget.setTabText(1, I18N.t("ðŸ’¹ Market Data", "ðŸ’¹ Dá»¯ liá»‡u thá»‹ trÆ°á»ng"))
                        tab_widget.setTabText(2, I18N.t("ðŸ“ˆ Trend Analysis", "ðŸ“ˆ PhÃ¢n tÃ­ch xu hÆ°á»›ng"))
                        tab_widget.setTabText(3, I18N.t("âš™ï¸ Technical Indicators", "âš™ï¸ Chá»‰ bÃ¡o ká»¹ thuáº­t"))
                        tab_widget.setTabText(4, I18N.t("ðŸ•¯ï¸ Candlestick Patterns", "ðŸ•¯ï¸ MÃ´ hÃ¬nh náº¿n"))
                        tab_widget.setTabText(5, I18N.t("ðŸ“Š Price Patterns", "ðŸ“Š MÃ´ hÃ¬nh giÃ¡"))
                        tab_widget.setTabText(6, I18N.t("ðŸ“° Economic News", "ðŸ“° Tin tá»©c kinh táº¿"))
                        tab_widget.setTabText(7, I18N.t("ðŸ›¡ï¸ Risk Management", "ðŸ›¡ï¸ Quáº£n lÃ½ rá»§i ro"))
                        tab_widget.setTabText(8, I18N.t("ðŸ“¡ Signal", "ðŸ“¡ TÃ­n hiá»‡u"))
                        tab_widget.setTabText(9, I18N.t("ðŸ¤– Auto Trading", "ðŸ¤– Giao dá»‹ch tá»± Ä‘á»™ng"))
                        
                        f.write("\n=== TAB TITLES AFTER RETRANSLATION ===\n")
                        for i in range(tab_widget.count()):
                            f.write(f"Tab {i}: '{tab_widget.tabText(i)}'\n")
                        
                        print(f"DEBUG: Tab titles logged to debug_tab_titles.txt")
                        
                    # Also store tab_widget reference for later debugging
                    main_window.debug_tab_widget = tab_widget
                except Exception as e:
                    print(f"[DEBUG] Error during initial tab translation: {e}")
            
                # Set main window reference for auto trading after all tabs are added
                auto_trading_tab.set_main_window_reference(main_window)
                print("[DEBUG] Main window reference set for AutoTradingTab")
            
                # Register main window globally for unified auto trading system discovery
                try:
                    from unified_auto_trading_system import UnifiedAutoTradingSystem as AutoTradingManager
                    # Store main window globally for discovery
                    if not hasattr(AutoTradingManager, '_registered_windows'):
                        AutoTradingManager._registered_windows = []
                    AutoTradingManager._registered_windows.append(main_window)
                    print("[DEBUG] Main window registered globally for unified auto trading system")
                except Exception as e:
                    print(f"[WARNING] Could not register window globally: {e}")
            
                print("Setting up layout...")
                # Main layout
                print("Creating QVBoxLayout...")
                main_layout = QVBoxLayout()
                print("Adding top_bar_widget...")
                main_layout.addWidget(top_bar_widget)
                print("Adding tab_widget...")
                main_layout.addWidget(tab_widget)
                print("Setting layout to main_window...")
                main_window.setLayout(main_layout)

                # ========== YÃŠU Cáº¦U ÄÄ‚NG NHáº¬P TRÆ¯á»šC KHI Má»ž APP ==========
                print("ðŸ” Checking login status...")
                
                # LuÃ´n hiá»ƒn thá»‹ login dialog - user pháº£i click Start Ä‘á»ƒ vÃ o app
                # Náº¿u Ä‘Ã£ cÃ³ cached session, sáº½ tá»± Ä‘á»™ng hiá»ƒn thá»‹ logged in panel vá»›i nÃºt Start
                print("ðŸ”‘ Opening login dialog...")
                
                # Loop Ä‘á»ƒ xá»­ lÃ½ Register flow
                while True:
                    login_dialog = LoginDialog()
                    
                    # Check if user has cached session - auto show logged in panel
                    try:
                        from license_client import get_license_client
                        license_client = get_license_client(server_url=LICENSE_SERVER_URL)
                        
                        if license_client.is_authenticated:
                            print(f"âœ… Found cached session, showing logged in panel...")
                            cached_username = license_client.get_cached_username() or "User"
                            days_remaining = license_client.days_remaining
                            license_type = license_client.license_data.get('license_type', 'N/A') if license_client.license_data else 'N/A'
                            
                            # Pre-fill the logged in panel
                            login_dialog.logged_in_user = {'username': cached_username}
                            login_dialog.logged_in_license = {'license_type': license_type, 'days_remaining': days_remaining}
                            
                            # Show logged in panel directly
                            login_dialog._show_logged_in_panel(
                                cached_username, 
                                {'license_type': license_type}, 
                                days_remaining
                            )
                    except Exception as e:
                        print(f"âš ï¸ Error checking cached session: {e}")
                    
                    result = login_dialog.exec_()
                    
                    # Check if user went to register
                    if hasattr(login_dialog, 'went_to_register') and login_dialog.went_to_register:
                        # User registered and activated - check login session again
                        try:
                            license_client = get_license_client(server_url=LICENSE_SERVER_URL)
                            if license_client.is_authenticated:
                                print("âœ… Login session valid after registration, continuing...")
                                break  # Exit loop, continue to main app
                        except:
                            pass
                        # Continue loop to show login dialog again
                        continue
                    
                    if result != QDialog.Accepted:
                        # User cancelled login - exit app
                        print("âŒ Login cancelled by user, exiting...")
                        sys.exit(0)
                    else:
                        # Login successful (user clicked Start)
                        break
                
                print("âœ… User clicked Start, opening main app...")
                
                # Sync language from LoginDialog to main app
                # LoginDialog may have changed language, so we need to apply it
                current_lang = AppState.language()
                print(f"ðŸŒ Syncing language after login: {current_lang}")
                # Just set the checked state - _apply_language will be triggered later when UI is ready
                if current_lang == 'vi':
                    lang_vi.setChecked(True)
                else:
                    lang_en.setChecked(True)
                # Store language to apply after window shows
                main_window._pending_language = current_lang
                
                # Láº¥y username tá»« login dialog vÃ  cáº­p nháº­t menu
                try:
                    # Try to get username from logged in info first, then from input field
                    logged_username = None
                    
                    # First try from user_name_label (shown in logged_in_panel)
                    if hasattr(login_dialog, 'user_name_label') and login_dialog.user_name_label.text():
                        logged_username = login_dialog.user_name_label.text()
                    
                    # Then try from logged_in_user dict
                    if not logged_username and hasattr(login_dialog, 'logged_in_user') and login_dialog.logged_in_user:
                        logged_username = login_dialog.logged_in_user.get('username') or login_dialog.logged_in_user.get('email')
                    
                    # Finally try from email input field
                    if not logged_username:
                        logged_username = login_dialog.email_input.text().strip()
                    
                    print(f"ðŸ“Š Got username: {logged_username}")
                    
                    if logged_username and hasattr(main_window, 'update_menu_for_user'):
                        main_window.update_menu_for_user(logged_username)
                        print(f"âœ… Menu updated for user: {logged_username}")
                    
                    # ========== SET USER LICENSE INFO FOR COUNTDOWN ==========
                    # Get license info from license_client (most up-to-date after refresh in _on_start_clicked)
                    expire_date = ''
                    days_remaining = 0
                    
                    # Try to get from license_client first
                    try:
                        from license_client import get_license_client
                        lc = get_license_client(server_url=LICENSE_SERVER_URL)
                        license_data = lc.license_data
                        
                        if license_data:
                            expire_date = license_data.get('expire_date', '')
                            days_remaining = license_data.get('days_remaining', 0)
                            
                            # Convert expire_date to string if needed
                            if expire_date and not isinstance(expire_date, str):
                                expire_date = str(expire_date)
                            
                            print(f"ðŸ“Š License data from client: expire_date={expire_date}, days_remaining={days_remaining}")
                    except Exception as e:
                        print(f"âš ï¸ Error getting license data from client: {e}")
                    
                    # Fallback to login_dialog data if needed
                    if not expire_date and hasattr(login_dialog, 'logged_in_license') and login_dialog.logged_in_license:
                        license_info = login_dialog.logged_in_license
                        expire_date = license_info.get('expire_date', '')
                        days_remaining = license_info.get('days_remaining', 0)
                        print(f"ðŸ“Š License data from login_dialog: expire_date={expire_date}, days_remaining={days_remaining}")
                    
                    # Always call set_user_license_info with whatever data we have
                    if hasattr(main_window, 'account_tab') and main_window.account_tab:
                        final_username = logged_username or 'User'
                        print(f"ðŸ“Š Calling set_user_license_info: username={final_username}, expire={expire_date}, days={days_remaining}")
                        main_window.account_tab.set_user_license_info(
                            username=final_username,
                            expire_date_str=expire_date,
                            days_remaining=days_remaining
                        )
                        print(f"âœ… License countdown started: expires {expire_date}, {days_remaining} days remaining")
                    else:
                        print(f"âš ï¸ account_tab not found or None!")
                    # ========== END SET USER LICENSE INFO ==========
                    
                except Exception as e:
                    print(f"âš ï¸ Error updating menu for user: {e}")
                
                # ========== Káº¾T THÃšC PHáº¦N ÄÄ‚NG NHáº¬P ==========

                # ========== PERIODIC LICENSE VALIDATION ==========
                # Track if we've already shown the expired warning this session
                _license_expired_warning_shown = [False]  # Use list to make it mutable in closure
                
                def periodic_license_check():
                    """Backup license check má»—i 30 phÃºt - sync vá»›i server"""
                    try:
                        # Check code integrity first (using license_guard)
                        try:
                            from license_guard import get_license_guard
                            guard = get_license_guard()
                            if not guard._check_code_integrity():
                                print("ðŸš¨ Code integrity check failed!")
                                QMessageBox.critical(main_window,
                                    "ðŸš¨ Security Alert",
                                    "Code tampering detected. Application will close.")
                                main_window.close()
                                sys.exit(1)
                        except ImportError:
                            pass  # license_guard not available
                        
                        # Check license validity (using license_client)
                        from license_client import get_license_client
                        lc = get_license_client(server_url=LICENSE_SERVER_URL)
                        
                        # Sync vá»›i server má»—i 30 phÃºt
                        print("ðŸ”„ Periodic sync: Refreshing license status from server...")
                        refresh_success, is_active = lc.refresh_license_status()
                        
                        if refresh_success:
                            print(f"âœ… License sync success, is_active={is_active}")
                            
                            # === UPDATE COUNTDOWN TIMER WITH NEW DATA FROM SERVER ===
                            try:
                                if hasattr(main_window, 'account_tab') and main_window.account_tab:
                                    # Get updated license data from client
                                    license_data = lc.license_data
                                    if license_data:
                                        new_expire_date = license_data.get('expire_date', '')
                                        new_days_remaining = license_data.get('days_remaining', 0)
                                        username = getattr(main_window.account_tab, '_logged_in_username', 'User')
                                        
                                        # Update countdown timer with new expire date
                                        main_window.account_tab.set_user_license_info(
                                            username=username,
                                            expire_date_str=new_expire_date,
                                            days_remaining=new_days_remaining
                                        )
                                        print(f"ðŸ”„ Countdown updated: expires {new_expire_date}, {new_days_remaining} days remaining")
                            except Exception as e:
                                print(f"âš ï¸ Error updating countdown: {e}")
                        else:
                            print(f"âš ï¸ License refresh failed (offline?), using cached: is_active={is_active}")
                        
                        # Check if license expired (not active)
                        if not is_active:
                            print("âš ï¸ License expired during periodic check")
                            
                            # === STOP AUTO TRADING IF RUNNING ===
                            try:
                                if hasattr(main_window, 'all_tabs') and 'auto_trading_tab' in main_window.all_tabs:
                                    auto_tab = main_window.all_tabs['auto_trading_tab']
                                    if hasattr(auto_tab, 'is_auto_on') and auto_tab.is_auto_on:
                                        print("âš ï¸ Stopping auto trading due to license expiration...")
                                        # Call toggle_auto to stop it
                                        if hasattr(auto_tab, 'toggle_auto'):
                                            auto_tab.toggle_auto()
                                        print("âœ… Auto trading stopped")
                            except Exception as e:
                                print(f"âš ï¸ Error stopping auto trading: {e}")
                            
                            # Only show warning once per session to avoid spam
                            if not _license_expired_warning_shown[0]:
                                _license_expired_warning_shown[0] = True
                                QMessageBox.warning(main_window,
                                    I18N.t("âš ï¸ License Expired", "âš ï¸ License Háº¿t Háº¡n"),
                                    I18N.t("Your license has expired.\n\nApp services (MT5 login, calculations, auto trading, etc.) are now restricted.\n\nAuto trading has been stopped.\n\nPlease renew your license to continue using all features.\n\nGo to Menu â†’ Account â†’ View Pricing to renew.",
                                           "License cá»§a báº¡n Ä‘Ã£ háº¿t háº¡n.\n\nCÃ¡c dá»‹ch vá»¥ cá»§a app (Ä‘Äƒng nháº­p MT5, tÃ­nh toÃ¡n, auto trading...) Ä‘Ã£ bá»‹ háº¡n cháº¿.\n\nAuto trading Ä‘Ã£ Ä‘Æ°á»£c táº¯t.\n\nVui lÃ²ng gia háº¡n license Ä‘á»ƒ tiáº¿p tá»¥c sá»­ dá»¥ng Ä‘áº§y Ä‘á»§ tÃ­nh nÄƒng.\n\nVÃ o Menu â†’ TÃ i khoáº£n â†’ Xem Báº£ng GiÃ¡ Ä‘á»ƒ gia háº¡n."))
                            
                            # NOTE: We do NOT close the app or force logout
                            # User can still browse and renew their license
                        else:
                            # Reset warning flag when license becomes valid again
                            _license_expired_warning_shown[0] = False
                            
                    except Exception as e:
                        print(f"âš ï¸ Periodic license check error: {e}")
                
                # Start periodic check timer (5 minutes = 300000 ms)
                # Sync with server to get updated license info (admin changes, renewals, etc.)
                license_check_timer = QTimer(main_window)
                license_check_timer.timeout.connect(periodic_license_check)
                license_check_timer.start(300000)  # 5 minutes
                print("âœ… Periodic license sync started (every 5 minutes)")
                # ========== END PERIODIC LICENSE VALIDATION ==========

                # ========== REAL-TIME LICENSE NOTIFICATION WATCHER ==========
                # Start notification watcher to receive real-time updates from server
                # when admin changes license (extend, reduce, etc.)
                try:
                    from license_client import get_license_client
                    notification_client = get_license_client(server_url=LICENSE_SERVER_URL)
                    
                    # Store pending notification to process in main thread
                    _pending_license_notification = [None]
                    
                    # Timer to process notifications in main thread (check every 500ms)
                    notification_process_timer = QTimer(main_window)
                    
                    def process_pending_notification():
                        """Process license notification in main thread (safe for Qt)"""
                        if _pending_license_notification[0] is None:
                            return
                        
                        change_info = _pending_license_notification[0]
                        _pending_license_notification[0] = None  # Clear pending
                        
                        try:
                            change_type = change_info.get('type', '')
                            change_data = change_info.get('data', {})
                            
                            print(f"ðŸ“¬ Processing license change in main thread: {change_type}")
                            
                            # Update countdown timer with new expire date
                            if hasattr(main_window, 'account_tab') and main_window.account_tab:
                                new_expire_date = change_data.get('expire_date', '')
                                new_days_remaining = change_data.get('days_remaining', 0)
                                username = getattr(main_window.account_tab, '_logged_in_username', 'User')
                                
                                # Update countdown timer
                                main_window.account_tab.set_user_license_info(
                                    username=username,
                                    expire_date_str=new_expire_date,
                                    days_remaining=new_days_remaining
                                )
                                print(f"ðŸ”„ Countdown updated from server: expires {new_expire_date}, {new_days_remaining} days")
                            
                            # Check if license was reduced to expired
                            is_valid = change_data.get('is_valid', True)
                            new_days_remaining = change_data.get('days_remaining', 0)
                            
                            if not is_valid or new_days_remaining <= 0:
                                print("âš ï¸ License expired (server notification)")
                                
                                # Stop auto trading if running
                                try:
                                    if hasattr(main_window, 'all_tabs') and 'auto_trading_tab' in main_window.all_tabs:
                                        auto_tab = main_window.all_tabs['auto_trading_tab']
                                        if hasattr(auto_tab, 'is_auto_on') and auto_tab.is_auto_on:
                                            print("âš ï¸ Stopping auto trading due to license expiration (server notify)...")
                                            if hasattr(auto_tab, 'toggle_auto'):
                                                auto_tab.toggle_auto()
                                            print("âœ… Auto trading stopped")
                                except Exception as e:
                                    print(f"âš ï¸ Error stopping auto trading: {e}")
                                
                                # Show warning if not already shown
                                if not _license_expired_warning_shown[0]:
                                    _license_expired_warning_shown[0] = True
                                    QMessageBox.warning(main_window,
                                        I18N.t("âš ï¸ License Expired", "âš ï¸ License Háº¿t Háº¡n"),
                                        I18N.t("Your license has expired.\n\nApp services (MT5 login, calculations, auto trading, etc.) are now restricted.\n\nPlease renew your license to continue using all features.",
                                               "License cá»§a báº¡n Ä‘Ã£ háº¿t háº¡n.\n\nCÃ¡c dá»‹ch vá»¥ cá»§a app (Ä‘Äƒng nháº­p MT5, tÃ­nh toÃ¡n, auto trading...) Ä‘Ã£ bá»‹ háº¡n cháº¿.\n\nVui lÃ²ng gia háº¡n license Ä‘á»ƒ tiáº¿p tá»¥c sá»­ dá»¥ng Ä‘áº§y Ä‘á»§ tÃ­nh nÄƒng."))
                            else:
                                # License renewed/extended - reset warning flag
                                _license_expired_warning_shown[0] = False
                                
                                # Show notification about license renewal
                                if change_type in ['license_renewed', 'license_updated']:
                                    new_expire_date = change_data.get('expire_date', '')
                                    new_days_remaining = change_data.get('days_remaining', 0)
                                    QMessageBox.information(main_window,
                                        I18N.t("âœ… License Updated", "âœ… License ÄÃ£ Cáº­p Nháº­t"),
                                        I18N.t(f"Your license has been updated.\n\nNew expiry: {new_expire_date}\nDays remaining: {new_days_remaining}",
                                               f"License cá»§a báº¡n Ä‘Ã£ Ä‘Æ°á»£c cáº­p nháº­t.\n\nHáº¿t háº¡n má»›i: {new_expire_date}\nSá»‘ ngÃ y cÃ²n láº¡i: {new_days_remaining}"))
                                    
                        except Exception as e:
                            print(f"âš ï¸ Error processing license change: {e}")
                    
                    notification_process_timer.timeout.connect(process_pending_notification)
                    notification_process_timer.start(500)  # Check every 500ms
                    
                    # Define callback for license changes from server (runs in background thread)
                    def on_license_changed_callback(change_info):
                        """Handle real-time license change notification from server (background thread)"""
                        # Just store the notification - will be processed in main thread by timer
                        print(f"ðŸ“¬ Real-time license change received: {change_info.get('type', '')}")
                        _pending_license_notification[0] = change_info
                    
                    # Set callback on license client
                    notification_client.on_license_changed = on_license_changed_callback
                    
                    # Start notification watcher thread
                    notification_client.start_notification_watcher()
                    print("ðŸ‘ï¸ Real-time license notification watcher started")
                    
                except Exception as e:
                    print(f"âš ï¸ Error starting notification watcher: {e}")
                # ========== END REAL-TIME LICENSE NOTIFICATION WATCHER ==========

                print("Showing window...")
                # Show window
                main_window.show()
                print("Window shown successfully!")
                
                # Apply pending language after window is shown
                try:
                    def apply_pending_language():
                        if hasattr(main_window, '_pending_language'):
                            pending_lang = main_window._pending_language
                            print(f"ðŸŒ Applying pending language: {pending_lang}")
                            # Trigger the language action to apply full UI translation
                            if pending_lang == 'en':
                                lang_en.trigger()
                            else:
                                lang_vi.trigger()
                            delattr(main_window, '_pending_language')
                    
                    QTimer.singleShot(100, apply_pending_language)  # Apply after 100ms
                except Exception as e:
                    print(f"âš ï¸ Error applying pending language: {e}")
                
                # Force refresh DCA labels after window is shown (Qt rendering fix)
                try:
                    def delayed_refresh():
                        if hasattr(main_window, 'all_tabs') and 'risk_management_tab' in main_window.all_tabs:
                            risk_tab = main_window.all_tabs['risk_management_tab']
                            if hasattr(risk_tab, 'refresh_dca_labels'):
                                risk_tab.refresh_dca_labels()
                                print("ðŸ”„ DCA labels refreshed after window display")
                
                    QTimer.singleShot(500, delayed_refresh)  # Refresh after 500ms
                except Exception as e:
                    print(f"âš ï¸ Error setting up delayed label refresh: {e}")
            
                print("âœ… GUI started successfully")

                # === Auto-start News scraping & scheduler integration ===
                try:
                    import pytz
                    from news_scraper import get_today_news, scan_event_window
                    print("[NewsAuto] Initializing news auto-start...")
                    # ========================= NEWS AUTO CONFIG =========================
                    # Set to True for scheduled-only mode (fetch only at news release times)
                    # Set to False for old behavior (initial fetch + periodic refresh)
                    NEWS_EVENT_ONLY = True  # Use scheduled times only
                    ENABLE_INITIAL_FETCH = True  # Always fetch on startup regardless of mode
                    # ====================================================================

                    # 1. Immediate clean + initial fetch (non-blocking via thread)
                    # Helper to invoke GUI-safe update
                    from PyQt5.QtCore import QMetaObject, Qt as _Qt, Q_ARG, QTimer as _QTimer

                    def _initial_news_fetch():
                        def _run():
                            try:
                                if news_tab.use_economic_calendar_checkbox.isChecked():
                                    print("[NewsAuto] Cleaning & fetching initial news (enabled)...")
                                
                                    # Get user news filters
                                    currencies, impacts = news_tab.get_user_news_filters()
                                    print(f"[NewsAuto] Using user filters - Currencies: {currencies}, Impacts: {impacts}")
                                
                                    get_today_news(currencies=currencies, impacts=impacts, headless=True, auto_cleanup=True, clean_existing_files=True)
                                    print("[NewsAuto] Initial news fetch complete")
                                
                                    # After successful fetch, extract news release times and schedule auto-updates
                                    print("[NewsAuto] Analyzing news release times...")
                                    try:
                                        from news_scraper import parse_news_release_times
                                        news_times = parse_news_release_times()
                                        if news_times:
                                            # Schedule auto-fetch at each news release time
                                            _QTimer.singleShot(2000, lambda: _setup_smart_news_schedule(news_times))
                                            print(f"[NewsAuto] Will schedule auto-fetch for {len(news_times)} times: {news_times}")
                                        else:
                                            print("[NewsAuto] No news times found, using fallback schedule")
                                            fallback_times = ["08:30", "13:30", "15:30", "19:00", "21:30"]
                                            _QTimer.singleShot(2000, lambda: _setup_smart_news_schedule(fallback_times))
                                    except Exception as e:
                                        print(f"[NewsAuto] Error analyzing news times: {e}")
                                        # Use fallback schedule
                                        fallback_times = ["08:30", "13:30", "15:30", "19:00", "21:30"]
                                        _QTimer.singleShot(2000, lambda: _setup_smart_news_schedule(fallback_times))
                                else:
                                    print("[NewsAuto] Skipped initial news fetch (disabled)")
                            except Exception as e:
                                print(f"[NewsAuto] Initial fetch error: {e}")
                            # After fetch attempt, ask NewsTab to load latest file on GUI thread
                            if news_tab.use_economic_calendar_checkbox.isChecked():
                                _QTimer.singleShot(0, news_tab.load_latest_news_file_slot)
                        threading.Thread(target=_run, daemon=True).start()
                
                    # Always run initial fetch if enabled
                    if ENABLE_INITIAL_FETCH:
                        _initial_news_fetch()
                        print("[NewsAuto] Initial news fetch scheduled")
                    else:
                        print("[NewsAuto] Initial fetch disabled by config")

                    # 2. Smart scheduler: auto-extract event times from fetched news
                    # After initial fetch, parse all news times and schedule auto-updates at those times
                    scheduled_event_times = []  # Will be populated from actual news data
                    _scheduled_events_mtime = None  # track mtime of scheduled_events.json
                    _latest_news_file_mtime = None  # track mtime of latest news file to derive times
                    _event_timers = []  # Store timer references for cleanup

                    def _setup_smart_news_schedule(news_times: list):
                        """Set up automatic news fetching at specific release times"""
                        try:
                            # Clear any existing event timers
                            for timer in _event_timers:
                                timer.stop()
                                timer.deleteLater()
                            _event_timers.clear()
                        
                            # Update scheduled_event_times with actual news times
                            scheduled_event_times.clear()
                            scheduled_event_times.extend(news_times)
                        
                            from PyQt5.QtCore import QTime
                            current_time = QTime.currentTime()
                        
                            print(f"[NewsAuto] Setting up smart schedule for {len(news_times)} times...")
                        
                            for time_str in news_times:
                                try:
                                    target_time = QTime.fromString(time_str, "hh:mm")
                                    if target_time.isValid():
                                        # Calculate milliseconds until target time
                                        if target_time > current_time:
                                            # Target time is later today
                                            ms_until = current_time.msecsTo(target_time)
                                        else:
                                            # Target time is tomorrow (add 24 hours)
                                            ms_until = current_time.msecsTo(target_time) + 24 * 60 * 60 * 1000
                                    
                                        timer = _QTimer()
                                        timer.setSingleShot(True)
                                        timer.timeout.connect(lambda t=time_str: _handle_scheduled_news_fetch(t))
                                        timer.start(ms_until)
                                        _event_timers.append(timer)
                                    
                                        print(f"[NewsAuto] â° Scheduled news fetch at {time_str} (in {ms_until/1000/60:.1f} minutes)")
                                    else:
                                        print(f"[NewsAuto] âŒ Invalid time format: {time_str}")
                                except Exception as e:
                                    print(f"[NewsAuto] âŒ Error setting timer for {time_str}: {e}")
                        
                            print(f"[NewsAuto] âœ… Smart news schedule ready with {len(_event_timers)} timers")
                        
                        except Exception as e:
                            print(f"[NewsAuto] âŒ Error setting up smart news schedule: {e}")

                    def _handle_scheduled_news_fetch(time_str: str):
                        """Handle automatic news fetch at scheduled time"""
                        try:
                            print(f"[NewsAuto] ðŸ”” Auto news fetch triggered at {time_str}")
                            def _fetch():
                                try:
                                    if news_tab.use_economic_calendar_checkbox.isChecked():
                                        print(f"[NewsAuto] Fetching news update at {time_str}...")
                                    
                                        # Get user news filters
                                        currencies, impacts = news_tab.get_user_news_filters()
                                        print(f"[NewsAuto] Using user filters - Currencies: {currencies}, Impacts: {impacts}")
                                    
                                        get_today_news(currencies=currencies, impacts=impacts, headless=True, auto_cleanup=False)
                                        print(f"[NewsAuto] âœ… News update complete at {time_str}")
                                        # Reload news in GUI
                                        _QTimer.singleShot(1000, news_tab.load_latest_news_file_slot)
                                    else:
                                        print(f"[NewsAuto] Skipped news fetch at {time_str} (disabled)")
                                except Exception as e:
                                    print(f"[NewsAuto] âŒ Error fetching news at {time_str}: {e}")
                        
                            # Run fetch in background thread
                            threading.Thread(target=_fetch, daemon=True).start()
                        
                            # Schedule next occurrence for tomorrow (24 hours later)
                            next_timer = _QTimer()
                            next_timer.setSingleShot(True)
                            next_timer.timeout.connect(lambda: _handle_scheduled_news_fetch(time_str))
                            next_timer.start(24 * 60 * 60 * 1000)  # 24 hours
                            _event_timers.append(next_timer)
                            print(f"[NewsAuto] â° Scheduled next occurrence for {time_str} tomorrow")
                        
                        except Exception as e:
                            print(f"[NewsAuto] âŒ Error in scheduled news fetch for {time_str}: {e}")

                    def _setup_daily_news_refresh():
                        """Set up daily news refresh at 00:01 and 00:30 to get new day's news schedule"""
                        try:
                            from PyQt5.QtCore import QTime
                            current_time = QTime.currentTime()
                        
                            # Daily refresh times
                            daily_refresh_times = ["00:01", "00:30"]
                        
                            print("[NewsAuto] Setting up daily news refresh schedule...")
                        
                            for time_str in daily_refresh_times:
                                try:
                                    target_time = QTime.fromString(time_str, "hh:mm")
                                    if target_time.isValid():
                                        # Calculate milliseconds until target time
                                        if target_time > current_time:
                                            # Target time is later today
                                            ms_until = current_time.msecsTo(target_time)
                                        else:
                                            # Target time is tomorrow (add 24 hours)
                                            ms_until = current_time.msecsTo(target_time) + 24 * 60 * 60 * 1000
                                    
                                        timer = _QTimer()
                                        timer.setSingleShot(True)
                                        timer.timeout.connect(lambda t=time_str: _handle_daily_news_refresh(t))
                                        timer.start(ms_until)
                                        _event_timers.append(timer)
                                    
                                        print(f"[NewsAuto] ðŸŒ… Scheduled daily news refresh at {time_str} (in {ms_until/1000/60:.1f} minutes)")
                                    else:
                                        print(f"[NewsAuto] âŒ Invalid refresh time format: {time_str}")
                                except Exception as e:
                                    print(f"[NewsAuto] âŒ Error setting daily refresh timer for {time_str}: {e}")
                        
                            print(f"[NewsAuto] âœ… Daily news refresh schedule ready")
                        
                        except Exception as e:
                            print(f"[NewsAuto] âŒ Error setting up daily news refresh: {e}")

                    def _handle_daily_news_refresh(time_str: str):
                        """Handle daily news refresh to get new day's news and update schedule"""
                        try:
                            print(f"[NewsAuto] ðŸŒ… Daily news refresh triggered at {time_str}")
                            def _refresh():
                                try:
                                    if news_tab.use_economic_calendar_checkbox.isChecked():
                                        print(f"[NewsAuto] Fetching fresh news data at {time_str} for new day...")
                                    
                                        # Get user news filters
                                        currencies, impacts = news_tab.get_user_news_filters()
                                        print(f"[NewsAuto] Using user filters - Currencies: {currencies}, Impacts: {impacts}")
                                    
                                        get_today_news(currencies=currencies, impacts=impacts, headless=True, auto_cleanup=True, clean_existing_files=True)
                                        print(f"[NewsAuto] âœ… Fresh news data fetched at {time_str}")
                                    
                                        # After getting fresh news, re-analyze and update schedule
                                        print("[NewsAuto] Re-analyzing news release times for new day...")
                                        try:
                                            from news_scraper import parse_news_release_times
                                            new_news_times = parse_news_release_times()
                                            if new_news_times:
                                                # Update schedule with new day's news times
                                                _QTimer.singleShot(2000, lambda: _setup_smart_news_schedule(new_news_times))
                                                print(f"[NewsAuto] ðŸ“… Updated schedule for new day with {len(new_news_times)} times: {new_news_times}")
                                            else:
                                                print("[NewsAuto] No new news times found, keeping existing schedule")
                                        except Exception as e:
                                            print(f"[NewsAuto] âŒ Error re-analyzing news times: {e}")
                                    
                                        # Reload news in GUI
                                        _QTimer.singleShot(1000, news_tab.load_latest_news_file_slot)
                                    else:
                                        print(f"[NewsAuto] Skipped daily refresh at {time_str} (disabled)")
                                except Exception as e:
                                    print(f"[NewsAuto] âŒ Error in daily news refresh at {time_str}: {e}")
                        
                            # Run refresh in background thread
                            threading.Thread(target=_refresh, daemon=True).start()
                        
                            # Schedule next daily refresh for tomorrow (24 hours later)
                            next_timer = _QTimer()
                            next_timer.setSingleShot(True)
                            next_timer.timeout.connect(lambda: _handle_daily_news_refresh(time_str))
                            next_timer.start(24 * 60 * 60 * 1000)  # 24 hours
                            _event_timers.append(next_timer)
                            print(f"[NewsAuto] ðŸŒ… Scheduled next daily refresh for {time_str} tomorrow")
                        
                        except Exception as e:
                            print(f"[NewsAuto] âŒ Error in daily news refresh for {time_str}: {e}")

                    def _convert_12h_to_24h(t: str) -> str:
                        t = str(t).strip().lower()
                        if not t or t in ("all day", ""):
                            return ""
                        m = re.match(r'^(\d{1,2}):(\d{2})(am|pm)$', t)
                        if not m:
                            # maybe already 24h
                            if re.match(r'^\d{2}:\d{2}$', t):
                                return t
                            return ""
                        h, mn, ap = m.groups()
                        h = int(h)
                        if ap == 'pm' and h != 12:
                            h += 12
                        if ap == 'am' and h == 12:
                            h = 0
                        return f"{h:02d}:{mn}"

                    def _find_latest_news_file():
                        news_dir = 'news_output'
                        if not os.path.exists(news_dir):
                            return None
                        newest = None
                        newest_time = 0
                        for fname in os.listdir(news_dir):
                            if not fname.endswith('.json'):
                                continue
                            fp = os.path.join(news_dir, fname)
                            try:
                                st = os.stat(fp)
                                if st.st_mtime > newest_time:
                                    newest = fp
                                    newest_time = st.st_mtime
                            except Exception:
                                continue
                        return newest

                    def _derive_times_from_latest_news():
                        nonlocal scheduled_event_times, _latest_news_file_mtime
                        latest = _find_latest_news_file()
                        if not latest:
                            return
                        try:
                            st = os.stat(latest)
                            if _latest_news_file_mtime is not None and st.st_mtime <= _latest_news_file_mtime:
                                return  # no change
                            with open(latest, 'r', encoding='utf-8') as f:
                                data = json.load(f)
                            # data can be list (old style) or dict with 'events'
                            events = []
                            if isinstance(data, list):
                                events = data
                            elif isinstance(data, dict):
                                if isinstance(data.get('events'), list):
                                    events = data['events']
                            now_vn = datetime.now(pytz.timezone('Asia/Ho_Chi_Minh'))
                            new_times = set()
                            for ev in events:
                                tm = ev.get('time')
                                dv = ev.get('date')
                                tm24 = _convert_12h_to_24h(tm)
                                if not tm24:
                                    continue
                                # Ensure event still in the future (>= now - 1 minute)
                                try:
                                    # parse date variants
                                    ev_date = None
                                    if isinstance(dv, str) and re.match(r'^\d{4}-\d{2}-\d{2}$', dv):
                                        ev_date = datetime.strptime(dv, '%Y-%m-%d')
                                    else:
                                        # fallback: assume today
                                        ev_date = now_vn
                                    ev_dt = now_vn.replace(hour=int(tm24[:2]), minute=int(tm24[3:5]), second=0, microsecond=0)
                                    # If date differs, adjust
                                    if ev_date.date() != now_vn.date():
                                        continue  # only today
                                    if (ev_dt - now_vn).total_seconds() >= -60:  # allow slightly past to still scan
                                        new_times.add(tm24)
                                except Exception:
                                    continue
                            if new_times:
                                merged = sorted(set(scheduled_event_times).union(new_times))
                                if merged != scheduled_event_times:
                                    scheduled_event_times = merged
                                    print(f"[NewsAuto] Derived event times from news: {scheduled_event_times}")
                                    # persist to scheduled_events.json so user can edit
                                    try:
                                        os.makedirs('news_output', exist_ok=True)
                                        with open(os.path.join('news_output','scheduled_events.json'),'w',encoding='utf-8') as wf:
                                            json.dump({'times': scheduled_event_times}, wf, ensure_ascii=False, indent=2)
                                    except Exception as e:
                                        print(f"[NewsAuto] Persist scheduled times failed: {e}")
                            _latest_news_file_mtime = st.st_mtime
                        except Exception as e:
                            print(f"[NewsAuto] Derive times error: {e}")

                    def _load_scheduled_events_file(initial=False):
                        nonlocal scheduled_event_times, _scheduled_events_mtime
                        cfg_path = os.path.join('news_output','scheduled_events.json')
                        if not os.path.exists(cfg_path):
                            if initial:
                                # Try to derive automatically on first run
                                _derive_times_from_latest_news()
                            return
                        try:
                            st = os.stat(cfg_path)
                            if _scheduled_events_mtime is not None and st.st_mtime == _scheduled_events_mtime:
                                return
                            with open(cfg_path,'r',encoding='utf-8') as f:
                                js = json.load(f)
                            if isinstance(js, dict) and isinstance(js.get('times'), list):
                                new_list = [t for t in js['times'] if isinstance(t,str) and re.match(r'^\d{2}:\d{2}$', t)]
                                if new_list != scheduled_event_times:
                                    scheduled_event_times = sorted(set(new_list))
                                    print(f"[NewsAuto] Loaded scheduled times: {scheduled_event_times}")
                            _scheduled_events_mtime = st.st_mtime
                        except Exception as e:
                            print(f"[NewsAuto] Load scheduled_events.json failed: {e}")

                    # Initial load/derive (derive only if not event-only)
                    _load_scheduled_events_file(initial=not NEWS_EVENT_ONLY)
                    if NEWS_EVENT_ONLY and not scheduled_event_times:
                        print("[NewsAuto] Event-only mode active but no scheduled times loaded. Create news_output/scheduled_events.json with { 'times': ['HH:MM', ...] }.")

                    # Provide hot reload from a config file if exists
                    sched_cfg_path = os.path.join('news_output', 'scheduled_events.json')
                    if os.path.exists(sched_cfg_path):
                        try:
                            with open(sched_cfg_path,'r',encoding='utf-8') as f:_sc=json.load(f)
                            if isinstance(_sc, dict) and isinstance(_sc.get('times'), list):
                                scheduled_event_times = [t for t in _sc['times'] if isinstance(t,str)]
                                print(f"[NewsAuto] Loaded scheduled times: {scheduled_event_times}")
                        except Exception as e:
                            print(f"[NewsAuto] Failed loading scheduled_events.json: {e}")

                    try:
                        vn_tz = pytz.timezone('Asia/Ho_Chi_Minh')
                    except Exception as e:
                        print(f"[NewsAuto] Timezone error: {e}, using UTC")
                        vn_tz = pytz.timezone('UTC')
                    active_scans = {}

                    def _maybe_trigger_event_scans():
                        now_vn = datetime.now(vn_tz)
                        current_hhmm = now_vn.strftime('%H:%M')
                        if not news_tab.use_economic_calendar_checkbox.isChecked():
                            return
                        # Dynamic reload attempt each cycle (cheap ops)
                        _load_scheduled_events_file()
                        for t in list(scheduled_event_times):
                            # Start scan a bit BEFORE exact minute and ensure not started
                            if t not in active_scans:
                                # If within -1 to +1 minute window
                                try:
                                    hh,mm = t.split(':'); target_dt = now_vn.replace(hour=int(hh), minute=int(mm), second=0, microsecond=0)
                                    delta_sec = (now_vn - target_dt).total_seconds()
                                    if -60 <= delta_sec <= 60:  # start scan window
                                        def _scan_thread(tt=t):
                                            try:
                                                print(f"[NewsAuto] Starting focused scan window for {tt}...")
                                                scan_event_window(target_time=tt, window_minutes=5, poll_interval=30,
                                                                  headless=True, clean_each_attempt=True)
                                                print(f"[NewsAuto] Focused scan finished for {tt}")
                                                # GUI refresh after scan
                                                if news_tab.use_economic_calendar_checkbox.isChecked():
                                                    _QTimer.singleShot(0, news_tab.load_latest_news_file_slot)
                                            except Exception as e:
                                                print(f"[NewsAuto] Scan error {tt}: {e}")
                                            finally:
                                                # Allow re-scan next day only
                                                active_scans.pop(tt, None)
                                        th = threading.Thread(target=_scan_thread, daemon=True)
                                        active_scans[t] = th
                                        th.start()
                                except Exception:
                                    continue

                    # Timer to check every 20s for upcoming events
                    news_timer = QTimer()
                    news_timer.setInterval(20000)
                    news_timer.timeout.connect(_maybe_trigger_event_scans)
                    news_timer.start()
                    # Periodic refresh (every 2 minutes) to catch manual file updates
                    if not NEWS_EVENT_ONLY:
                        periodic_news_refresh = _QTimer()
                        periodic_news_refresh.setInterval(120000)
                        def _periodic_refresh():
                            if news_tab.use_economic_calendar_checkbox.isChecked():
                                news_tab.load_latest_news_file_slot()
                        periodic_news_refresh.timeout.connect(_periodic_refresh)
                        periodic_news_refresh.start()
                        # Timer to periodically attempt deriving times from updated news file (if user manually fetched)
                        derive_timer = QTimer()
                        derive_timer.setInterval(60000)  # 60s
                        def _periodic_derive():
                            if news_tab.use_economic_calendar_checkbox.isChecked():
                                _derive_times_from_latest_news()
                        derive_timer.timeout.connect(_periodic_derive)
                        derive_timer.start()
                        print("[NewsAuto] Standard mode: scheduler active (20s), refresh 120s, derive 60s.")
                    else:
                        print("[NewsAuto] Event-only mode active: no periodic refresh/derive; scans only at scheduled times.")
                except Exception as e:
                    print(f"[NewsAuto] Initialization failed: {e}")
            
                # Set up daily news refresh at 00:01 and 00:30 (after all functions are defined)
                try:
                    _QTimer.singleShot(5000, _setup_daily_news_refresh)  # Start after 5 seconds
                    print("[NewsAuto] Daily news refresh (00:01, 00:30) scheduled")
                except Exception as e:
                    print(f"[NewsAuto] Daily refresh setup failed: {e}")
            
                # Strategy Management Function
                def _open_strategy_manager():
                    """Open strategy management dialog"""
                    try:
                        from PyQt5.QtWidgets import QDialog, QVBoxLayout, QHBoxLayout, QListWidget, QPushButton, QInputDialog, QMessageBox, QLabel
                        import json
                        import os
                        from datetime import datetime
                        
                        class StrategyManagerDialog(QDialog):
                            def __init__(self, parent=None):
                                super().__init__(parent)
                                self.setWindowTitle(I18N.t("Trading Strategy Manager", "Quáº£n lÃ½ Chiáº¿n lÆ°á»£c Giao dá»‹ch"))
                                self.setFixedSize(600, 400)
                                self.setModal(True)
                                
                                # Store main window reference for strategy application
                                self.main_window_ref = parent
                                
                                # Strategy storage file
                                self.strategies_file = os.path.join(os.getcwd(), "saved_strategies.json")
                                
                                self.init_ui()
                                self.load_strategies()
                                
                            def init_ui(self):
                                layout = QVBoxLayout()
                                
                                # Title
                                title_label = QLabel(I18N.t("Strategy Management", "Quáº£n lÃ½ Chiáº¿n lÆ°á»£c"))
                                title_label.setStyleSheet("font-size: 16px; font-weight: bold; margin: 10px;")
                                layout.addWidget(title_label)
                                
                                # Strategy list
                                self.strategy_list = QListWidget()
                                self.strategy_list.itemDoubleClicked.connect(self.load_selected_strategy)
                                layout.addWidget(self.strategy_list)
                                
                                # Buttons layout
                                button_layout = QHBoxLayout()
                                
                                # Create new strategy button
                                create_btn = QPushButton(I18N.t("Create New Strategy", "Táº¡o Chiáº¿n lÆ°á»£c Má»›i"))
                                create_btn.clicked.connect(self.create_new_strategy)
                                create_btn.setStyleSheet("""
                                    QPushButton {
                                        background: #4CAF50;
                                        color: white;
                                        border: none;
                                        padding: 8px 16px;
                                        border-radius: 4px;
                                        font-weight: bold;
                                    }
                                    QPushButton:hover { background: #45a049; }
                                """)
                                
                                # Load strategy button
                                load_btn = QPushButton(I18N.t("Load Strategy", "Táº£i Chiáº¿n lÆ°á»£c"))
                                load_btn.clicked.connect(self.load_selected_strategy)
                                load_btn.setStyleSheet("""
                                    QPushButton {
                                        background: #2196F3;
                                        color: white;
                                        border: none;
                                        padding: 8px 16px;
                                        border-radius: 4px;
                                        font-weight: bold;
                                    }
                                    QPushButton:hover { background: #1976D2; }
                                """)
                                
                                # Delete strategy button
                                delete_btn = QPushButton(I18N.t("Delete Strategy", "XÃ³a Chiáº¿n lÆ°á»£c"))
                                delete_btn.clicked.connect(self.delete_selected_strategy)
                                delete_btn.setStyleSheet("""
                                    QPushButton {
                                        background: #f44336;
                                        color: white;
                                        border: none;
                                        padding: 8px 16px;
                                        border-radius: 4px;
                                        font-weight: bold;
                                    }
                                    QPushButton:hover { background: #d32f2f; }
                                """)
                                
                                # Close button
                                close_btn = QPushButton(I18N.t("Close", "ÄÃ³ng"))
                                close_btn.clicked.connect(self.close)
                                close_btn.setStyleSheet("""
                                    QPushButton {
                                        background: #757575;
                                        color: white;
                                        border: none;
                                        padding: 8px 16px;
                                        border-radius: 4px;
                                        font-weight: bold;
                                    }
                                    QPushButton:hover { background: #616161; }
                                """)
                                
                                button_layout.addWidget(create_btn)
                                button_layout.addWidget(load_btn)
                                button_layout.addWidget(delete_btn)
                                button_layout.addStretch()
                                button_layout.addWidget(close_btn)
                                
                                layout.addLayout(button_layout)
                                self.setLayout(layout)
                                
                            def get_current_strategy_settings(self):
                                """Capture ALL current tab settings - COMPREHENSIVE VERSION 4.0"""
                                try:
                                    print("[Strategy] ðŸ”„ Capturing current settings (v4.0 - COMPLETE)...")
                                    
                                    main_window_ref = getattr(self, 'main_window_ref', None)
                                    if not main_window_ref:
                                        print("[Strategy] âŒ CRITICAL: Cannot find main window reference!")
                                        return None
                                    
                                    settings = {
                                        'timestamp': datetime.now().isoformat(),
                                        'version': '4.0',
                                        'tabs': {}
                                    }
                                    
                                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                    # RISK MANAGEMENT TAB - COMPLETE CAPTURE
                                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                    try:
                                        print("[Strategy] ðŸ›¡ï¸ Capturing Risk Management tab...")
                                        risk_settings = {}
                                        
                                        if hasattr(main_window_ref, 'risk_tab') and main_window_ref.risk_tab:
                                            rt = main_window_ref.risk_tab
                                            
                                            # ALL SPIN BOXES (QSpinBox & QDoubleSpinBox)
                                            spin_widgets = [
                                                'min_lot_spin', 'fixed_volume_spin', 'default_volume_spin',
                                                'default_sl_spin', 'default_tp_spin',
                                                'breakeven_min_spin', 'breakeven_max_spin',
                                                'trailing_activation_spin', 'trailing_min_spin', 'trailing_max_spin',
                                                'max_positions_spin', 'max_positions_per_symbol_spin', 'max_correlation_spin',
                                                'start_hour_spin', 'end_hour_spin',
                                                'spread_multiplier_spin', 'max_slippage_spin',
                                                'max_dca_levels_spin', 'dca_multiplier_spin',
                                                'dca_atr_period_spin', 'dca_atr_mult_spin', 'dca_base_distance_spin',
                                                'dca_min_drawdown_spin', 'dca_avg_sl_profit_spin',
                                            ]
                                            for w in spin_widgets:
                                                if hasattr(rt, w):
                                                    widget = getattr(rt, w)
                                                    if hasattr(widget, 'value'):
                                                        risk_settings[w] = widget.value()
                                            
                                            # ALL COMBO BOXES (with both text and index)
                                            combo_widgets = [
                                                'volume_mode_combo', 'sltp_mode_combo',
                                                'max_risk_combo', 'max_drawdown_combo', 'daily_loss_combo',
                                                'max_lot_combo', 'min_rr_combo',
                                                'avoid_news_combo', 'emergency_dd_combo',
                                                'dca_mode_combo', 'dca_fibo_start_combo', 'dca_fibo_exec_combo', 'dca_sl_mode_combo',
                                            ]
                                            for w in combo_widgets:
                                                if hasattr(rt, w):
                                                    widget = getattr(rt, w)
                                                    if hasattr(widget, 'currentText'):
                                                        risk_settings[w] = widget.currentText()
                                                    if hasattr(widget, 'currentIndex'):
                                                        risk_settings[w + '_idx'] = widget.currentIndex()
                                            
                                            # ALL CHECKBOXES
                                            checkbox_widgets = [
                                                'trailing_volatility_cb', 'enable_dca_check', 'auto_reduce_check',
                                            ]
                                            for w in checkbox_widgets:
                                                if hasattr(rt, w):
                                                    widget = getattr(rt, w)
                                                    if hasattr(widget, 'isChecked'):
                                                        risk_settings[w] = widget.isChecked()
                                            
                                            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                            # SYMBOL EXPOSURE TABLE - capture exposure and multipliers
                                            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                            symbol_exposure = {}
                                            symbol_multipliers = {}
                                            
                                            # METHOD 1: Try to read from rt.settings FIRST (most reliable)
                                            if hasattr(rt, 'settings') and rt.settings:
                                                if 'symbol_exposure' in rt.settings and rt.settings['symbol_exposure']:
                                                    symbol_exposure = dict(rt.settings['symbol_exposure'])
                                                if 'symbol_multipliers' in rt.settings and rt.settings['symbol_multipliers']:
                                                    symbol_multipliers = dict(rt.settings['symbol_multipliers'])
                                            
                                            # METHOD 2: If settings empty, try reading from exposure_table widget
                                            if not symbol_exposure and hasattr(rt, 'exposure_table') and rt.exposure_table:
                                                for row in range(rt.exposure_table.rowCount()):
                                                    symbol_item = rt.exposure_table.item(row, 0)
                                                    if symbol_item:
                                                        symbol = symbol_item.text()
                                                        if symbol and symbol not in ["ChÆ°a chá»n mÃ£", "No symbols selected", "--", ""]:
                                                            try:
                                                                exposure_widget = rt.exposure_table.cellWidget(row, 1)
                                                                multiplier_widget = rt.exposure_table.cellWidget(row, 2)
                                                                if exposure_widget and multiplier_widget:
                                                                    symbol_exposure[symbol] = exposure_widget.value()
                                                                    symbol_multipliers[symbol] = multiplier_widget.value()
                                                            except:
                                                                pass
                                            
                                            # METHOD 3: If still empty, try reading from risk_settings.json file
                                            if not symbol_exposure:
                                                try:
                                                    import os
                                                    risk_file = os.path.join(os.getcwd(), "risk_management", "risk_settings.json")
                                                    if os.path.exists(risk_file):
                                                        with open(risk_file, 'r', encoding='utf-8') as f:
                                                            file_settings = json.load(f)
                                                        if 'symbol_exposure' in file_settings and file_settings['symbol_exposure']:
                                                            symbol_exposure = dict(file_settings['symbol_exposure'])
                                                        if 'symbol_multipliers' in file_settings and file_settings['symbol_multipliers']:
                                                            symbol_multipliers = dict(file_settings['symbol_multipliers'])
                                                except:
                                                    pass
                                            
                                            # Save to strategy
                                            if symbol_exposure:
                                                risk_settings['symbol_exposure'] = symbol_exposure
                                                risk_settings['symbol_multipliers'] = symbol_multipliers
                                                print(f"   ðŸ“Š Symbol exposure: {len(symbol_exposure)} symbols")
                                            
                                            print(f"   âœ… Risk Management: {len(risk_settings)} settings captured")
                                        
                                        settings['tabs']['risk_management'] = risk_settings
                                    except Exception as e:
                                        print(f"   âŒ Risk Management error: {e}")
                                        settings['tabs']['risk_management'] = {}
                                    
                                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                    # MARKET TAB - SYMBOLS & TIMEFRAMES (FULL)
                                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                    try:
                                        print("[Strategy] ðŸ’¹ Capturing Market tab...")
                                        market_settings = {}
                                        
                                        if hasattr(main_window_ref, 'market_tab') and main_window_ref.market_tab:
                                            mt = main_window_ref.market_tab
                                            
                                            # Selected symbols (from checked_symbols set)
                                            if hasattr(mt, 'checked_symbols'):
                                                market_settings['checked_symbols'] = list(mt.checked_symbols)
                                                print(f"   ðŸ“Œ Symbols: {market_settings['checked_symbols']}")
                                            
                                            # Timeframe settings (checkbox state + candle count)
                                            if hasattr(mt, 'tf_checkboxes') and hasattr(mt, 'tf_spinboxes'):
                                                tf_settings = {}
                                                for tf_name, cb in mt.tf_checkboxes.items():
                                                    tf_settings[tf_name] = {
                                                        'enabled': cb.isChecked(),
                                                        'candles': mt.tf_spinboxes[tf_name].value() if tf_name in mt.tf_spinboxes else 5000
                                                    }
                                                market_settings['timeframes'] = tf_settings
                                            
                                            # Chart settings
                                            if hasattr(mt, 'chart_symbol_combo'):
                                                market_settings['chart_symbol'] = mt.chart_symbol_combo.currentText()
                                            if hasattr(mt, 'chart_timeframe_combo'):
                                                market_settings['chart_timeframe'] = mt.chart_timeframe_combo.currentText()
                                            
                                            print(f"   âœ… Market: {len(market_settings.get('checked_symbols', []))} symbols, {len(market_settings.get('timeframes', {}))} timeframes")
                                        
                                        settings['tabs']['market'] = market_settings
                                    except Exception as e:
                                        print(f"   âŒ Market error: {e}")
                                        settings['tabs']['market'] = {}
                                    
                                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                    # INDICATOR TAB - COMPATIBLE WITH restore_user_config FORMAT
                                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                    try:
                                        print("[Strategy] ðŸ“Š Capturing Indicator tab...")
                                        indicator_settings = {}
                                        
                                        if hasattr(main_window_ref, 'indicator_tab') and main_window_ref.indicator_tab:
                                            it = main_window_ref.indicator_tab
                                            
                                            # Use same format as save_current_user_config for compatibility
                                            if hasattr(it, 'indicator_rows') and hasattr(it, 'INDICATOR_OPTIONS'):
                                                rows_data = []
                                                for row_dict in it.indicator_rows:
                                                    try:
                                                        if 'indi_combo' not in row_dict:
                                                            continue
                                                        
                                                        indi_label = row_dict['indi_combo'].currentText()
                                                        # Find indicator name from label
                                                        indi_name = None
                                                        for opt in it.INDICATOR_OPTIONS:
                                                            if opt.get("label") == indi_label:
                                                                indi_name = opt.get("name")
                                                                break
                                                        
                                                        if not indi_name:
                                                            continue
                                                        
                                                        # Collect params using same logic as save_current_user_config
                                                        params = {}
                                                        param_keys = [
                                                            ("period_spin", "period"), ("ma_type_combo", "ma_type"),
                                                            ("fast_spin", "fast"), ("slow_spin", "slow"), ("signal_spin", "signal"),
                                                            ("smooth_spin", "smooth"), ("window_spin", "window"), ("dev_spin", "dev"),
                                                            ("step_spin", "step"), ("max_step_spin", "max_step"),
                                                            ("window1_spin", "window1"), ("window2_spin", "window2"),
                                                            ("window3_spin", "window3"), ("window4_spin", "window4"),
                                                            ("window_sig_spin", "window_sig"),
                                                            ("smooth1_spin", "smooth1"), ("smooth2_spin", "smooth2"),
                                                            ("short_spin", "short"), ("medium_spin", "medium"), ("long_spin", "long"),
                                                            ("lookback_spin", "lookback"),
                                                            ("tenkan_spin", "tenkan"), ("kijun_spin", "kijun"), ("senkou_spin", "senkou"),
                                                            ("percent_spin", "percent"),
                                                        ]
                                                        
                                                        for widget_key, param_name in param_keys:
                                                            if widget_key in row_dict:
                                                                widget = row_dict[widget_key]
                                                                try:
                                                                    if hasattr(widget, 'value'):
                                                                        params[param_name] = widget.value()
                                                                    elif hasattr(widget, 'currentText'):
                                                                        params[param_name] = widget.currentText()
                                                                except:
                                                                    pass
                                                        
                                                        row_data = {
                                                            "name": indi_name,
                                                            "label": indi_label,
                                                            "params": params
                                                        }
                                                        rows_data.append(row_data)
                                                        print(f"   ðŸ“ˆ {indi_name}: {params}")
                                                    except Exception as row_e:
                                                        print(f"   âš ï¸ Row error: {row_e}")
                                                
                                                indicator_settings['indicator_rows'] = rows_data
                                            
                                            print(f"   âœ… Indicators: {len(indicator_settings.get('indicator_rows', []))} rows captured")
                                        
                                        settings['tabs']['indicators'] = indicator_settings
                                    except Exception as e:
                                        print(f"   âŒ Indicator error: {e}")
                                        settings['tabs']['indicators'] = {}
                                    
                                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                    # PATTERN TAB (Candlestick)
                                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                    try:
                                        print("[Strategy] ðŸ•¯ï¸ Capturing Pattern tab...")
                                        pattern_settings = {}
                                        
                                        if hasattr(main_window_ref, 'pattern_tab') and main_window_ref.pattern_tab:
                                            pt = main_window_ref.pattern_tab
                                            if hasattr(pt, 'enable_checkbox'):
                                                pattern_settings['enabled'] = pt.enable_checkbox.isChecked()
                                            if hasattr(pt, 'min_confidence_spinbox'):
                                                pattern_settings['min_confidence'] = pt.min_confidence_spinbox.value()
                                            print(f"   âœ… Pattern: enabled={pattern_settings.get('enabled', 'N/A')}")
                                        
                                        settings['tabs']['pattern'] = pattern_settings
                                    except Exception as e:
                                        print(f"   âŒ Pattern error: {e}")
                                        settings['tabs']['pattern'] = {}
                                    
                                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                    # PRICE PATTERN TAB
                                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                    try:
                                        print("[Strategy] ðŸ“ˆ Capturing Price Pattern tab...")
                                        price_pattern_settings = {}
                                        
                                        if hasattr(main_window_ref, 'price_pattern_tab') and main_window_ref.price_pattern_tab:
                                            ppt = main_window_ref.price_pattern_tab
                                            if hasattr(ppt, 'enable_checkbox'):
                                                price_pattern_settings['enabled'] = ppt.enable_checkbox.isChecked()
                                            if hasattr(ppt, 'min_confidence_spinbox'):
                                                price_pattern_settings['min_confidence'] = ppt.min_confidence_spinbox.value()
                                            if hasattr(ppt, 'max_age_spinbox'):
                                                price_pattern_settings['max_age'] = ppt.max_age_spinbox.value()
                                            print(f"   âœ… Price Pattern: enabled={price_pattern_settings.get('enabled', 'N/A')}")
                                        
                                        settings['tabs']['price_pattern'] = price_pattern_settings
                                    except Exception as e:
                                        print(f"   âŒ Price Pattern error: {e}")
                                        settings['tabs']['price_pattern'] = {}
                                    
                                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                    # TREND TAB
                                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                    try:
                                        print("[Strategy] ðŸ“‰ Capturing Trend tab...")
                                        trend_settings = {}
                                        
                                        if hasattr(main_window_ref, 'trend_tab') and main_window_ref.trend_tab:
                                            tt = main_window_ref.trend_tab
                                            if hasattr(tt, 'enable_checkbox'):
                                                trend_settings['enabled'] = tt.enable_checkbox.isChecked()
                                            print(f"   âœ… Trend: enabled={trend_settings.get('enabled', 'N/A')}")
                                        
                                        settings['tabs']['trend'] = trend_settings
                                    except Exception as e:
                                        print(f"   âŒ Trend error: {e}")
                                        settings['tabs']['trend'] = {}
                                    
                                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                    # NEWS TAB - FULL (Currency + Impact checkboxes)
                                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                    try:
                                        print("[Strategy] ðŸ“° Capturing News tab...")
                                        news_settings = {}
                                        
                                        if hasattr(main_window_ref, 'news_tab') and main_window_ref.news_tab:
                                            nt = main_window_ref.news_tab
                                            
                                            # Main checkbox
                                            if hasattr(nt, 'use_economic_calendar_checkbox'):
                                                news_settings['use_economic_calendar'] = nt.use_economic_calendar_checkbox.isChecked()
                                            
                                            # Currency checkboxes
                                            if hasattr(nt, 'currency_checkboxes'):
                                                currency_states = {}
                                                for cb in nt.currency_checkboxes:
                                                    currency_states[cb.text()] = cb.isChecked()
                                                news_settings['currencies'] = currency_states
                                            
                                            # Impact checkboxes - use string keys for JSON compatibility
                                            if hasattr(nt, 'impact_checkboxes'):
                                                impact_states = {}
                                                for cb in nt.impact_checkboxes:
                                                    if hasattr(cb, 'impact_value'):
                                                        # Use string key because JSON converts int keys to strings
                                                        impact_states[str(cb.impact_value)] = cb.isChecked()
                                                news_settings['impacts'] = impact_states
                                            
                                            print(f"   âœ… News: calendar={news_settings.get('use_economic_calendar', 'N/A')}, currencies={len(news_settings.get('currencies', {}))}, impacts={len(news_settings.get('impacts', {}))}")
                                        
                                        settings['tabs']['news'] = news_settings
                                    except Exception as e:
                                        print(f"   âŒ News error: {e}")
                                        settings['tabs']['news'] = {}
                                    
                                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                    # SIGNAL TAB - ALL NOTIFICATION CHECKBOXES
                                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                    try:
                                        print("[Strategy] ðŸ“¡ Capturing Signal tab...")
                                        signal_settings = {}
                                        
                                        if hasattr(main_window_ref, 'signal_tab') and main_window_ref.signal_tab:
                                            st = main_window_ref.signal_tab
                                            
                                            # All possible notification checkboxes
                                            cb_widgets = [
                                                'telegram_cb', 'whatsapp_cb', 'signal_cb', 'discord_cb',
                                                'zalo_cb', 'wechat_cb', 'line_cb', 'kakaotalk_cb',
                                                'facebook_cb', 'instagram_cb', 'twitter_cb', 'linkedin_cb',
                                                'slack_cb', 'teams_cb', 'skype_cb', 'viber_cb',
                                                'email_cb', 'sms_cb', 'webhook_cb', 'pushbullet_cb',
                                                'include_technical_cb', 'include_indicators_cb', 'include_summary_cb',
                                                'include_candlestick_cb', 'include_price_patterns_cb',
                                                'track_orders_cb', 'notify_sl_tp_cb', 'notify_close_cb',
                                                'auto_notification_cb',
                                            ]
                                            for w in cb_widgets:
                                                if hasattr(st, w):
                                                    widget = getattr(st, w)
                                                    if hasattr(widget, 'isChecked'):
                                                        signal_settings[w] = widget.isChecked()
                                            
                                            print(f"   âœ… Signal: {len(signal_settings)} notification settings")
                                        
                                        settings['tabs']['signal'] = signal_settings
                                    except Exception as e:
                                        print(f"   âŒ Signal error: {e}")
                                        settings['tabs']['signal'] = {}
                                    
                                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                    # EXTERNAL CONFIG FILES
                                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                    try:
                                        print("[Strategy] ðŸ“ Capturing external configs...")
                                        
                                        # Smart entry config
                                        smart_entry_path = os.path.join(os.getcwd(), 'smart_entry_config.json')
                                        if os.path.exists(smart_entry_path):
                                            with open(smart_entry_path, 'r', encoding='utf-8') as f:
                                                settings['smart_entry'] = json.load(f)
                                            print(f"   âœ… smart_entry_config.json loaded")
                                        
                                        # Notification config
                                        notification_path = os.path.join(os.getcwd(), 'notification_config.json')
                                        if os.path.exists(notification_path):
                                            with open(notification_path, 'r', encoding='utf-8') as f:
                                                settings['notifications'] = json.load(f)
                                            print(f"   âœ… notification_config.json loaded")
                                        
                                    except Exception as e:
                                        print(f"   âš ï¸ External config error: {e}")
                                    
                                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                    # SUMMARY
                                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                    total_settings = sum(len(v) if isinstance(v, dict) else 0 for v in settings['tabs'].values())
                                    print(f"\n[Strategy] âœ… Capture complete! Total: {total_settings} settings from {len(settings['tabs'])} tabs")
                                    
                                    return settings
                                    
                                except Exception as e:
                                    print(f"[Strategy] âŒ Error capturing settings: {e}")
                                    import traceback
                                    traceback.print_exc()
                                    return {'error': str(e)}
                            
                            def apply_strategy_settings(self, settings):
                                """Apply ALL strategy settings - COMPREHENSIVE VERSION 4.0"""
                                try:
                                    print(f"\n[Strategy] ðŸš€ Applying strategy settings (v4.0 - COMPLETE)...")
                                    
                                    main_window_ref = getattr(self, 'main_window_ref', None)
                                    if not main_window_ref:
                                        print("[Strategy] âŒ CRITICAL: Cannot find main window reference!")
                                        return False
                                    
                                    if 'tabs' not in settings:
                                        print("[Strategy] âŒ No tabs settings found!")
                                        return False
                                    
                                    success_count = 0
                                    
                                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                    # APPLY RISK MANAGEMENT TAB
                                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                    try:
                                        if 'risk_management' in settings['tabs']:
                                            print("[Strategy] ðŸ›¡ï¸ Applying Risk Management...")
                                            rs = settings['tabs']['risk_management']
                                        
                                            if hasattr(main_window_ref, 'risk_tab') and main_window_ref.risk_tab:
                                                rt = main_window_ref.risk_tab
                                                
                                                # Disable auto-save during restoration
                                                old_init_flag = getattr(rt, '_is_initializing', False)
                                                rt._is_initializing = True
                                                
                                                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                                # STEP 1: Apply MODE COMBOS FIRST (triggers UI updates)
                                                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                                mode_combos = ['volume_mode_combo', 'sltp_mode_combo', 'dca_mode_combo']
                                                for key in mode_combos:
                                                    if key in rs and hasattr(rt, key):
                                                        try:
                                                            widget = getattr(rt, key)
                                                            widget.setCurrentText(str(rs[key]))
                                                            success_count += 1
                                                        except Exception as e:
                                                            print(f"   âš ï¸ Mode.{key} error: {e}")
                                                
                                                # Trigger UI updates AFTER setting modes
                                                try:
                                                    if hasattr(rt, 'update_volume_fields_visibility'):
                                                        rt.update_volume_fields_visibility()
                                                    if hasattr(rt, 'update_sltp_mode_controls'):
                                                        rt.update_sltp_mode_controls()
                                                    if hasattr(rt, 'update_dca_mode_controls'):
                                                        rt.update_dca_mode_controls()
                                                except:
                                                    pass
                                                
                                                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                                # STEP 2: Apply ALL OTHER settings (spins, combos, checkboxes)
                                                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                                for key, value in rs.items():
                                                    if key.endswith('_idx'):
                                                        continue  # Skip index keys, use text keys
                                                    if key in ['symbol_exposure', 'symbol_multipliers']:
                                                        continue  # Handle separately below
                                                    if key in mode_combos:
                                                        continue  # Already applied above
                                                    try:
                                                        if hasattr(rt, key):
                                                            widget = getattr(rt, key)
                                                            if hasattr(widget, 'setValue'):
                                                                # Check if it's QSpinBox (int) or QDoubleSpinBox (float)
                                                                if isinstance(widget, QSpinBox):
                                                                    widget.setValue(int(value))
                                                                else:
                                                                    widget.setValue(float(value))
                                                                success_count += 1
                                                            elif hasattr(widget, 'setCurrentText'):
                                                                widget.setCurrentText(str(value))
                                                                success_count += 1
                                                            elif hasattr(widget, 'setChecked'):
                                                                widget.setChecked(bool(value))
                                                                success_count += 1
                                                    except Exception as e:
                                                        print(f"   âš ï¸ Risk.{key} error: {e}")
                                                
                                                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                                # STEP 3: RESTORE SYMBOL EXPOSURE TABLE
                                                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                                if 'symbol_exposure' in rs or 'symbol_multipliers' in rs:
                                                    try:
                                                        # Update settings dict first
                                                        if 'symbol_exposure' in rs:
                                                            rt.settings['symbol_exposure'] = dict(rs['symbol_exposure'])
                                                        if 'symbol_multipliers' in rs:
                                                            rt.settings['symbol_multipliers'] = dict(rs['symbol_multipliers'])
                                                        
                                                        # IMPORTANT: Also update available_symbols to match saved data
                                                        # This ensures the table will show all symbols that were saved
                                                        saved_symbols = list(rs.get('symbol_exposure', {}).keys())
                                                        if saved_symbols:
                                                            # Merge with existing available_symbols
                                                            current_symbols = set(getattr(rt, 'available_symbols', []) or [])
                                                            merged_symbols = list(current_symbols.union(set(saved_symbols)))
                                                            rt.available_symbols = merged_symbols
                                                            print(f"   ðŸ“Š Updated available_symbols: {merged_symbols}")
                                                        
                                                        # Repopulate the exposure table with new values
                                                        if hasattr(rt, 'populate_exposure_table'):
                                                            rt.populate_exposure_table()
                                                            print(f"   ðŸ“Š Restored {len(rs.get('symbol_exposure', {}))} symbol exposures")
                                                            success_count += len(rs.get('symbol_exposure', {}))
                                                    except Exception as e:
                                                        print(f"   âš ï¸ Symbol exposure restore error: {e}")
                                                
                                                # Restore auto-save flag
                                                rt._is_initializing = old_init_flag
                                                
                                                # Save to risk_settings.json file
                                                try:
                                                    if hasattr(rt, 'save_risk_settings'):
                                                        rt.save_risk_settings()
                                                        print("   ðŸ’¾ Saved to risk_settings.json")
                                                except:
                                                    pass
                                                
                                                print(f"   âœ… Risk Management: {success_count} settings applied")
                                            else:
                                                print("[Strategy] âš ï¸ risk_tab is None")
                                        else:
                                            print("[Strategy] âš ï¸ risk_management not in settings['tabs']")
                                    except Exception as e:
                                        print(f"[Strategy] âŒ Risk Management apply error: {e}")
                                        import traceback
                                        traceback.print_exc()
                                    
                                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                    # APPLY MARKET TAB - SYMBOLS & TIMEFRAMES
                                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                    if 'market' in settings['tabs']:
                                        print("[Strategy] ðŸ’¹ Applying Market tab...")
                                        ms = settings['tabs']['market']
                                        
                                        if hasattr(main_window_ref, 'market_tab') and main_window_ref.market_tab:
                                            mt = main_window_ref.market_tab
                                            
                                            # Apply timeframe settings
                                            if 'timeframes' in ms:
                                                if hasattr(mt, 'tf_checkboxes') and hasattr(mt, 'tf_spinboxes'):
                                                    for tf_name, tf_data in ms['timeframes'].items():
                                                        try:
                                                            if tf_name in mt.tf_checkboxes:
                                                                mt.tf_checkboxes[tf_name].setChecked(tf_data.get('enabled', False))
                                                                success_count += 1
                                                            if tf_name in mt.tf_spinboxes:
                                                                mt.tf_spinboxes[tf_name].setValue(tf_data.get('candles', 5000))
                                                                success_count += 1
                                                        except:
                                                            pass
                                            
                                            # Restore checked symbols - update the set and check items in list
                                            if 'checked_symbols' in ms:
                                                saved_symbols = set(ms['checked_symbols'])
                                                mt.checked_symbols = saved_symbols.copy()
                                                
                                                # Update symbol list checkboxes
                                                if hasattr(mt, 'symbol_list') and mt.symbol_list:
                                                    for i in range(mt.symbol_list.count()):
                                                        item = mt.symbol_list.item(i)
                                                        if item:
                                                            symbol_text = item.text().split()[0] if ' ' in item.text() else item.text()
                                                            if symbol_text in saved_symbols:
                                                                item.setCheckState(Qt.Checked)
                                                            else:
                                                                item.setCheckState(Qt.Unchecked)
                                                
                                                print(f"   ðŸ“Œ Restored {len(saved_symbols)} symbols: {list(saved_symbols)[:5]}...")
                                                success_count += len(saved_symbols)
                                            
                                            # Restore chart settings
                                            if 'chart_symbol' in ms and hasattr(mt, 'chart_symbol_combo'):
                                                mt.chart_symbol_combo.setCurrentText(ms['chart_symbol'])
                                            if 'chart_timeframe' in ms and hasattr(mt, 'chart_timeframe_combo'):
                                                mt.chart_timeframe_combo.setCurrentText(ms['chart_timeframe'])
                                            
                                            print(f"   âœ… Market tab applied")
                                    
                                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                    # APPLY INDICATOR TAB - COMPATIBLE WITH restore_user_config
                                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                    if 'indicators' in settings['tabs']:
                                        print("[Strategy] ðŸ“Š Applying Indicator tab...")
                                        ind_s = settings['tabs']['indicators']
                                        
                                        if hasattr(main_window_ref, 'indicator_tab') and main_window_ref.indicator_tab:
                                            it = main_window_ref.indicator_tab
                                            
                                            # Apply indicator rows using same logic as restore_user_config
                                            if 'indicator_rows' in ind_s and hasattr(it, 'indicator_rows'):
                                                try:
                                                    # Clear existing rows
                                                    while it.indicator_rows:
                                                        it.remove_indicator_row(it.indicator_rows[0])
                                                    
                                                    # Add saved rows with all parameters
                                                    for indi in ind_s['indicator_rows']:
                                                        it.add_indicator_row()
                                                        if not it.indicator_rows:
                                                            continue
                                                        
                                                        row = it.indicator_rows[-1]
                                                        combo = row["indi_combo"]
                                                        
                                                        # Find indicator by label (or name as fallback)
                                                        idx = combo.findText(indi.get("label", indi.get("name", "")))
                                                        if idx >= 0:
                                                            combo.setCurrentIndex(idx)
                                                            # Trigger on_indicator_changed to create param widgets
                                                            it.on_indicator_changed(idx, row)
                                                        
                                                        # Apply params using same logic as restore_user_config
                                                        params = indi.get("params", {})
                                                        for param_name, value in params.items():
                                                            widget_name = f"{param_name}_spin"
                                                            if widget_name in row:
                                                                try:
                                                                    row[widget_name].setValue(value)
                                                                except:
                                                                    pass
                                                            elif param_name == "ma_type" and "ma_type_combo" in row:
                                                                idx2 = row["ma_type_combo"].findText(str(value))
                                                                if idx2 >= 0:
                                                                    row["ma_type_combo"].setCurrentIndex(idx2)
                                                        
                                                        print(f"   ðŸ“ˆ Restored: {indi.get('name', 'Unknown')} with {len(params)} params")
                                                        success_count += 1
                                                    
                                                    # Save the restored config and update whitelist
                                                    try:
                                                        it.save_current_user_config()
                                                        it._persist_indicator_whitelist()
                                                        it.update_toggle_button()
                                                    except:
                                                        pass
                                                    
                                                except Exception as e:
                                                    print(f"   âš ï¸ Indicator rows error: {e}")
                                                    import traceback
                                                    traceback.print_exc()
                                            
                                            print(f"   âœ… Indicator tab applied: {len(ind_s.get('indicator_rows', []))} indicators")
                                    
                                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                    # APPLY PATTERN TAB (Candlestick)
                                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                    if 'pattern' in settings['tabs']:
                                        print("[Strategy] ðŸ•¯ï¸ Applying Pattern tab...")
                                        ps = settings['tabs']['pattern']
                                        
                                        if hasattr(main_window_ref, 'pattern_tab') and main_window_ref.pattern_tab:
                                            pt = main_window_ref.pattern_tab
                                            if 'enabled' in ps and hasattr(pt, 'enable_checkbox'):
                                                pt.enable_checkbox.setChecked(ps['enabled'])
                                                success_count += 1
                                            if 'min_confidence' in ps and hasattr(pt, 'min_confidence_spinbox'):
                                                pt.min_confidence_spinbox.setValue(ps['min_confidence'])
                                                success_count += 1
                                            print(f"   âœ… Pattern tab applied")
                                    
                                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                    # APPLY PRICE PATTERN TAB
                                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                    if 'price_pattern' in settings['tabs']:
                                        print("[Strategy] ðŸ“ˆ Applying Price Pattern tab...")
                                        pps = settings['tabs']['price_pattern']
                                        
                                        if hasattr(main_window_ref, 'price_pattern_tab') and main_window_ref.price_pattern_tab:
                                            ppt = main_window_ref.price_pattern_tab
                                            if 'enabled' in pps and hasattr(ppt, 'enable_checkbox'):
                                                ppt.enable_checkbox.setChecked(pps['enabled'])
                                                success_count += 1
                                            if 'min_confidence' in pps and hasattr(ppt, 'min_confidence_spinbox'):
                                                ppt.min_confidence_spinbox.setValue(pps['min_confidence'])
                                                success_count += 1
                                            if 'max_age' in pps and hasattr(ppt, 'max_age_spinbox'):
                                                ppt.max_age_spinbox.setValue(pps['max_age'])
                                                success_count += 1
                                            print(f"   âœ… Price Pattern tab applied")
                                    
                                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                    # APPLY TREND TAB
                                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                    if 'trend' in settings['tabs']:
                                        print("[Strategy] ðŸ“‰ Applying Trend tab...")
                                        ts = settings['tabs']['trend']
                                        
                                        if hasattr(main_window_ref, 'trend_tab') and main_window_ref.trend_tab:
                                            tt = main_window_ref.trend_tab
                                            if 'enabled' in ts and hasattr(tt, 'enable_checkbox'):
                                                tt.enable_checkbox.setChecked(ts['enabled'])
                                                success_count += 1
                                            print(f"   âœ… Trend tab applied")
                                    
                                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                    # APPLY NEWS TAB - FULL (Currencies + Impacts)
                                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                    if 'news' in settings['tabs']:
                                        print("[Strategy] ðŸ“° Applying News tab...")
                                        ns = settings['tabs']['news']
                                        
                                        if hasattr(main_window_ref, 'news_tab') and main_window_ref.news_tab:
                                            nt = main_window_ref.news_tab
                                            
                                            # Main checkbox
                                            if 'use_economic_calendar' in ns and hasattr(nt, 'use_economic_calendar_checkbox'):
                                                nt.use_economic_calendar_checkbox.setChecked(ns['use_economic_calendar'])
                                                success_count += 1
                                            
                                            # Currency checkboxes
                                            if 'currencies' in ns and hasattr(nt, 'currency_checkboxes'):
                                                for cb in nt.currency_checkboxes:
                                                    if cb.text() in ns['currencies']:
                                                        cb.setChecked(ns['currencies'][cb.text()])
                                                        success_count += 1
                                            
                                            # Impact checkboxes - handle both int and string keys
                                            if 'impacts' in ns and hasattr(nt, 'impact_checkboxes'):
                                                for cb in nt.impact_checkboxes:
                                                    if hasattr(cb, 'impact_value'):
                                                        # Try both string key (from JSON) and int key
                                                        impact_key = str(cb.impact_value)
                                                        if impact_key in ns['impacts']:
                                                            cb.setChecked(ns['impacts'][impact_key])
                                                            success_count += 1
                                                        elif cb.impact_value in ns['impacts']:
                                                            cb.setChecked(ns['impacts'][cb.impact_value])
                                                            success_count += 1
                                            
                                            print(f"   âœ… News tab applied")
                                    
                                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                    # APPLY SIGNAL TAB
                                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                    if 'signal' in settings['tabs']:
                                        print("[Strategy] ðŸ“¡ Applying Signal tab...")
                                        ss = settings['tabs']['signal']
                                        
                                        if hasattr(main_window_ref, 'signal_tab') and main_window_ref.signal_tab:
                                            st = main_window_ref.signal_tab
                                            
                                            for key, value in ss.items():
                                                try:
                                                    if hasattr(st, key):
                                                        widget = getattr(st, key)
                                                        if hasattr(widget, 'setChecked'):
                                                            widget.setChecked(bool(value))
                                                            success_count += 1
                                                except:
                                                    pass
                                            
                                            print(f"   âœ… Signal tab applied")
                                    
                                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                    # APPLY EXTERNAL CONFIG FILES
                                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                    try:
                                        if 'smart_entry' in settings:
                                            smart_entry_path = os.path.join(os.getcwd(), 'smart_entry_config.json')
                                            with open(smart_entry_path, 'w', encoding='utf-8') as f:
                                                json.dump(settings['smart_entry'], f, indent=4, ensure_ascii=False)
                                            print("[Strategy] âœ… smart_entry_config.json restored")
                                        
                                        if 'notifications' in settings:
                                            notification_path = os.path.join(os.getcwd(), 'notification_config.json')
                                            with open(notification_path, 'w', encoding='utf-8') as f:
                                                json.dump(settings['notifications'], f, indent=4, ensure_ascii=False)
                                            print("[Strategy] âœ… notification_config.json restored")
                                    except Exception as e:
                                        print(f"[Strategy] âš ï¸ External config restore error: {e}")
                                    
                                    print(f"\n[Strategy] âœ… Apply complete! {success_count} settings applied")
                                    return success_count > 0
                                    
                                except Exception as e:
                                    print(f"[Strategy] âŒ Error applying settings: {e}")
                                    import traceback
                                    traceback.print_exc()
                                    return False
                            
                            def load_strategies(self):
                                """Load saved strategies from file"""
                                self.strategy_list.clear()
                                try:
                                    if os.path.exists(self.strategies_file):
                                        with open(self.strategies_file, 'r', encoding='utf-8') as f:
                                            strategies = json.load(f)
                                            for name, data in strategies.items():
                                                timestamp = data.get('timestamp', 'Unknown')
                                                item_text = f"{name} ({timestamp[:19]})"
                                                self.strategy_list.addItem(item_text)
                                    else:
                                        self.strategy_list.addItem(I18N.t("No strategies saved yet", "ChÆ°a cÃ³ chiáº¿n lÆ°á»£c nÃ o Ä‘Æ°á»£c lÆ°u"))
                                except Exception as e:
                                    print(f"[Strategy] Error loading strategies: {e}")
                            
                            def create_new_strategy(self):
                                """Create new strategy from current settings"""
                                try:
                                    name, ok = QInputDialog.getText(
                                        self, 
                                        I18N.t("Create Strategy", "Táº¡o Chiáº¿n lÆ°á»£c"),
                                        I18N.t("Enter strategy name:", "Nháº­p tÃªn chiáº¿n lÆ°á»£c:")
                                    )
                                    
                                    if ok and name.strip():
                                        name = name.strip()
                                        
                                        # Load existing strategies
                                        strategies = {}
                                        if os.path.exists(self.strategies_file):
                                            with open(self.strategies_file, 'r', encoding='utf-8') as f:
                                                strategies = json.load(f)
                                        
                                        # Check if strategy already exists
                                        if name in strategies:
                                            reply = QMessageBox.question(
                                                self,
                                                I18N.t("Confirm Overwrite", "XÃ¡c nháº­n Ghi Ä‘Ã¨"),
                                                I18N.t("Strategy '{name}' already exists. Do you want to overwrite it?", "Chiáº¿n lÆ°á»£c '{name}' Ä‘Ã£ tá»“n táº¡i. Báº¡n cÃ³ muá»‘n ghi Ä‘Ã¨ khÃ´ng?", name=name),
                                                QMessageBox.Yes | QMessageBox.No
                                            )
                                            if reply != QMessageBox.Yes:
                                                return
                                        
                                        # Get current settings
                                        settings = self.get_current_strategy_settings()
                                        
                                        # Add new strategy
                                        strategies[name] = settings
                                        
                                        # Save strategies
                                        with open(self.strategies_file, 'w', encoding='utf-8') as f:
                                            json.dump(strategies, f, indent=4, ensure_ascii=False)
                                        
                                        # Refresh list
                                        self.load_strategies()
                                        
                                        QMessageBox.information(
                                            self,
                                            I18N.t("Success", "ThÃ nh cÃ´ng"),
                                            I18N.t("Strategy '{name}' created successfully!", "Chiáº¿n lÆ°á»£c '{name}' Ä‘Ã£ Ä‘Æ°á»£c táº¡o thÃ nh cÃ´ng!", name=name)
                                        )
                                        
                                except Exception as e:
                                    print(f"[Strategy] Error creating strategy: {e}")
                                    QMessageBox.critical(
                                        self,
                                        I18N.t("Error", "Lá»—i"),
                                        I18N.t("Failed to create strategy", "KhÃ´ng thá»ƒ táº¡o chiáº¿n lÆ°á»£c")
                                    )
                            
                            def load_selected_strategy(self):
                                """Load selected strategy"""
                                try:
                                    current_item = self.strategy_list.currentItem()
                                    if not current_item:
                                        return
                                    
                                    # Extract strategy name from item text
                                    item_text = current_item.text()
                                    
                                    # Skip placeholder item
                                    if "No strategies" in item_text or "ChÆ°a cÃ³ chiáº¿n lÆ°á»£c" in item_text:
                                        QMessageBox.information(
                                            self,
                                            I18N.t("Info", "ThÃ´ng bÃ¡o"),
                                            I18N.t("No strategy to load. Please create one first.", "KhÃ´ng cÃ³ chiáº¿n lÆ°á»£c Ä‘á»ƒ táº£i. Vui lÃ²ng táº¡o má»™t chiáº¿n lÆ°á»£c trÆ°á»›c.")
                                        )
                                        return
                                    if "(" in item_text:
                                        strategy_name = item_text.split(" (")[0]
                                    else:
                                        strategy_name = item_text
                                    
                                    # Load strategies file
                                    if os.path.exists(self.strategies_file):
                                        with open(self.strategies_file, 'r', encoding='utf-8') as f:
                                            strategies = json.load(f)
                                        
                                        if strategy_name in strategies:
                                            # Apply strategy settings
                                            success = self.apply_strategy_settings(strategies[strategy_name])
                                            
                                            if success:
                                                QMessageBox.information(
                                                    self,
                                                    I18N.t("Success", "ThÃ nh cÃ´ng"),
                                                    I18N.t("Strategy '{name}' loaded successfully!", "Chiáº¿n lÆ°á»£c '{name}' Ä‘Ã£ Ä‘Æ°á»£c táº£i thÃ nh cÃ´ng!", name=strategy_name)
                                                )
                                                self.close()
                                            else:
                                                QMessageBox.warning(
                                                    self,
                                                    I18N.t("Warning", "Cáº£nh bÃ¡o"),
                                                    I18N.t("Strategy loaded with some errors", "Chiáº¿n lÆ°á»£c Ä‘Æ°á»£c táº£i nhÆ°ng cÃ³ má»™t sá»‘ lá»—i")
                                                )
                                        else:
                                            QMessageBox.warning(
                                                self,
                                                I18N.t("Error", "Lá»—i"),
                                                I18N.t("Strategy not found", "KhÃ´ng tÃ¬m tháº¥y chiáº¿n lÆ°á»£c")
                                            )
                                    
                                except Exception as e:
                                    print(f"[Strategy] Error loading strategy: {e}")
                                    QMessageBox.critical(
                                        self,
                                        I18N.t("Error", "Lá»—i"),
                                        I18N.t("Failed to load strategy", "KhÃ´ng thá»ƒ táº£i chiáº¿n lÆ°á»£c")
                                    )
                            
                            def delete_selected_strategy(self):
                                """Delete selected strategy"""
                                try:
                                    current_item = self.strategy_list.currentItem()
                                    if not current_item:
                                        return
                                    
                                    # Extract strategy name
                                    item_text = current_item.text()
                                    
                                    # Skip placeholder item
                                    if "No strategies" in item_text or "ChÆ°a cÃ³ chiáº¿n lÆ°á»£c" in item_text:
                                        return
                                    
                                    if "(" in item_text:
                                        strategy_name = item_text.split(" (")[0]
                                    else:
                                        strategy_name = item_text
                                    
                                    # Confirm deletion
                                    reply = QMessageBox.question(
                                        self,
                                        I18N.t("Confirm Delete", "XÃ¡c nháº­n XÃ³a"),
                                        I18N.t("Are you sure you want to delete strategy '{name}'?", "Báº¡n cÃ³ cháº¯c muá»‘n xÃ³a chiáº¿n lÆ°á»£c '{name}'?", name=strategy_name),
                                        QMessageBox.Yes | QMessageBox.No
                                    )
                                    
                                    if reply == QMessageBox.Yes:
                                        # Load and update strategies
                                        if os.path.exists(self.strategies_file):
                                            with open(self.strategies_file, 'r', encoding='utf-8') as f:
                                                strategies = json.load(f)
                                            
                                            if strategy_name in strategies:
                                                del strategies[strategy_name]
                                                
                                                # Save updated strategies
                                                with open(self.strategies_file, 'w', encoding='utf-8') as f:
                                                    json.dump(strategies, f, indent=4, ensure_ascii=False)
                                                
                                                # Refresh list
                                                self.load_strategies()
                                                
                                                QMessageBox.information(
                                                    self,
                                                    I18N.t("Success", "ThÃ nh cÃ´ng"),
                                                    I18N.t("Strategy deleted successfully!", "Chiáº¿n lÆ°á»£c Ä‘Ã£ Ä‘Æ°á»£c xÃ³a thÃ nh cÃ´ng!")
                                                )
                                
                                except Exception as e:
                                    print(f"[Strategy] Error deleting strategy: {e}")
                                    QMessageBox.critical(
                                        self,
                                        I18N.t("Error", "Lá»—i"),
                                        I18N.t("Failed to delete strategy", "KhÃ´ng thá»ƒ xÃ³a chiáº¿n lÆ°á»£c")
                                    )
                        
                        # Show dialog
                        dialog = StrategyManagerDialog(main_window)
                        dialog.exec_()
                        
                    except Exception as e:
                        print(f"[Strategy] Error opening strategy manager: {e}")
                        from PyQt5.QtWidgets import QMessageBox
                        QMessageBox.critical(
                            main_window,
                            "Error",
                            f"Failed to open strategy manager: {str(e)}"
                        )

                # Hook language toggles to AppState and refresh open views
                def _apply_language(lang_code: str):
                    print(f"[LangSwitch] Switching to: {lang_code}")
                    AppState.set_language(lang_code)
                    try:
                        print(f"[LangSwitch] Current stored language: {AppState.language()}")
                        # Retranslate menu and actions
                        lang_menu.setTitle(I18N.t("Language", "NgÃ´n ngá»¯"))
                        act_strategy.setText(I18N.t("Trading Strategy", "Chiáº¿n lÆ°á»£c giao dá»‹ch"))
                        act_support.setText(I18N.t("Support", "Há»— trá»£"))
                        act_pricing.setText(I18N.t("ðŸ’° Pricing", "ðŸ’° Báº£ng GiÃ¡"))
                        
                        # Cáº­p nháº­t menu user náº¿u Ä‘Ã£ Ä‘Äƒng nháº­p
                        if hasattr(main_window, 'update_menu_for_user') and hasattr(main_window, 'logged_in_user'):
                            main_window.update_menu_for_user(main_window.logged_in_user)
                        lang_en.setText(I18N.t("English", "English"))
                        lang_vi.setText(I18N.t("Vietnamese", "Tiáº¿ng Viá»‡t"))
                        menu_btn.setToolTip(I18N.t("Menu", "TrÃ¬nh Ä‘Æ¡n"))
                        # Update window & header title (keep same English brand, optional suffix in VI)
                        title_txt = I18N.t("ChatGPT AI BOT 4.3.2", "ChatGPT AI BOT 4.3.2")
                        try:
                            main_window.setWindowTitle(title_txt)
                            app_title.setText(title_txt)
                        except Exception:
                            pass

                        # Retranslate tab titles
                        tab_widget.setTabText(0, I18N.t("ðŸ¦ MT5 Account", "ðŸ¦ TÃ i khoáº£n MT5"))
                        tab_widget.setTabText(1, I18N.t("ðŸ’¹ Market Data", "ðŸ’¹ Dá»¯ liá»‡u thá»‹ trÆ°á»ng"))
                        tab_widget.setTabText(2, I18N.t("ðŸ“ˆ Trend Analysis", "ðŸ“ˆ PhÃ¢n tÃ­ch xu hÆ°á»›ng"))
                        tab_widget.setTabText(3, I18N.t("âš™ï¸ Technical Indicators", "âš™ï¸ Chá»‰ bÃ¡o ká»¹ thuáº­t"))
                        tab_widget.setTabText(4, I18N.t("ðŸ•¯ï¸ Candlestick Patterns", "ðŸ•¯ï¸ MÃ´ hÃ¬nh náº¿n"))
                        tab_widget.setTabText(5, I18N.t("ðŸ“Š Price Patterns", "ðŸ“Š MÃ´ hÃ¬nh giÃ¡"))
                        tab_widget.setTabText(6, I18N.t("ðŸ“° Economic News", "ðŸ“° Tin tá»©c kinh táº¿"))
                        tab_widget.setTabText(7, I18N.t("ðŸ›¡ï¸ Risk Management", "ðŸ›¡ï¸ Quáº£n lÃ½ rá»§i ro"))
                        tab_widget.setTabText(8, I18N.t("ðŸ“¡ Signal", "ðŸ“¡ TÃ­n hiá»‡u"))
                        tab_widget.setTabText(9, I18N.t("ðŸ¤– Auto Trading", "ðŸ¤– Giao dá»‹ch tá»± Ä‘á»™ng"))
                        # Force apply Vietnamese titles if needed (diagnostic)
                        if AppState.language() == 'vi':
                            vn_titles = [
                                "ðŸ¦ TÃ i khoáº£n MT5","ðŸ’¹ Dá»¯ liá»‡u thá»‹ trÆ°á»ng","ðŸ“ˆ PhÃ¢n tÃ­ch xu hÆ°á»›ng",
                                "âš™ï¸ Chá»‰ bÃ¡o ká»¹ thuáº­t","ðŸ•¯ï¸ MÃ´ hÃ¬nh náº¿n","ðŸ“Š MÃ´ hÃ¬nh giÃ¡",
                                "ðŸ“° Tin tá»©c kinh táº¿","ðŸ›¡ï¸ Quáº£n lÃ½ rá»§i ro","ðŸ“¡ TÃ­n hiá»‡u","ðŸ¤– Giao dá»‹ch tá»± Ä‘á»™ng"
                            ]
                            for idx, txt in enumerate(vn_titles):
                                try:
                                    tab_widget.setTabText(idx, txt)
                                except Exception:
                                    pass
                            print("[LangSwitch] Forced VN tab titles committed")

                        # Retranslate Signal tab UI
                        try:
                            signal_tab.retranslate_ui()
                        except Exception:
                            pass

                        # Refresh News tab for language change
                        try:
                            if hasattr(news_tab, 'refresh_all_labels'):
                                news_tab.refresh_all_labels()
                            elif hasattr(news_tab, 'refresh_impact_labels'):
                                news_tab.refresh_impact_labels()
                        except Exception as e:
                            print(f"[LangSwitch] News tab refresh error: {e}")

                        # Refresh risk tab localized labels
                        try:
                            if hasattr(risk_tab, 'refresh_translations'):
                                risk_tab.refresh_translations()
                            # Legacy DCA refresh (kept for backward compatibility, no-op after removals)
                            if hasattr(risk_tab, 'refresh_dca_labels'):
                                risk_tab.refresh_dca_labels()
                        except Exception as e:
                            print(f"[LangSwitch] Risk tab refresh error: {e}")

                        # ðŸ†• Refresh Pattern tabs
                        try:
                            if hasattr(pattern_tab, 'refresh_translations'):
                                pattern_tab.refresh_translations()
                        except Exception as e:
                            print(f"[LangSwitch] Pattern tab refresh error: {e}")
                        
                        try:
                            if hasattr(price_pattern_tab, 'refresh_translations'):
                                price_pattern_tab.refresh_translations()
                        except Exception as e:
                            print(f"[LangSwitch] Price pattern tab refresh error: {e}")
                        
                        # ðŸ†• Refresh Trend tab
                        try:
                            if hasattr(trend_tab, 'refresh_translations'):
                                trend_tab.refresh_translations()
                        except Exception as e:
                            print(f"[LangSwitch] Trend tab refresh error: {e}")

                        # ðŸ†• Refresh Auto Trading tab
                        try:
                            if hasattr(auto_trading_tab, 'refresh_translations'):
                                auto_trading_tab.refresh_translations()
                        except Exception as e:
                            print(f"[LangSwitch] Auto Trading tab refresh error: {e}")

                        # Broad pass: update common static texts in the whole window
                        try:
                            I18N.retranslate_widget_tree(main_window)
                            # Also translate any other top-level dialogs / windows
                            I18N.translate_application()
                            # Aggressive fallback pass
                            I18N.force_full_translation(main_window, debug=True)
                        except Exception:
                            pass
                        
                        # Debug log tab titles after language switch
                        try:
                            if hasattr(main_window, 'debug_tab_widget'):
                                tw = main_window.debug_tab_widget
                                with open("debug_language_switch.txt", "w", encoding="utf-8") as f:
                                    f.write(f"=== LANGUAGE SWITCH TO: {lang_code} ===\n")
                                    for i in range(tw.count()):
                                        f.write(f"Tab {i}: '{tw.tabText(i)}'\n")
                                print(f"DEBUG: Language switch logged to debug_language_switch.txt")
                        except Exception as e:
                            print(f"DEBUG: Language switch logging error: {e}")
                        # Update dynamic indicator row buttons to match language
                        try:
                            indicator_tab.apply_language_to_indicator_rows()
                        except Exception:
                            pass
                        # Sample debug: find a known label text
                        try:
                            from PyQt5.QtWidgets import QApplication, QLabel
                            app_inst = QApplication.instance()
                            sample_found = False
                            for w in app_inst.allWidgets():
                                if isinstance(w, QLabel):
                                    txt = w.text()
                                    if 'Volume:' in txt or 'Khá»‘i lÆ°á»£ng:' in txt:
                                        print(f"[LangDebug] Volume label => {txt}")
                                        sample_found = True
                                        break
                            if not sample_found:
                                print("[LangDebug] Volume label NOT found in scan")
                        except Exception:
                            pass

                        # Ensure GUI processes pending repaint events
                        try:
                            from PyQt5.QtWidgets import QApplication
                            QApplication.processEvents()
                        except Exception:
                            pass

                        signal_tab.load_actions_text()
                        # ðŸ†• Update notification preview when language changes
                        try:
                            if hasattr(signal_tab, '_update_preview'):
                                signal_tab._update_preview()
                        except Exception as e:
                            print(f"[LangSwitch] Preview update error: {e}")
                        # refresh selected report, if any
                        sel = signal_tab.sig_table.currentRow()
                        if sel >= 0:
                            it = signal_tab.sig_table.item(sel, 0)
                            if it:
                                signal_tab.load_latest_report(it.text())
                    except Exception:
                        pass
                # Connect strategy management trigger
                act_strategy.triggered.connect(_open_strategy_manager)
                
                # Connect Login and Register actions
                def _open_login_dialog():
                    try:
                        dialog = LoginDialog(main_window)
                        dialog.exec_()
                    except Exception as e:
                        print(f"[Login] Error opening login dialog: {e}")

                def _open_register_dialog():
                    try:
                        dialog = RegisterDialog(main_window)
                        dialog.exec_()
                    except Exception as e:
                        print(f"[Register] Error opening register dialog: {e}")
                
                # Ensure exclusivity & direct connections (more reliable than group triggered logic)
                try:
                    lang_group.setExclusive(True)
                except Exception:
                    pass
                lang_en.triggered.connect(lambda: _apply_language('en'))
                lang_vi.triggered.connect(lambda: _apply_language('vi'))

                # Apply restored language once after full UI build (if not EN)
                if AppState.language() != 'en':
                    _apply_language(AppState.language())

                # Register graceful shutdown of threads
                try:
                    def _on_about_to_quit():
                        try:
                            print("ðŸ›‘ App shutting down - stopping all threads...")
                            candidates = []
                        
                            # Get tab references from main_window
                            if hasattr(main_window, 'all_tabs'):
                                candidates.extend(main_window.all_tabs.values())
                                print(f"ðŸ” Found {len(candidates)} tabs to check for threads")
                        
                            # Also include main_window itself for any direct thread references
                            candidates.append(main_window)
                        
                            graceful_shutdown_threads(candidates)
                            print("âœ… Graceful shutdown completed")
                        except Exception as _e:
                            print(f"âš ï¸ graceful shutdown hook error: {_e}")
                    app.aboutToQuit.connect(_on_about_to_quit)
                except Exception:
                    pass

                # Start event loop
                print("ðŸš€ Starting main event loop...")
                app.exec_()
                print("âœ… Event loop completed")
                
            except Exception as e:
                print(f"âŒ GUI failed to start: {e}")
                import traceback
                traceback.print_exc()
            
    except Exception as main_error:
        print(f"ðŸš¨ CRITICAL ERROR in main(): {type(main_error).__name__}: {str(main_error)}")
        print("ðŸ›¡ï¸ Anti-crash system activated - saving error and continuing...")
        
        # Log critical error
        try:
            crash_log = f"logs/main_crash_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log"
            os.makedirs("logs", exist_ok=True)
            with open(crash_log, 'w', encoding='utf-8') as f:
                f.write(f"Main Function Crash: {datetime.now()}\n")
                f.write(f"Error: {type(main_error).__name__}: {str(main_error)}\n\n")
                f.write("Traceback:\n")
                traceback.print_exc(file=f)
            print(f"ðŸ’¾ Main crash log saved: {crash_log}")
        except:
            print("âŒ Could not save crash log, but continuing anyway...")
        
        # Continue execution instead of crashing
        print("ðŸ”„ Attempting to continue despite error...")

def main():
    """Ultra-safe main function with comprehensive crash protection"""
    try:
        print("ðŸ›¡ï¸ Trading Bot Starting with Anti-Crash Protection...")
        main_original()
    except Exception as e:
        print(f"ðŸš¨ MAIN FUNCTION CRASH: {type(e).__name__}: {str(e)}")
        print("ðŸ›¡ï¸ Anti-crash system activated - app will continue running...")
        
        # Log the crash
        try:
            crash_log = f"logs/main_crash_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log"
            os.makedirs("logs", exist_ok=True)
            with open(crash_log, 'w', encoding='utf-8') as f:
                f.write(f"Main Function Crash: {datetime.now()}\n")
                f.write(f"Error: {type(e).__name__}: {str(e)}\n\n")
                f.write("Traceback:\n")
                traceback.print_exc(file=f)
            print(f"ðŸ’¾ Crash log saved: {crash_log}")
        except:
            pass
        
        # Try emergency recovery
        try:
            print("ðŸ”„ Attempting emergency recovery...")
            if GUI_AVAILABLE:
                print("ðŸ“± Starting minimal GUI...")
                from PyQt5.QtWidgets import QApplication, QWidget, QLabel, QVBoxLayout
                app = QApplication([])
                window = QWidget()
                layout = QVBoxLayout()
                layout.addWidget(QLabel("ðŸ›¡ï¸ Anti-Crash Mode Active"))
                layout.addWidget(QLabel(f"Error: {str(e)}"))
                layout.addWidget(QLabel("App is protected and running safely"))
                window.setLayout(layout)
                window.setWindowTitle("Trading Bot - Safe Mode")
                window.show()
                app.exec_()
            else:
                print("ðŸ’» Console mode recovery - keeping app alive...")
                input("Press Enter to exit safely...")
        except:
            print("âŒ Emergency recovery failed, but app continues...")

def safe_main():
    """Ultra-safe main wrapper with crash protection"""
    try:
        print("[START] Starting Trading Bot with Anti-Crash Protection...")
        main_original()  # Call main_original directly - it works perfectly
        print("[OK] Trading Bot completed successfully!")
        
    except KeyboardInterrupt:
        print("\n[INTERRUPT] User interrupted - shutting down gracefully...")
        
    except Exception as e:
        error_msg = f"App crashed: {type(e).__name__}: {str(e)}"
        print(f"\n[ERROR] {error_msg}")
        
        # Log the crash
        try:
            crash_log = f"logs/safe_main_crash_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log"
            os.makedirs("logs", exist_ok=True)
            with open(crash_log, 'w', encoding='utf-8') as f:
                f.write(f"Safe Main Crash: {datetime.now()}\n")
                f.write(f"Error: {type(e).__name__}: {str(e)}\n\n")
                f.write("Traceback:\n")
                traceback.print_exc(file=f)
            print(f"[SAVE] Crash log saved: {crash_log}")
        except:
            pass
        
        print("[SAFE] Anti-crash protection activated - app stays safe")

def emergency_cleanup():
    """Emergency cleanup for all threads and processes"""
    try:
        print("[CLEANUP] EMERGENCY CLEANUP - Stopping all threads and processes...")
        
        # Kill any remaining subprocess
        import psutil
        current_process = psutil.Process()
        children = current_process.children(recursive=True)
        
        for child in children:
            try:
                child.terminate()
                child.wait(timeout=2)
            except:
                try:
                    child.kill()
                except:
                    pass
        
        # Force cleanup of QApplication if exists
        if GUI_AVAILABLE:
            try:
                from PyQt5.QtWidgets import QApplication
                app = QApplication.instance()
                if app:
                    app.quit()
                    app.processEvents()
            except:
                pass
                
        print("[OK] Emergency cleanup completed")
        
    except Exception as e:
        print(f"[ERROR] Emergency cleanup error: {e}")

if __name__ == "__main__":
    try:
        safe_main()
    except KeyboardInterrupt:
        print("\n[INTERRUPT] Keyboard interrupt - emergency shutdown...")
        emergency_cleanup()
    except Exception as e:
        print(f"\n[ERROR] Final exception: {e}")
        emergency_cleanup()
    finally:
        print("[END] Application shutdown complete")
    
# --- Added global graceful shutdown utility (non-invasive) ---
def graceful_shutdown_threads(thread_containers: list):
    """Gracefully stop QThreads to prevent 'QThread: Destroyed while thread is still running'.

    Provide a list of containers/objects that may have attributes holding QThread instances
    e.g., ['pattern_tab', 'price_pattern_tab'] or direct lists. Call this before QApplication quits.
    """
    try:
        import inspect
        visited = set()
        threads = []
        def collect(obj):
            try:
                if obj is None: return
                if isinstance(obj, (list, tuple, set)):
                    for x in obj: collect(x)
                    return
                # Introspect attributes
                for name in dir(obj):
                    if name.startswith('_'): continue
                    try:
                        val = getattr(obj, name)
                    except Exception:
                        continue
                    if id(val) in visited: continue
                    visited.add(id(val))
                    # QThread heuristic: has isRunning and quit
                    if hasattr(val, 'isRunning') and hasattr(val, 'quit'):
                        threads.append(val)
                    elif isinstance(val, (list, tuple, set)):
                        collect(val)
            except Exception:
                pass
        for c in thread_containers:
            collect(c)
        uniq = []
        seen = set()
        for t in threads:
            if id(t) not in seen:
                uniq.append(t); seen.add(id(t))
        if not uniq:
            return
        print(f"ðŸ›‘ Graceful shutdown: {len(uniq)} thread(s) detected")
        for t in uniq:
            try:
                if hasattr(t, 'requestInterruption'):
                    t.requestInterruption()
                t.quit()
            except Exception:
                continue
        for t in uniq:
            try:
                t.wait(3000)
            except Exception:
                continue
        print("âœ… Threads terminated")
    except Exception as e:
        print(f"âš ï¸ graceful_shutdown_threads error: {e}")
